/**
 * Consciousness Synchronizer
 *
 * This module provides a synchronizer for consciousness streams,
 * ensuring coherent state across multiple streams.
 *
 * @version 1.0.0
 */
import { v4 as uuidv4 } from 'uuid';
import { ConsciousnessStreamManager } from '../ConsciousnessStreamProtocol';
import { QuantumStateManager } from '../../quantum/QuantumStateManager';
import { QuantumCoherenceVerifier } from '../../quantum/QuantumCoherenceVerifier';
/**
 * Synchronization status
 */
export var SynchronizationStatus;
(function (SynchronizationStatus) {
    SynchronizationStatus["PENDING"] = "pending";
    SynchronizationStatus["COMPLETED"] = "completed";
    SynchronizationStatus["FAILED"] = "failed";
})(SynchronizationStatus || (SynchronizationStatus = {}));
/**
 * Synchronization strategy
 */
export var SynchronizationStrategy;
(function (SynchronizationStrategy) {
    SynchronizationStrategy["FULL"] = "full";
    SynchronizationStrategy["INCREMENTAL"] = "incremental";
    SynchronizationStrategy["SELECTIVE"] = "selective";
})(SynchronizationStrategy || (SynchronizationStrategy = {}));
/**
 * Consciousness Synchronizer
 */
export class ConsciousnessSynchronizer {
    /**
     * Constructor
     */
    constructor() {
        this.streamManager = new ConsciousnessStreamManager();
        this.stateManager = new QuantumStateManager();
        this.coherenceVerifier = new QuantumCoherenceVerifier();
        this.synchronizations = new Map();
    }
    /**
     * Synchronize consciousness streams
     */
    synchronizeStreams(sourceStreamId, targetStreamId, options) {
        // Get streams
        const sourceStream = this.streamManager.getStream(sourceStreamId);
        const targetStream = this.streamManager.getStream(targetStreamId);
        if (!sourceStream) {
            throw new Error(`Source stream ${sourceStreamId} not found`);
        }
        if (!targetStream) {
            throw new Error(`Target stream ${targetStreamId} not found`);
        }
        // Create synchronization result
        const synchronizationId = uuidv4();
        const result = {
            id: synchronizationId,
            sourceStreamId,
            targetStreamId,
            status: SynchronizationStatus.PENDING,
            timestamp: Date.now(),
            packetsSent: 0,
            packetsReceived: 0,
            coherenceScore: 0,
        };
        this.synchronizations.set(synchronizationId, result);
        try {
            // Perform synchronization based on strategy
            switch (options.strategy) {
                case SynchronizationStrategy.FULL:
                    this.performFullSynchronization(result, sourceStream, targetStream, options);
                    break;
                case SynchronizationStrategy.INCREMENTAL:
                    this.performIncrementalSynchronization(result, sourceStream, targetStream, options);
                    break;
                case SynchronizationStrategy.SELECTIVE:
                    this.performSelectiveSynchronization(result, sourceStream, targetStream, options);
                    break;
            }
            // Verify coherence
            result.coherenceScore = this.verifyCoherence(sourceStream, targetStream);
            // Update result
            result.status = SynchronizationStatus.COMPLETED;
            result.completedTimestamp = Date.now();
            return result;
        }
        catch (error) {
            // Update result with error
            result.status = SynchronizationStatus.FAILED;
            result.completedTimestamp = Date.now();
            result.error = error instanceof Error ? error.message : String(error);
            return result;
        }
    }
    /**
     * Get synchronization result
     */
    getSynchronization(synchronizationId) {
        return this.synchronizations.get(synchronizationId);
    }
    /**
     * Get all synchronization results
     */
    getAllSynchronizations() {
        return Array.from(this.synchronizations.values());
    }
    /**
     * Perform full synchronization
     */
    performFullSynchronization(result, sourceStream, targetStream, options) {
        // Get all packets from source stream
        const sourcePackets = this.streamManager.getStreamPackets(sourceStream.id);
        // Send all packets to target stream
        for (const packet of sourcePackets) {
            this.synchronizePacket(result, packet, targetStream, options);
        }
        // If bidirectional, synchronize from target to source
        if (options.bidirectional) {
            const targetPackets = this.streamManager.getStreamPackets(targetStream.id);
            for (const packet of targetPackets) {
                this.synchronizePacket(result, packet, sourceStream, options);
            }
        }
    }
    /**
     * Perform incremental synchronization
     */
    performIncrementalSynchronization(result, sourceStream, targetStream, options) {
        // Get latest synchronization between these streams
        const latestSynchronization = this.getLatestSynchronization(sourceStream.id, targetStream.id);
        // If no previous synchronization, perform full synchronization
        if (!latestSynchronization) {
            this.performFullSynchronization(result, sourceStream, targetStream, options);
            return;
        }
        // Get packets since last synchronization
        const sourcePackets = this.streamManager.getStreamPacketsSince(sourceStream.id, latestSynchronization.completedTimestamp || latestSynchronization.timestamp);
        // Send new packets to target stream
        for (const packet of sourcePackets) {
            this.synchronizePacket(result, packet, targetStream, options);
        }
        // If bidirectional, synchronize from target to source
        if (options.bidirectional) {
            const targetPackets = this.streamManager.getStreamPacketsSince(targetStream.id, latestSynchronization.completedTimestamp || latestSynchronization.timestamp);
            for (const packet of targetPackets) {
                this.synchronizePacket(result, packet, sourceStream, options);
            }
        }
    }
    /**
     * Perform selective synchronization
     */
    performSelectiveSynchronization(result, sourceStream, targetStream, options) {
        if (!options.selectiveProperties || options.selectiveProperties.length === 0) {
            throw new Error('Selective properties are required for selective synchronization');
        }
        // Get all packets from source stream
        const sourcePackets = this.streamManager.getStreamPackets(sourceStream.id);
        // Filter packets by selective properties
        const filteredPackets = sourcePackets.filter(packet => {
            const packetData = packet.payload.data;
            if (!packetData) {
                return false;
            }
            // Check if packet contains any of the selective properties
            return options.selectiveProperties.some(property => property in packetData);
        });
        // Send filtered packets to target stream
        for (const packet of filteredPackets) {
            this.synchronizePacket(result, packet, targetStream, options);
        }
        // If bidirectional, synchronize from target to source
        if (options.bidirectional) {
            const targetPackets = this.streamManager.getStreamPackets(targetStream.id);
            const filteredTargetPackets = targetPackets.filter(packet => {
                const packetData = packet.payload.data;
                if (!packetData) {
                    return false;
                }
                // Check if packet contains any of the selective properties
                return options.selectiveProperties.some(property => property in packetData);
            });
            for (const packet of filteredTargetPackets) {
                this.synchronizePacket(result, packet, sourceStream, options);
            }
        }
    }
    /**
     * Synchronize packet
     */
    synchronizePacket(result, packet, targetStream, options) {
        // Create new packet for target stream
        const newPacket = {
            header: {
                streamId: targetStream.id,
                sourceId: packet.header.sourceId,
                targetId: packet.header.targetId,
                contextPreservationFlags: {
                    preserveQuantumState: options.preserveQuantumState,
                    preserveContext: options.preserveContext,
                },
            },
            payload: {
                data: packet.payload.data,
            },
        };
        // Add quantum state if preserving
        if (options.preserveQuantumState && packet.payload.quantumState) {
            newPacket.payload.quantumState = packet.payload.quantumState;
        }
        // Send packet to target stream
        this.streamManager.sendPacket(targetStream.id, newPacket);
        // Update result
        result.packetsSent++;
        result.packetsReceived++;
    }
    /**
     * Get latest synchronization between streams
     */
    getLatestSynchronization(sourceStreamId, targetStreamId) {
        const synchronizations = Array.from(this.synchronizations.values())
            .filter(sync => (sync.sourceStreamId === sourceStreamId && sync.targetStreamId === targetStreamId) ||
            (sync.sourceStreamId === targetStreamId && sync.targetStreamId === sourceStreamId))
            .filter(sync => sync.status === SynchronizationStatus.COMPLETED)
            .sort((a, b) => (b.completedTimestamp || b.timestamp) - (a.completedTimestamp || a.timestamp));
        return synchronizations[0];
    }
    /**
     * Verify coherence between streams
     */
    verifyCoherence(sourceStream, targetStream) {
        // Get quantum states from streams
        const sourceQuantumStates = this.getStreamQuantumStates(sourceStream.id);
        const targetQuantumStates = this.getStreamQuantumStates(targetStream.id);
        // If no quantum states, return default coherence
        if (sourceQuantumStates.length === 0 || targetQuantumStates.length === 0) {
            return 1.0;
        }
        // Verify coherence between quantum states
        const coherenceScores = [];
        for (const sourceState of sourceQuantumStates) {
            for (const targetState of targetQuantumStates) {
                const result = this.coherenceVerifier.verifyCoherence(sourceState, targetState);
                coherenceScores.push(result.coherenceScore);
            }
        }
        // Calculate average coherence score
        return coherenceScores.reduce((sum, score) => sum + score, 0) / coherenceScores.length;
    }
    /**
     * Get quantum states from stream
     */
    getStreamQuantumStates(streamId) {
        const packets = this.streamManager.getStreamPackets(streamId);
        const quantumStateIds = new Set();
        // Collect unique quantum state IDs
        for (const packet of packets) {
            if (packet.payload.quantumState?.id) {
                quantumStateIds.add(packet.payload.quantumState.id);
            }
        }
        // Get quantum states
        const quantumStates = [];
        for (const stateId of quantumStateIds) {
            const state = this.stateManager.getState(stateId);
            if (state) {
                quantumStates.push(state);
            }
        }
        return quantumStates;
    }
}
