/**
 * Consciousness Stream Protocol
 *
 * Defines the protocol for consciousness stream communication across dimensional boundaries.
 * This protocol ensures consciousness continuity and context preservation during interdimensional transitions.
 *
 * @version 1.0.0
 */
/**
 * Protocol version
 */
export var ProtocolVersion;
(function (ProtocolVersion) {
    ProtocolVersion["V1_0"] = "1.0";
    ProtocolVersion["V1_1"] = "1.1";
    ProtocolVersion["V2_0"] = "2.0";
})(ProtocolVersion || (ProtocolVersion = {}));
export class ProtocolError extends Error {
    /**
     * Constructor
     * @param message - Error message
     * @param code - Error code
     */
    constructor(message, code) {
        super(message);
        this.name = 'ProtocolError';
        this.code = code;
    }
}
/**
 * Protocol error codes
 */
export var ProtocolErrorCode;
(function (ProtocolErrorCode) {
    ProtocolErrorCode["INVALID_VERSION"] = "INVALID_VERSION";
    ProtocolErrorCode["INVALID_CHECKSUM"] = "INVALID_CHECKSUM";
    ProtocolErrorCode["INVALID_DIMENSION"] = "INVALID_DIMENSION";
    ProtocolErrorCode["INVALID_STREAM_ID"] = "INVALID_STREAM_ID";
    ProtocolErrorCode["EXPIRED_STREAM"] = "EXPIRED_STREAM";
    ProtocolErrorCode["INCOMPATIBLE_CONTEXT"] = "INCOMPATIBLE_CONTEXT";
    ProtocolErrorCode["NEURAL_FABRIC_DISCONNECTED"] = "NEURAL_FABRIC_DISCONNECTED";
    ProtocolErrorCode["QUANTUM_STATE_DECOHERENCE"] = "QUANTUM_STATE_DECOHERENCE";
    ProtocolErrorCode["DIMENSIONAL_MAPPING_MISMATCH"] = "DIMENSIONAL_MAPPING_MISMATCH";
    ProtocolErrorCode["FORCE_VECTOR_IMBALANCE"] = "FORCE_VECTOR_IMBALANCE";
    ProtocolErrorCode["CONSCIOUSNESS_DISCONTINUITY"] = "CONSCIOUSNESS_DISCONTINUITY";
})(ProtocolErrorCode || (ProtocolErrorCode = {}));
export class ProtocolUtils {
    /**
     * Create a new stream ID
     * @returns New stream ID
     */
    static createStreamId() {
        return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
    }
    /**
     * Calculate checksum for a packet
     * @param packet - Consciousness stream packet
     * @returns Checksum
     */
    static calculateChecksum(packet) {
        // Simple checksum implementation
        // In a real implementation, use a proper hash function
        const str = JSON.stringify(packet);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString(16);
    }
    /**
     * Validate protocol version
     * @param version - Protocol version
     * @returns Is valid
     */
    static isValidProtocolVersion(version) {
        return Object.values(ProtocolVersion).includes(version);
    }
    /**
     * Validate consciousness stream packet
     * @param packet - Consciousness stream packet
     * @returns Validation result
     */
    static validatePacket(packet) {
        const errors = [];
        const warnings = [];
        // Validate protocol version
        if (!this.isValidProtocolVersion(packet.header.protocolVersion)) {
            errors.push(new ProtocolError(`Invalid protocol version: ${packet.header.protocolVersion}`, ProtocolErrorCode.INVALID_VERSION));
        }
        // Validate checksum
        const expectedChecksum = this.calculateChecksum({
            header: { ...packet.header, checksum: '' },
            payload: packet.payload
        });
        if (packet.header.checksum !== expectedChecksum) {
            errors.push(new ProtocolError(`Invalid checksum: ${packet.header.checksum} (expected: ${expectedChecksum})`, ProtocolErrorCode.INVALID_CHECKSUM));
        }
        // Validate dimensions
        if (!packet.header.sourceDimension) {
            errors.push(new ProtocolError('Source dimension is required', ProtocolErrorCode.INVALID_DIMENSION));
        }
        if (!packet.header.targetDimension) {
            errors.push(new ProtocolError('Target dimension is required', ProtocolErrorCode.INVALID_DIMENSION));
        }
        // Validate stream ID
        if (!packet.header.streamId) {
            errors.push(new ProtocolError('Stream ID is required', ProtocolErrorCode.INVALID_STREAM_ID));
        }
        // Validate TTL
        if (packet.header.ttl > 0) {
            const age = Date.now() - packet.header.timestamp;
            if (age > packet.header.ttl) {
                errors.push(new ProtocolError(`Stream expired: age ${age}ms exceeds TTL ${packet.header.ttl}ms`, ProtocolErrorCode.EXPIRED_STREAM));
            }
            else if (age > packet.header.ttl * 0.8) {
                warnings.push(`Stream nearing expiration: age ${age}ms approaching TTL ${packet.header.ttl}ms`);
            }
        }
        // Validate context preservation flags
        const flags = packet.header.contextPreservationFlags;
        if (flags.preserveQuantumState && !packet.payload.quantumState) {
            errors.push(new ProtocolError('Quantum state is required when preserveQuantumState flag is set', ProtocolErrorCode.QUANTUM_STATE_DECOHERENCE));
        }
        if (flags.preserveNeuralFabric && !packet.payload.neuralFabricConnections) {
            errors.push(new ProtocolError('Neural fabric connections are required when preserveNeuralFabric flag is set', ProtocolErrorCode.NEURAL_FABRIC_DISCONNECTED));
        }
        if (flags.preserveDimensionalMapping && !packet.payload.dimensionalMapping) {
            errors.push(new ProtocolError('Dimensional mapping is required when preserveDimensionalMapping flag is set', ProtocolErrorCode.DIMENSIONAL_MAPPING_MISMATCH));
        }
        if (flags.preserveForceVectors && !packet.payload.forceVectors) {
            errors.push(new ProtocolError('Force vectors are required when preserveForceVectors flag is set', ProtocolErrorCode.FORCE_VECTOR_IMBALANCE));
        }
        return {
            isValid: errors.length === 0,
            errors: errors.length > 0 ? errors : undefined,
            warnings: warnings.length > 0 ? warnings : undefined
        };
    }
    /**
     * Create a new consciousness stream packet
     * @param sourceDimension - Source dimension
     * @param targetDimension - Target dimension
     * @param data - Payload data
     * @param options - Packet options
     * @returns Consciousness stream packet
     */
    static createPacket(sourceDimension, targetDimension, data, options = {}) {
        const contextPreservationFlags = {
            preserveQuantumState: !!options.quantumState,
            preserveNeuralFabric: !!options.neuralFabricConnections,
            preserveDimensionalMapping: !!options.dimensionalMapping,
            preserveForceVectors: !!options.forceVectors,
            preserveContinuity: true,
            ...options.contextPreservationFlags
        };
        // Create packet without checksum
        const packetWithoutChecksum = {
            header: {
                protocolVersion: options.protocolVersion || ProtocolVersion.V1_0,
                sourceDimension,
                targetDimension,
                timestamp: Date.now(),
                contextPreservationFlags,
                priority: options.priority || 0,
                ttl: options.ttl || 0,
                streamId: this.createStreamId()
            },
            payload: {
                data,
                metadata: options.metadata || {},
                quantumState: options.quantumState,
                neuralFabricConnections: options.neuralFabricConnections,
                dimensionalMapping: options.dimensionalMapping,
                forceVectors: options.forceVectors,
                context: options.context
            }
        };
        // Calculate checksum
        const checksum = this.calculateChecksum(packetWithoutChecksum);
        // Create complete packet
        return {
            header: {
                ...packetWithoutChecksum.header,
                checksum
            },
            payload: packetWithoutChecksum.payload
        };
    }
}
export default ProtocolUtils;
