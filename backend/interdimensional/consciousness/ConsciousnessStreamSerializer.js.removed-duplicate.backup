/**
 * Consciousness Stream Serializer
 *
 * Provides serialization and deserialization functions for consciousness stream packets.
 * Ensures context preservation during serialization and deserialization.
 *
 * @version 1.0.0
 */
import { ProtocolError, ProtocolErrorCode, ProtocolUtils } from './ConsciousnessStreamProtocol';
/**
 * Serialization format
 */
export var SerializationFormat;
(function (SerializationFormat) {
    SerializationFormat["JSON"] = "json";
    SerializationFormat["BINARY"] = "binary";
    SerializationFormat["QUANTUM"] = "quantum";
})(SerializationFormat || (SerializationFormat = {}));
/**
 * Default serialization options
 */
const DEFAULT_OPTIONS = {
    format: SerializationFormat.JSON,
    compression: false,
    encryption: false,
    contextPreservationLevel: 1.0
};
/**
 * Default deserialization options
 */
const DEFAULT_DESERIALIZATION_OPTIONS = {
    contextRestorationLevel: 1.0,
    validate: true
};
/**
 * Consciousness stream serializer
 */
export class ConsciousnessStreamSerializer {
    static serialize(packet, options = {}) {
        // Merge options with defaults
        const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
        // Validate packet before serialization
        const validationResult = ProtocolUtils.validatePacket(packet);
        if (!validationResult.isValid) {
            throw new ProtocolError(`Cannot serialize invalid packet: ${validationResult.errors?.[0]?.message}`, validationResult.errors?.[0]?.code || ProtocolErrorCode.INVALID_STREAM_ID);
        }
        // Prepare packet for serialization
        const preparedPacket = this.preparePacketForSerialization(packet, mergedOptions.contextPreservationLevel || 1.0);
        // Serialize based on format
        let serialized;
        switch (mergedOptions.format) {
            case SerializationFormat.JSON:
                serialized = JSON.stringify(preparedPacket);
                break;
            case SerializationFormat.BINARY:
                serialized = this.serializeToBinary(preparedPacket);
                break;
            case SerializationFormat.QUANTUM:
                serialized = this.serializeToQuantum(preparedPacket);
                break;
            default:
                serialized = JSON.stringify(preparedPacket);
                break;
        }
        // Apply compression if enabled
        if (mergedOptions.compression) {
            serialized = this.compress(serialized);
        }
        // Apply encryption if enabled
        if (mergedOptions.encryption) {
            if (!mergedOptions.encryptionKey) {
                throw new ProtocolError('Encryption key is required when encryption is enabled', ProtocolErrorCode.INVALID_STREAM_ID);
            }
            serialized = this.encrypt(serialized, mergedOptions.encryptionKey);
        }
        return {
            data: serialized,
            format: mergedOptions.format || SerializationFormat.JSON,
            compressed: !!mergedOptions.compression,
            encrypted: !!mergedOptions.encryption,
            contextPreservationLevel: mergedOptions.contextPreservationLevel || 1.0
        };
    }
    /**
     * Deserialize consciousness stream packet
     * @param data - Serialized data
     * @param options - Deserialization options
     * @returns Deserialization result
     */
    static deserialize(data, options = {}) {
        // Merge options with defaults
        const mergedOptions = { ...DEFAULT_DESERIALIZATION_OPTIONS, ...options };
        // Detect format if not specified
        const format = mergedOptions.expectedFormat || this.detectFormat(data);
        // Track serialization properties
        let wasCompressed = false;
        let wasEncrypted = false;
        // Decrypt if encrypted
        if (this.isEncrypted(data)) {
            if (!mergedOptions.decryptionKey) {
                throw new ProtocolError('Decryption key is required for encrypted data', ProtocolErrorCode.INVALID_STREAM_ID);
            }
            data = this.decrypt(data, mergedOptions.decryptionKey);
            wasEncrypted = true;
        }
        // Decompress if compressed
        if (this.isCompressed(data)) {
            data = this.decompress(data);
            wasCompressed = true;
        }
        // Deserialize based on format
        let packet;
        switch (format) {
            case SerializationFormat.JSON:
                packet = this.deserializeFromJson(data);
                break;
            case SerializationFormat.BINARY:
                packet = this.deserializeFromBinary(data);
                break;
            case SerializationFormat.QUANTUM:
                packet = this.deserializeFromQuantum(data);
                break;
            default:
                throw new ProtocolError(`Unsupported serialization format: ${format}`, ProtocolErrorCode.INVALID_VERSION);
        }
        // Restore context
        packet = this.restorePacketContext(packet, mergedOptions.contextRestorationLevel || 1.0);
        // Validate if requested
        let validationResult;
        if (mergedOptions.validate) {
            validationResult = ProtocolUtils.validatePacket(packet);
            if (!validationResult.isValid) {
                console.warn(`Deserialized packet is invalid: ${validationResult.errors?.[0]?.message}`);
            }
        }
        return {
            packet,
            originalFormat: format,
            wasCompressed,
            wasEncrypted,
            contextRestorationLevel: mergedOptions.contextRestorationLevel || 1.0,
            validationResult
        };
    }
    /**
     * Prepare packet for serialization
     * @param packet - Consciousness stream packet
     * @param contextPreservationLevel - Context preservation level
     * @returns Prepared packet
     */
    static preparePacketForSerialization(packet, contextPreservationLevel) {
        // Clone packet to avoid modifying the original
        const clonedPacket = JSON.parse(JSON.stringify(packet));
        // Apply context preservation level
        if (contextPreservationLevel < 1.0) {
            const flags = clonedPacket.header.contextPreservationFlags;
            // Reduce context based on preservation level
            if (contextPreservationLevel < 0.8) {
                // Remove non-essential context
                if (flags.preserveForceVectors) {
                    delete clonedPacket.payload.forceVectors;
                    flags.preserveForceVectors = false;
                }
            }
            if (contextPreservationLevel < 0.6) {
                // Remove dimensional mapping
                if (flags.preserveDimensionalMapping) {
                    delete clonedPacket.payload.dimensionalMapping;
                    flags.preserveDimensionalMapping = false;
                }
            }
            if (contextPreservationLevel < 0.4) {
                // Remove neural fabric connections
                if (flags.preserveNeuralFabric) {
                    delete clonedPacket.payload.neuralFabricConnections;
                    flags.preserveNeuralFabric = false;
                }
            }
            if (contextPreservationLevel < 0.2) {
                // Remove quantum state
                if (flags.preserveQuantumState) {
                    delete clonedPacket.payload.quantumState;
                    flags.preserveQuantumState = false;
                }
            }
        }
        return clonedPacket;
    }
    /**
     * Restore packet context
     * @param packet - Consciousness stream packet
     * @param contextRestorationLevel - Context restoration level
     * @returns Restored packet
     */
    static restorePacketContext(packet, contextRestorationLevel) {
        // Clone packet to avoid modifying the original
        const clonedPacket = JSON.parse(JSON.stringify(packet));
        // No additional restoration needed if level is high enough
        if (contextRestorationLevel >= 0.8) {
            return clonedPacket;
        }
        // Restore missing context based on what's available
        const flags = clonedPacket.header.contextPreservationFlags;
        // Restore quantum state if missing but flag is set
        if (flags.preserveQuantumState && !clonedPacket.payload.quantumState) {
            clonedPacket.payload.quantumState = {
                coherenceLevel: 1.0,
                lastUpdated: new Date()
            };
        }
        // Restore neural fabric connections if missing but flag is set
        if (flags.preserveNeuralFabric && !clonedPacket.payload.neuralFabricConnections) {
            clonedPacket.payload.neuralFabricConnections = [];
        }
        // Restore dimensional mapping if missing but flag is set
        if (flags.preserveDimensionalMapping && !clonedPacket.payload.dimensionalMapping) {
            clonedPacket.payload.dimensionalMapping = {};
        }
        // Restore force vectors if missing but flag is set
        if (flags.preserveForceVectors && !clonedPacket.payload.forceVectors) {
            clonedPacket.payload.forceVectors = {};
        }
        return clonedPacket;
    }
    /**
     * Serialize to binary
     * @param packet - Consciousness stream packet
     * @returns Binary data
     */
    static serializeToBinary(packet) {
        // In a real implementation, use a proper binary serialization library
        // For this example, we'll convert JSON to a Uint8Array
        const jsonString = JSON.stringify(packet);
        const encoder = new TextEncoder();
        return encoder.encode(jsonString);
    }
    /**
     * Serialize to quantum
     * @param packet - Consciousness stream packet
     * @returns Quantum data
     */
    static serializeToQuantum(packet) {
        // In a real implementation, this would use quantum serialization
        // For this example, we'll just use binary serialization with a header
        const binaryData = this.serializeToBinary(packet);
        const quantumHeader = new Uint8Array([0x51, 0x55, 0x41, 0x4E, 0x54, 0x55, 0x4D]); // "QUANTUM" in ASCII
        // Combine header and data
        const result = new Uint8Array(quantumHeader.length + binaryData.length);
        result.set(quantumHeader);
        result.set(binaryData, quantumHeader.length);
        return result;
    }
    /**
     * Deserialize from JSON
     * @param data - JSON string
     * @returns Consciousness stream packet
     */
    static deserializeFromJson(data) {
        try {
            return JSON.parse(data);
        }
        catch (error) {
            throw new ProtocolError(`Failed to parse JSON: ${error.message}`, ProtocolErrorCode.INVALID_STREAM_ID);
        }
    }
    /**
     * Deserialize from binary
     * @param data - Binary data
     * @returns Consciousness stream packet
     */
    static deserializeFromBinary(data) {
        try {
            // In a real implementation, use a proper binary deserialization library
            // For this example, we'll convert Uint8Array to JSON
            const decoder = new TextDecoder();
            const jsonString = decoder.decode(data);
            return this.deserializeFromJson(jsonString);
        }
        catch (error) {
            throw new ProtocolError(`Failed to deserialize binary data: ${error.message}`, ProtocolErrorCode.INVALID_STREAM_ID);
        }
    }
    /**
     * Deserialize from quantum
     * @param data - Quantum data
     * @returns Consciousness stream packet
     */
    static deserializeFromQuantum(data) {
        try {
            // In a real implementation, this would use quantum deserialization
            // For this example, we'll just check for the header and use binary deserialization
            const quantumHeader = new Uint8Array([0x51, 0x55, 0x41, 0x4E, 0x54, 0x55, 0x4D]); // "QUANTUM" in ASCII
            // Check header
            for (let i = 0; i < quantumHeader.length; i++) {
                if (data[i] !== quantumHeader[i]) {
                    throw new Error('Invalid quantum header');
                }
            }
            // Extract data without header
            const binaryData = data.slice(quantumHeader.length);
            return this.deserializeFromBinary(binaryData);
        }
        catch (error) {
            throw new ProtocolError(`Failed to deserialize quantum data: ${error.message}`, ProtocolErrorCode.INVALID_STREAM_ID);
        }
    }
    /**
     * Detect serialization format
     * @param data - Serialized data
     * @returns Detected format
     */
    static detectFormat(data) {
        if (typeof data === 'string') {
            // Assume JSON for string data
            return SerializationFormat.JSON;
        }
        // Check for quantum header
        const quantumHeader = new Uint8Array([0x51, 0x55, 0x41, 0x4E, 0x54, 0x55, 0x4D]); // "QUANTUM" in ASCII
        let isQuantum = true;
        for (let i = 0; i < quantumHeader.length; i++) {
            if (data[i] !== quantumHeader[i]) {
                isQuantum = false;
                break;
            }
        }
        if (isQuantum) {
            return SerializationFormat.QUANTUM;
        }
        // Default to binary for Uint8Array data
        return SerializationFormat.BINARY;
    }
    /**
     * Compress data
     * @param data - Data to compress
     * @returns Compressed data
     */
    static compress(data) {
        // In a real implementation, use a proper compression library
        // For this example, we'll just add a compression header
        if (typeof data === 'string') {
            const encoder = new TextEncoder();
            data = encoder.encode(data);
        }
        const compressionHeader = new Uint8Array([0x43, 0x4F, 0x4D, 0x50]); // "COMP" in ASCII
        // Combine header and data
        const result = new Uint8Array(compressionHeader.length + data.length);
        result.set(compressionHeader);
        result.set(data, compressionHeader.length);
        return result;
    }
    /**
     * Decompress data
     * @param data - Compressed data
     * @returns Decompressed data
     */
    static decompress(data) {
        // In a real implementation, use a proper decompression library
        // For this example, we'll just check for the compression header and return the data
        const compressionHeader = new Uint8Array([0x43, 0x4F, 0x4D, 0x50]); // "COMP" in ASCII
        // Check header
        for (let i = 0; i < compressionHeader.length; i++) {
            if (data[i] !== compressionHeader[i]) {
                throw new Error('Invalid compression header');
            }
        }
        // Extract data without header
        return data.slice(compressionHeader.length);
    }
    /**
     * Check if data is compressed
     * @param data - Data to check
     * @returns Is compressed
     */
    static isCompressed(data) {
        if (typeof data === 'string') {
            return false;
        }
        const compressionHeader = new Uint8Array([0x43, 0x4F, 0x4D, 0x50]); // "COMP" in ASCII
        if (data.length < compressionHeader.length) {
            return false;
        }
        // Check header
        for (let i = 0; i < compressionHeader.length; i++) {
            if (data[i] !== compressionHeader[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Encrypt data
     * @param data - Data to encrypt
     * @param key - Encryption key
     * @returns Encrypted data
     */
    static encrypt(data, key) {
        // In a real implementation, use a proper encryption library
        // For this example, we'll just add an encryption header
        if (typeof data === 'string') {
            const encoder = new TextEncoder();
            data = encoder.encode(data);
        }
        const encryptionHeader = new Uint8Array([0x45, 0x4E, 0x43, 0x52]); // "ENCR" in ASCII
        // Combine header and data
        const result = new Uint8Array(encryptionHeader.length + data.length);
        result.set(encryptionHeader);
        result.set(data, encryptionHeader.length);
        return result;
    }
    /**
     * Decrypt data
     * @param data - Encrypted data
     * @param key - Decryption key
     * @returns Decrypted data
     */
    static decrypt(data, key) {
        // In a real implementation, use a proper decryption library
        // For this example, we'll just check for the encryption header and return the data
        if (typeof data === 'string') {
            throw new Error('Cannot decrypt string data');
        }
        const encryptionHeader = new Uint8Array([0x45, 0x4E, 0x43, 0x52]); // "ENCR" in ASCII
        // Check header
        for (let i = 0; i < encryptionHeader.length; i++) {
            if (data[i] !== encryptionHeader[i]) {
                throw new Error('Invalid encryption header');
            }
        }
        // Extract data without header
        return data.slice(encryptionHeader.length);
    }
    /**
     * Check if data is encrypted
     * @param data - Data to check
     * @returns Is encrypted
     */
    static isEncrypted(data) {
        if (typeof data === 'string') {
            return false;
        }
        const encryptionHeader = new Uint8Array([0x45, 0x4E, 0x43, 0x52]); // "ENCR" in ASCII
        if (data.length < encryptionHeader.length) {
            return false;
        }
        // Check header
        for (let i = 0; i < encryptionHeader.length; i++) {
            if (data[i] !== encryptionHeader[i]) {
                return false;
            }
        }
        return true;
    }
}
export default ConsciousnessStreamSerializer;
