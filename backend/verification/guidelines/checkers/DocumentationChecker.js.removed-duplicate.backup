"use strict";
/**
 * DocumentationChecker
 *
 * Checks compliance with documentation guidelines.
 *
 * @version 1.0.0
 */
const fs = require('fs').promises;
const path = require('path');
const { EventEmitter } = require('events');
/**
 * DocumentationChecker
 *
 * Checks compliance with documentation guidelines.
 */
class DocumentationChecker extends EventEmitter {
    /**
     * Create a new DocumentationChecker instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Base directory
            baseDir: process.cwd(),
            // Whether to enforce all guidelines strictly
            strictMode: true,
            // Merge with provided options
            ...options,
        };
    }
    /**
     * Check documentation compliance
     * @param {string} targetPath - Path to the implementation to check
     * @param {boolean} isDirectory - Whether the target is a directory
     * @param {Object} options - Check options
     * @returns {Promise<Object>} Check result
     */
    async check(targetPath, isDirectory, options = {}) {
        try {
            this.log(`Checking documentation compliance for: ${targetPath}`);
            // Get component name
            const componentName = path.basename(targetPath);
            // Check component guide
            const componentGuideResult = await this._checkComponentGuide(componentName);
            // Check example file
            const exampleFileResult = await this._checkExampleFile(componentName);
            // Check JSDoc comments
            const jsDocResult = await this._checkJSDocComments(targetPath, isDirectory);
            // Collect violations
            const violations = [
                ...componentGuideResult.violations,
                ...exampleFileResult.violations,
                ...jsDocResult.violations,
            ];
            this.log(`Documentation compliance check completed for: ${targetPath}`);
            return {
                componentGuide: componentGuideResult,
                exampleFile: exampleFileResult,
                jsDocComments: jsDocResult,
                violations,
            };
        }
        catch (error) {
            this.log(`Documentation check error: ${error.message}`);
            return {
                error: error.message,
                violations: [],
            };
        }
    }
    /**
     * Check component guide
     * @param {string} componentName - Component name
     * @returns {Promise<Object>} Check result
     * @private
     */
    async _checkComponentGuide(componentName) {
        try {
            this.log(`Checking component guide for: ${componentName}`);
            // Convert component name to kebab-case for guide filename
            const guideFilename = this._toKebabCase(componentName) + '-guide.md';
            // Check if guide exists
            const guidePath = path.resolve(this.config.baseDir, 'docs', 'guides', guideFilename);
            const guideExists = await fs.stat(guidePath).catch(() => null);
            if (!guideExists) {
                return {
                    compliant: false,
                    violations: [
                        {
                            guideline: 'documentation.componentGuides',
                            path: guidePath,
                            message: `Component guide not found: ${guideFilename}`,
                            severity: 'critical',
                        },
                    ],
                };
            }
            // Check guide content
            const guideContent = await fs.readFile(guidePath, 'utf8');
            // Check if guide has required sections
            const requiredSections = [
                '# ', // Title
                '## Overview', // Overview section
                '## Architecture', // Architecture section
                '## Core', // Core implementation details
                '## Public API', // Public API usage
                '## Integration', // Integration points
                '## Best Practices', // Best practices and caveats
            ];
            const missingSections = requiredSections.filter(section => !guideContent.includes(section));
            if (missingSections.length > 0) {
                return {
                    compliant: false,
                    violations: [
                        {
                            guideline: 'documentation.componentGuides',
                            path: guidePath,
                            message: `Component guide missing required sections: ${missingSections.join(', ')}`,
                            severity: 'warning',
                        },
                    ],
                };
            }
            return {
                compliant: true,
                violations: [],
            };
        }
        catch (error) {
            this.log(`Check component guide error: ${error.message}`);
            return {
                error: error.message,
                violations: [],
            };
        }
    }
    /**
     * Check example file
     * @param {string} componentName - Component name
     * @returns {Promise<Object>} Check result
     * @private
     */
    async _checkExampleFile(componentName) {
        try {
            this.log(`Checking example file for: ${componentName}`);
            // Convert component name to kebab-case for example filename
            const exampleFilename = this._toKebabCase(componentName) + '-example.js';
            // Check if example exists
            const examplePath = path.resolve(this.config.baseDir, 'examples', exampleFilename);
            const exampleExists = await fs.stat(examplePath).catch(() => null);
            if (!exampleExists) {
                return {
                    compliant: false,
                    violations: [
                        {
                            guideline: 'documentation.exampleFiles',
                            path: examplePath,
                            message: `Example file not found: ${exampleFilename}`,
                            severity: 'critical',
                        },
                    ],
                };
            }
            // Check example content
            const exampleContent = await fs.readFile(examplePath, 'utf8');
            // Check if example has required elements
            const requiredElements = [
                '/**', // JSDoc comment
                'require(', // Require statement
                'console.log(', // Output demonstration
            ];
            const missingElements = requiredElements.filter(element => !exampleContent.includes(element));
            if (missingElements.length > 0) {
                return {
                    compliant: false,
                    violations: [
                        {
                            guideline: 'documentation.exampleFiles',
                            path: examplePath,
                            message: `Example file missing required elements: ${missingElements.join(', ')}`,
                            severity: 'warning',
                        },
                    ],
                };
            }
            return {
                compliant: true,
                violations: [],
            };
        }
        catch (error) {
            this.log(`Check example file error: ${error.message}`);
            return {
                error: error.message,
                violations: [],
            };
        }
    }
    /**
     * Check JSDoc comments
     * @param {string} targetPath - Path to target
     * @param {boolean} isDirectory - Whether target is a directory
     * @returns {Promise<Object>} Check result
     * @private
     */
    async _checkJSDocComments(targetPath, isDirectory) {
        try {
            this.log(`Checking JSDoc comments for: ${targetPath}`);
            // If target is a directory, check all JS files in directory
            if (isDirectory) {
                const files = await this._getJSFiles(targetPath);
                // Check each file
                const results = await Promise.all(files.map(file => this._checkJSDocCommentsInFile(file)));
                // Combine violations
                const violations = results.flatMap(result => result.violations);
                return {
                    compliant: violations.length === 0,
                    violations,
                };
            }
            // If target is a file, check that file
            return await this._checkJSDocCommentsInFile(targetPath);
        }
        catch (error) {
            this.log(`Check JSDoc comments error: ${error.message}`);
            return {
                error: error.message,
                violations: [],
            };
        }
    }
    /**
     * Check JSDoc comments in file
     * @param {string} filePath - Path to file
     * @returns {Promise<Object>} Check result
     * @private
     */
    async _checkJSDocCommentsInFile(filePath) {
        try {
            // Only check JS files
            if (!filePath.endsWith('.js')) {
                return {
                    compliant: true,
                    violations: [],
                };
            }
            // Read file content
            const content = await fs.readFile(filePath, 'utf8');
            // Find class, method, and function declarations
            const classRegex = /class\s+(\w+)/g;
            const methodRegex = /(\w+)\s*\([^)]*\)\s*{/g;
            const functionRegex = /function\s+(\w+)\s*\([^)]*\)/g;
            // Find JSDoc comments
            const jsDocRegex = /\/\*\*[\s\S]*?\*\//g;
            // Extract declarations and comments
            const classes = [...content.matchAll(classRegex)].map(match => match[1]);
            const methods = [...content.matchAll(methodRegex)].map(match => match[1]);
            const functions = [...content.matchAll(functionRegex)].map(match => match[1]);
            const jsDocComments = [...content.matchAll(jsDocRegex)];
            // Check if all classes have JSDoc comments
            const violations = [];
            for (const className of classes) {
                const hasJSDoc = jsDocComments.some(comment => comment[0].includes(`* ${className}`) || comment[0].includes(`*\n * ${className}`));
                if (!hasJSDoc) {
                    violations.push({
                        guideline: 'documentation.jsDocComments',
                        path: filePath,
                        message: `Class ${className} missing JSDoc comment`,
                        severity: 'critical',
                    });
                }
            }
            // Check if all public methods and functions have JSDoc comments
            const publicMethods = methods.filter(method => !method.startsWith('_') && method !== 'constructor');
            const publicFunctions = functions.filter(func => !func.startsWith('_'));
            for (const methodName of publicMethods) {
                const hasJSDoc = jsDocComments.some(comment => comment[0].includes(`* ${methodName}`) || comment[0].includes(`*\n * ${methodName}`));
                if (!hasJSDoc) {
                    violations.push({
                        guideline: 'documentation.jsDocComments',
                        path: filePath,
                        message: `Method ${methodName} missing JSDoc comment`,
                        severity: 'critical',
                    });
                }
            }
            for (const funcName of publicFunctions) {
                const hasJSDoc = jsDocComments.some(comment => comment[0].includes(`* ${funcName}`) || comment[0].includes(`*\n * ${funcName}`));
                if (!hasJSDoc) {
                    violations.push({
                        guideline: 'documentation.jsDocComments',
                        path: filePath,
                        message: `Function ${funcName} missing JSDoc comment`,
                        severity: 'critical',
                    });
                }
            }
            return {
                compliant: violations.length === 0,
                violations,
            };
        }
        catch (error) {
            this.log(`Check JSDoc comments in file error: ${error.message}`);
            return {
                error: error.message,
                violations: [],
            };
        }
    }
    /**
     * Get all JS files in directory
     * @param {string} dirPath - Path to directory
     * @returns {Promise<Array>} JS files
     * @private
     */
    async _getJSFiles(dirPath) {
        try {
            const files = [];
            // Read directory
            const entries = await fs.readdir(dirPath, { withFileTypes: true });
            // Process each entry
            for (const entry of entries) {
                const entryPath = path.join(dirPath, entry.name);
                if (entry.isDirectory()) {
                    // Recursively get files from subdirectory
                    const subFiles = await this._getJSFiles(entryPath);
                    files.push(...subFiles);
                }
                else if (entry.isFile() && entry.name.endsWith('.js')) {
                    // Add JS file
                    files.push(entryPath);
                }
            }
            return files;
        }
        catch (error) {
            this.log(`Get JS files error: ${error.message}`);
            return [];
        }
    }
    /**
     * Convert string to kebab-case
     * @param {string} str - String to convert
     * @returns {string} Kebab-case string
     * @private
     */
    _toKebabCase(str) {
        return (str
            // Replace PascalCase with kebab-case
            .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
            // Replace spaces and underscores with hyphens
            .replace(/[\s_]+/g, '-')
            // Convert to lowercase
            .toLowerCase());
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[DocumentationChecker] ${message}`);
        }
    }
}
module.exports = DocumentationChecker;
