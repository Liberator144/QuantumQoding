"use strict";
/**
 * ContextIntegration
 *
 * Integrates guideline verification with context tools.
 *
 * @version 1.0.0
 */
const { EventEmitter } = require('events');
const GuidelineChecker = require('./GuidelineChecker');
/**
 * ContextIntegration
 *
 * Integrates guideline verification with context tools.
 */
class ContextIntegration extends EventEmitter {
    /**
     * Create a new ContextIntegration instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Context detector
            contextDetector: null,
            // Context linter
            contextLinter: null,
            // Merge with provided options
            ...options,
        };
        // Initialize
        this._init();
    }
    /**
     * Initialize the context integration
     * @private
     */
    async _init() {
        this.log('Initializing ContextIntegration');
        try {
            // Load context detector if provided
            if (this.config.contextDetector) {
                this.contextDetector = this.config.contextDetector;
            }
            else {
                // Try to load MLContextDetector
                try {
                    const MLContextDetector = require('../../ml/context/MLContextDetector');
                    this.contextDetector = new MLContextDetector();
                }
                catch (error) {
                    this.log(`MLContextDetector not available: ${error.message}`);
                }
            }
            // Load context linter if provided
            if (this.config.contextLinter) {
                this.contextLinter = this.config.contextLinter;
            }
            else {
                // Try to load ContextLinter
                try {
                    const ContextLinter = require('../../tools/linting/ContextLinter');
                    this.contextLinter = new ContextLinter();
                }
                catch (error) {
                    this.log(`ContextLinter not available: ${error.message}`);
                }
            }
            this.log('ContextIntegration initialized');
        }
        catch (error) {
            this.log(`Initialization error: ${error.message}`);
            this.emit('error', error);
        }
    }
    /**
     * Detect context and verify guidelines
     * @param {string} targetPath - Path to target
     * @param {Object} options - Options
     * @returns {Object} Verification result
     */
    detectContextAndVerifyGuidelines(targetPath, options = {}) {
        try {
            this.log(`Detecting context and verifying guidelines for: ${targetPath}`);
            // Check if context detector is available
            if (!this.contextDetector) {
                // Use a mock context detector
                this.log('Using mock context detector');
                // Mock context detection
                const mockContext = 'component';
                this.log(`Detected mock context: ${mockContext}`);
                // Get context-specific guidelines
                const contextGuidelines = this._getContextSpecificGuidelines(mockContext);
                // Create guideline checker with context-specific guidelines
                const guidelineChecker = new GuidelineChecker({
                    ...options,
                    contextSpecificGuidelines: contextGuidelines,
                });
                // Verify guidelines
                const verificationResult = guidelineChecker.check(targetPath);
                // Add context information to result
                verificationResult.context = mockContext;
                this.log(`Guidelines verification completed for mock context: ${mockContext}`);
                this.emit('context-verification-completed', { targetPath, context: mockContext });
                return verificationResult;
            }
            // Use real context detector
            const contextResult = this.contextDetector.detectContext(targetPath);
            if (!contextResult.success) {
                throw new Error(`Context detection failed: ${contextResult.error}`);
            }
            this.log(`Detected context: ${contextResult.context}`);
            // Get context-specific guidelines
            const contextGuidelines = this._getContextSpecificGuidelines(contextResult.context);
            // Create guideline checker with context-specific guidelines
            const guidelineChecker = new GuidelineChecker({
                ...options,
                contextSpecificGuidelines: contextGuidelines,
            });
            // Verify guidelines
            const verificationResult = guidelineChecker.check(targetPath);
            // Add context information to result
            verificationResult.context = contextResult.context;
            this.log(`Guidelines verification completed for context: ${contextResult.context}`);
            this.emit('context-verification-completed', { targetPath, context: contextResult.context });
            return verificationResult;
        }
        catch (error) {
            this.log(`Detect context and verify guidelines error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Lint and verify guidelines
     * @param {string} targetPath - Path to target
     * @param {Object} options - Options
     * @returns {Object} Verification result
     */
    lintAndVerifyGuidelines(targetPath, options = {}) {
        try {
            this.log(`Linting and verifying guidelines for: ${targetPath}`);
            // Get lint result
            const lintResult = this._getLintResult(targetPath);
            // Verify guidelines
            const verificationResult = this._verifyGuidelines(targetPath, options);
            // Extract violations
            const violations = this._extractViolations(verificationResult);
            // Combine results
            const combinedResult = this._combineResults(targetPath, lintResult, verificationResult, violations);
            this.log(`Linting and guidelines verification completed for: ${targetPath}`);
            this.emit('lint-verification-completed', { targetPath });
            return combinedResult;
        }
        catch (error) {
            this.log(`Lint and verify guidelines error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Get lint result
     * @param {string} targetPath - Path to target
     * @returns {Object} Lint result
     * @private
     */
    _getLintResult(targetPath) {
        // Check if context linter is available
        if (!this.contextLinter) {
            // Use a mock linter
            this.log('Using mock linter');
            // Mock lint result
            const mockLintResult = {
                success: true,
                issues: [
                    {
                        type: 'lint_issue',
                        message: 'Mock lint issue',
                        path: targetPath,
                        severity: 'warning',
                    },
                ],
            };
            this.log(`Mock linting completed with ${mockLintResult.issues.length} issues`);
            return mockLintResult;
        }
        // Use real linter
        const lintResult = this.contextLinter.lint(targetPath);
        if (!lintResult.success) {
            throw new Error(`Linting failed: ${lintResult.error}`);
        }
        this.log(`Linting completed with ${lintResult.issues.length} issues`);
        return lintResult;
    }
    /**
     * Verify guidelines
     * @param {string} targetPath - Path to target
     * @param {Object} options - Options
     * @returns {Object} Verification result
     * @private
     */
    _verifyGuidelines(targetPath, options) {
        // Create guideline checker
        const guidelineChecker = new GuidelineChecker(options);
        // Verify guidelines
        return guidelineChecker.check(targetPath);
    }
    /**
     * Extract violations from verification result
     * @param {Object} verificationResult - Verification result
     * @returns {Array} Violations
     * @private
     */
    _extractViolations(verificationResult) {
        const violations = [];
        if (!verificationResult.results) {
            return violations;
        }
        const categories = ['documentation', 'structure', 'codeStyle', 'testing'];
        for (const category of categories) {
            if (verificationResult.results[category] && verificationResult.results[category].violations) {
                violations.push(...verificationResult.results[category].violations);
            }
        }
        return violations;
    }
    /**
     * Combine lint and verification results
     * @param {string} targetPath - Path to target
     * @param {Object} lintResult - Lint result
     * @param {Object} verificationResult - Verification result
     * @param {Array} violations - Violations
     * @returns {Object} Combined result
     * @private
     */
    _combineResults(targetPath, lintResult, verificationResult, violations) {
        return {
            success: true,
            targetPath,
            lintResult,
            verificationResult,
            issues: [
                ...lintResult.issues,
                ...violations.map(violation => ({
                    type: 'guideline_violation',
                    guideline: violation.guideline,
                    message: violation.message,
                    path: violation.path,
                    severity: violation.severity,
                })),
            ],
        };
    }
    /**
     * Get context-specific guidelines
     * @param {string} context - Context
     * @returns {Object} Context-specific guidelines
     * @private
     */
    _getContextSpecificGuidelines(context) {
        try {
            // In a real implementation, this would load context-specific guidelines
            // based on the detected context
            // For now, we'll return a simplified set of guidelines
            const baseGuidelines = {
                documentation: {
                    componentGuides: {
                        required: true,
                        description: 'Create comprehensive guides in the `docs/guides/` directory for all new significant components or modules.',
                    },
                    exampleFiles: {
                        required: true,
                        description: 'Create illustrative example files in the `examples/` directory to demonstrate practical usage of new components or features.',
                    },
                    jsDocComments: {
                        required: true,
                        description: 'Rigorously document all public APIs (classes, methods, properties, functions) using JSDoc comments.',
                    },
                },
                structure: {
                    directoryStructure: {
                        required: true,
                        description: 'Place components in the appropriate module directory. Directory names should be lowercase and hyphenated if multiple words.',
                    },
                    fileOrganization: {
                        required: true,
                        description: 'Create a main component file using PascalCase. Create separate files for distinct subcomponents or helper classes.',
                    },
                    integration: {
                        required: true,
                        description: "Update the parent module's `index.js` file to re-export the new component or its encapsulating module.",
                    },
                },
                codeStyle: {
                    namingConventions: {
                        required: true,
                        description: 'Use `camelCase` for variables, function names, and object properties. Use `PascalCase` for class names.',
                    },
                    fileStructure: {
                        required: true,
                        description: 'Start each `.js` file with a JSDoc file header comment outlining its purpose and author/version if applicable.',
                    },
                    errorHandling: {
                        required: true,
                        description: 'Utilize `try/catch` blocks for operations that are known to be error-prone. Provide meaningful, informative error messages.',
                    },
                },
                testing: {
                    unitTests: {
                        required: true,
                        description: 'Create comprehensive unit tests for all individual components, classes, and non-trivial functions.',
                    },
                    integrationTests: {
                        required: true,
                        description: 'Create integration tests to verify the interactions and contracts between collaborating components or modules.',
                    },
                    testOrganization: {
                        required: true,
                        description: 'Organize test files in a `tests` directory that mirrors the `src` directory structure.',
                    },
                    testAutomation: {
                        required: true,
                        description: 'Automate all tests to ensure they can be run consistently and efficiently.',
                    },
                },
            };
            return this._customizeGuidelinesForContext(context, baseGuidelines);
        }
        catch (error) {
            this.log(`Get context-specific guidelines error: ${error.message}`);
            throw error;
        }
    }
    /**
     * Customize guidelines for context
     * @param {string} context - Context
     * @param {Object} baseGuidelines - Base guidelines
     * @returns {Object} Customized guidelines
     * @private
     */
    _customizeGuidelinesForContext(context, baseGuidelines) {
        switch (context) {
            case 'component':
                // No changes for components
                return baseGuidelines;
            case 'utility':
                // Utilities don't need component guides
                return {
                    ...baseGuidelines,
                    documentation: {
                        ...baseGuidelines.documentation,
                        componentGuides: {
                            required: false,
                            description: 'Component guides are optional for utility functions.',
                        },
                    },
                };
            case 'test':
                // Tests have different requirements
                return {
                    documentation: {
                        jsDocComments: {
                            required: true,
                            description: 'Document test purpose and test cases using JSDoc comments.',
                        },
                    },
                    structure: {
                        directoryStructure: {
                            required: true,
                            description: 'Place tests in the appropriate test directory that mirrors the src structure.',
                        },
                        fileOrganization: {
                            required: true,
                            description: 'Name test files with `.test.js` suffix.',
                        },
                    },
                    codeStyle: {
                        namingConventions: {
                            required: true,
                            description: 'Use descriptive test names that explain what is being tested.',
                        },
                        fileStructure: {
                            required: true,
                            description: 'Organize tests with describe and it/test blocks.',
                        },
                    },
                };
            default:
                return baseGuidelines;
        }
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[ContextIntegration] ${message}`);
        }
    }
}
module.exports = ContextIntegration;
