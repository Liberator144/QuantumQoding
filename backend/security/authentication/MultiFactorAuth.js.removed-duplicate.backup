"use strict";
/**
 * Multi-Factor Authentication
 *
 * Provides multi-factor authentication functionality.
 *
 * @version 1.0.0
 */
const crypto = require('crypto');
const { EventEmitter } = require('events');
/**
 * Multi-Factor Authentication
 *
 * Provides multi-factor authentication functionality.
 */
class MultiFactorAuth extends EventEmitter {
    /**
     * Create a new MultiFactorAuth instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Secret key for TOTP
            secretKey: options.secretKey || crypto.randomBytes(32).toString('hex'),
            // TOTP time step (in seconds)
            timeStep: 30,
            // TOTP code length
            codeLength: 6,
            // TOTP algorithm
            algorithm: 'sha1',
            // TOTP window (number of time steps to check)
            window: 1,
            // Backup codes count
            backupCodesCount: 10,
            // Backup codes length
            backupCodeLength: 10,
            // User repository
            userRepository: null,
            // MFA repository
            mfaRepository: null,
            // Database
            database: null,
            // Merge with provided options
            ...options,
        };
        // Initialize
        this._init();
    }
    /**
     * Initialize the multi-factor authentication
     * @private
     */
    _init() {
        this.log('Initializing Multi-Factor Authentication');
        // Create MFA collection if it doesn't exist
        if (this.config.database && !this.config.database.getCollection('_mfa')) {
            this.config.database.createCollection('_mfa');
        }
        this.log('Multi-Factor Authentication initialized');
    }
    /**
     * Set database
     * @param {Object} database - Database instance
     * @returns {MultiFactorAuth} This instance for chaining
     */
    setDatabase(database) {
        this.config.database = database;
        // Create MFA collection if it doesn't exist
        if (!database.getCollection('_mfa')) {
            database.createCollection('_mfa');
        }
        this.log('Database set');
        return this;
    }
    /**
     * Enable MFA for user
     * @param {string} userId - User ID
     * @param {string} method - MFA method (totp, sms, email, biometric, hardware)
     * @param {Object} options - Method-specific options
     * @returns {Promise<Object>} Enablement result
     */
    async enableMFA(userId, method, options = {}) {
        try {
            this.log(`Enabling MFA for user: ${userId}, method: ${method}`);
            // Check if MFA is already enabled
            const existingMFA = await this._getMFASettings(userId, method);
            if (existingMFA) {
                return {
                    success: false,
                    error: `MFA method ${method} is already enabled for user ${userId}`,
                };
            }
            // Generate MFA settings based on method
            let mfaSettings;
            switch (method) {
                case 'totp':
                    mfaSettings = this._generateTOTPSettings(options);
                    break;
                case 'sms':
                    mfaSettings = this._generateSMSSettings(options);
                    break;
                case 'email':
                    mfaSettings = this._generateEmailSettings(options);
                    break;
                case 'biometric':
                    mfaSettings = this._generateBiometricSettings(options);
                    break;
                case 'hardware':
                    mfaSettings = this._generateHardwareSettings(options);
                    break;
                default:
                    throw new Error(`Unsupported MFA method: ${method}`);
            }
            // Save MFA settings
            await this._saveMFASettings(userId, method, mfaSettings);
            this.log(`MFA enabled for user: ${userId}, method: ${method}`);
            this.emit('mfa-enabled', { userId, method });
            return {
                success: true,
                method,
                settings: this._getPublicMFASettings(mfaSettings),
            };
        }
        catch (error) {
            this.log(`Enable MFA error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Disable MFA for user
     * @param {string} userId - User ID
     * @param {string} method - MFA method (totp, sms, email, biometric, hardware)
     * @returns {Promise<Object>} Disablement result
     */
    async disableMFA(userId, method) {
        try {
            this.log(`Disabling MFA for user: ${userId}, method: ${method}`);
            // Check if MFA is enabled
            const existingMFA = await this._getMFASettings(userId, method);
            if (!existingMFA) {
                return {
                    success: false,
                    error: `MFA method ${method} is not enabled for user ${userId}`,
                };
            }
            // Delete MFA settings
            await this._deleteMFASettings(userId, method);
            this.log(`MFA disabled for user: ${userId}, method: ${method}`);
            this.emit('mfa-disabled', { userId, method });
            return {
                success: true,
                method,
            };
        }
        catch (error) {
            this.log(`Disable MFA error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Verify MFA code
     * @param {string} userId - User ID
     * @param {string} method - MFA method (totp, sms, email, biometric, hardware)
     * @param {string} code - MFA code
     * @returns {Promise<Object>} Verification result
     */
    async verifyMFA(userId, method, code) {
        try {
            this.log(`Verifying MFA for user: ${userId}, method: ${method}`);
            // Check if MFA is enabled
            const mfaSettings = await this._getMFASettings(userId, method);
            if (!mfaSettings) {
                return {
                    success: false,
                    error: `MFA method ${method} is not enabled for user ${userId}`,
                };
            }
            // Verify code based on method
            let isValid = false;
            switch (method) {
                case 'totp':
                    isValid = this._verifyTOTPCode(code, mfaSettings);
                    break;
                case 'sms':
                    isValid = this._verifySMSCode(code, mfaSettings);
                    break;
                case 'email':
                    isValid = this._verifyEmailCode(code, mfaSettings);
                    break;
                case 'biometric':
                    isValid = this._verifyBiometricCode(code, mfaSettings);
                    break;
                case 'hardware':
                    isValid = this._verifyHardwareCode(code, mfaSettings);
                    break;
                case 'backup':
                    isValid = await this._verifyBackupCode(userId, code);
                    break;
                default:
                    throw new Error(`Unsupported MFA method: ${method}`);
            }
            if (!isValid) {
                this.log(`Invalid MFA code for user: ${userId}, method: ${method}`);
                this.emit('mfa-failed', { userId, method });
                return {
                    success: false,
                    error: 'Invalid MFA code',
                };
            }
            this.log(`MFA verified for user: ${userId}, method: ${method}`);
            this.emit('mfa-verified', { userId, method });
            return {
                success: true,
                method,
            };
        }
        catch (error) {
            this.log(`Verify MFA error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Generate backup codes for user
     * @param {string} userId - User ID
     * @returns {Promise<Object>} Generation result
     */
    async generateBackupCodes(userId) {
        try {
            this.log(`Generating backup codes for user: ${userId}`);
            // Generate backup codes
            const backupCodes = [];
            for (let i = 0; i < this.config.backupCodesCount; i++) {
                const code = crypto
                    .randomBytes(Math.ceil(this.config.backupCodeLength / 2))
                    .toString('hex')
                    .slice(0, this.config.backupCodeLength);
                backupCodes.push(code);
            }
            // Hash backup codes
            const hashedCodes = backupCodes.map(code => {
                const hash = crypto.createHash('sha256');
                hash.update(code);
                return hash.digest('hex');
            });
            // Save backup codes
            await this._saveBackupCodes(userId, hashedCodes);
            this.log(`Backup codes generated for user: ${userId}`);
            this.emit('backup-codes-generated', { userId });
            return {
                success: true,
                backupCodes,
            };
        }
        catch (error) {
            this.log(`Generate backup codes error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Get MFA methods for user
     * @param {string} userId - User ID
     * @returns {Promise<Object>} MFA methods
     */
    async getMFAMethods(userId) {
        try {
            this.log(`Getting MFA methods for user: ${userId}`);
            // Get MFA collection
            const mfaCollection = this.config.database.getCollection('_mfa');
            // Find MFA settings for user
            const mfaSettings = mfaCollection.find({ userId });
            // Extract methods
            const methods = mfaSettings.map(setting => setting.method);
            return {
                success: true,
                methods,
                hasBackupCodes: methods.includes('backup'),
            };
        }
        catch (error) {
            this.log(`Get MFA methods error: ${error.message}`);
            this.emit('error', error);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Generate TOTP settings
     * @param {Object} options - TOTP options
     * @returns {Object} TOTP settings
     * @private
     */
    _generateTOTPSettings(options = {}) {
        // Generate secret key if not provided
        const secret = options.secret || this._generateTOTPSecret();
        return {
            secret,
            algorithm: options.algorithm || this.config.algorithm,
            digits: options.digits || this.config.codeLength,
            period: options.period || this.config.timeStep,
            createdAt: Date.now(),
        };
    }
    /**
     * Generate TOTP secret
     * @returns {string} TOTP secret
     * @private
     */
    _generateTOTPSecret() {
        return crypto.randomBytes(20).toString('base64');
    }
    /**
     * Verify TOTP code
     * @param {string} code - TOTP code
     * @param {Object} settings - TOTP settings
     * @returns {boolean} True if code is valid
     * @private
     */
    _verifyTOTPCode(code, settings) {
        // Get current time step
        const now = Math.floor(Date.now() / 1000);
        const timeStep = settings.period || this.config.timeStep;
        const currentStep = Math.floor(now / timeStep);
        // Check code for current time step and window
        const window = this.config.window;
        for (let i = -window; i <= window; i++) {
            const step = currentStep + i;
            const expectedCode = this._generateTOTPCode(settings.secret, step, settings);
            if (code === expectedCode) {
                return true;
            }
        }
        return false;
    }
    /**
     * Generate TOTP code
     * @param {string} secret - TOTP secret
     * @param {number} step - Time step
     * @param {Object} settings - TOTP settings
     * @returns {string} TOTP code
     * @private
     */
    _generateTOTPCode(secret, step, settings) {
        // Convert step to buffer
        const buffer = Buffer.alloc(8);
        for (let i = 0; i < 8; i++) {
            buffer[7 - i] = step & 0xff;
            step = step >> 8;
        }
        // Generate HMAC
        const hmac = crypto.createHmac(settings.algorithm || this.config.algorithm, Buffer.from(secret, 'base64'));
        hmac.update(buffer);
        const hmacResult = hmac.digest();
        // Get offset
        const offset = hmacResult[hmacResult.length - 1] & 0xf;
        // Generate code
        const binary = ((hmacResult[offset] & 0x7f) << 24) |
            ((hmacResult[offset + 1] & 0xff) << 16) |
            ((hmacResult[offset + 2] & 0xff) << 8) |
            (hmacResult[offset + 3] & 0xff);
        const digits = settings.digits || this.config.codeLength;
        const code = binary % Math.pow(10, digits);
        // Pad code with leading zeros
        return code.toString().padStart(digits, '0');
    }
    /**
     * Generate SMS settings
     * @param {Object} options - SMS options
     * @returns {Object} SMS settings
     * @private
     */
    _generateSMSSettings(options = {}) {
        return {
            phoneNumber: options.phoneNumber,
            provider: options.provider || 'default',
            createdAt: Date.now(),
        };
    }
    /**
     * Verify SMS code
     * @param {string} code - SMS code
     * @param {Object} settings - SMS settings
     * @returns {boolean} True if code is valid
     * @private
     */
    _verifySMSCode(code, settings) {
        // In a real implementation, this would verify the code against a stored code
        // For now, we'll simulate verification
        return code === '123456';
    }
    /**
     * Generate email settings
     * @param {Object} options - Email options
     * @returns {Object} Email settings
     * @private
     */
    _generateEmailSettings(options = {}) {
        return {
            email: options.email,
            createdAt: Date.now(),
        };
    }
    /**
     * Verify email code
     * @param {string} code - Email code
     * @param {Object} settings - Email settings
     * @returns {boolean} True if code is valid
     * @private
     */
    _verifyEmailCode(code, settings) {
        // In a real implementation, this would verify the code against a stored code
        // For now, we'll simulate verification
        return code === '123456';
    }
    /**
     * Generate biometric settings
     * @param {Object} options - Biometric options
     * @returns {Object} Biometric settings
     * @private
     */
    _generateBiometricSettings(options = {}) {
        return {
            biometricId: options.biometricId,
            biometricType: options.biometricType || 'fingerprint',
            createdAt: Date.now(),
        };
    }
    /**
     * Verify biometric code
     * @param {string} code - Biometric code
     * @param {Object} settings - Biometric settings
     * @returns {boolean} True if code is valid
     * @private
     */
    _verifyBiometricCode(code, settings) {
        // In a real implementation, this would verify the biometric data
        // For now, we'll simulate verification
        return code === settings.biometricId;
    }
    /**
     * Generate hardware settings
     * @param {Object} options - Hardware options
     * @returns {Object} Hardware settings
     * @private
     */
    _generateHardwareSettings(options = {}) {
        return {
            deviceId: options.deviceId,
            deviceType: options.deviceType || 'yubikey',
            publicKey: options.publicKey,
            createdAt: Date.now(),
        };
    }
    /**
     * Verify hardware code
     * @param {string} code - Hardware code
     * @param {Object} settings - Hardware settings
     * @returns {boolean} True if code is valid
     * @private
     */
    _verifyHardwareCode(code, settings) {
        // In a real implementation, this would verify the hardware token
        // For now, we'll simulate verification
        return code.startsWith(settings.deviceId);
    }
    /**
     * Verify backup code
     * @param {string} userId - User ID
     * @param {string} code - Backup code
     * @returns {Promise<boolean>} True if code is valid
     * @private
     */
    async _verifyBackupCode(userId, code) {
        // Get MFA collection
        const mfaCollection = this.config.database.getCollection('_mfa');
        // Find backup codes for user
        const backupSettings = await mfaCollection.findOne({
            userId,
            method: 'backup',
        });
        if (!backupSettings?.settings?.codes) {
            return false;
        }
        // Hash the provided code
        const hash = crypto.createHash('sha256');
        hash.update(code);
        const hashedCode = hash.digest('hex');
        // Check if code exists
        const index = backupSettings.settings.codes.indexOf(hashedCode);
        if (index === -1) {
            return false;
        }
        // Remove used code
        backupSettings.settings.codes.splice(index, 1);
        // Update backup codes
        await mfaCollection.update(backupSettings);
        return true;
    }
    /**
     * Get MFA settings
     * @param {string} userId - User ID
     * @param {string} method - MFA method
     * @returns {Promise<Object>} MFA settings
     * @private
     */
    async _getMFASettings(userId, method) {
        // Get MFA collection
        const mfaCollection = this.config.database.getCollection('_mfa');
        // Find MFA settings
        const mfaSettings = await mfaCollection.findOne({
            userId,
            method,
        });
        return mfaSettings ? mfaSettings.settings : null;
    }
    /**
     * Save MFA settings
     * @param {string} userId - User ID
     * @param {string} method - MFA method
     * @param {Object} settings - MFA settings
     * @returns {Promise<void>}
     * @private
     */
    async _saveMFASettings(userId, method, settings) {
        // Get MFA collection
        const mfaCollection = this.config.database.getCollection('_mfa');
        // Find existing settings
        const existingSettings = await mfaCollection.findOne({
            userId,
            method,
        });
        if (existingSettings) {
            // Update settings
            existingSettings.settings = settings;
            await mfaCollection.update(existingSettings);
        }
        else {
            // Insert new settings
            await mfaCollection.insert({
                userId,
                method,
                settings,
                createdAt: Date.now(),
            });
        }
    }
    /**
     * Delete MFA settings
     * @param {string} userId - User ID
     * @param {string} method - MFA method
     * @returns {Promise<void>}
     * @private
     */
    async _deleteMFASettings(userId, method) {
        // Get MFA collection
        const mfaCollection = this.config.database.getCollection('_mfa');
        // Delete settings
        await mfaCollection.delete({
            userId,
            method,
        });
    }
    /**
     * Save backup codes
     * @param {string} userId - User ID
     * @param {Array} hashedCodes - Hashed backup codes
     * @returns {Promise<void>}
     * @private
     */
    async _saveBackupCodes(userId, hashedCodes) {
        // Get MFA collection
        const mfaCollection = this.config.database.getCollection('_mfa');
        // Find existing backup codes
        const existingBackupCodes = await mfaCollection.findOne({
            userId,
            method: 'backup',
        });
        // Settings object
        const settings = {
            codes: hashedCodes,
            createdAt: Date.now(),
        };
        if (existingBackupCodes) {
            // Update existing backup codes
            existingBackupCodes.settings = settings;
            await mfaCollection.update(existingBackupCodes);
        }
        else {
            // Insert new backup codes
            await mfaCollection.insert({
                userId,
                method: 'backup',
                settings,
                createdAt: Date.now(),
            });
        }
    }
    /**
     * Get public MFA settings
     * @param {Object} settings - MFA settings
     * @returns {Object} Public MFA settings
     * @private
     */
    _getPublicMFASettings(settings) {
        // Create a copy of settings
        const publicSettings = { ...settings };
        // Remove sensitive data
        delete publicSettings.secret;
        delete publicSettings.codes;
        return publicSettings;
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[MultiFactorAuth] ${message}`);
        }
    }
}
module.exports = { MultiFactorAuth };
