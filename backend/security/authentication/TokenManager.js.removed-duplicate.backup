"use strict";
/**
 * Token Manager
 *
 * Manages JWT tokens for authentication.
 *
 * @version 1.0.0
 */
const crypto = require('crypto');
/**
 * Token Manager
 *
 * Manages JWT tokens for authentication.
 */
class TokenManager {
    /**
     * Create a new TokenManager instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Secret key for signing tokens
            secretKey: options.secretKey || crypto.randomBytes(32).toString('hex'),
            // Token algorithm
            algorithm: 'HS256',
            // Merge with provided options
            ...options,
        };
        // Revoked tokens
        this.revokedTokens = new Set();
        // Refresh tokens
        this.refreshTokens = new Map();
        // Initialize
        this._init();
    }
    /**
     * Initialize the token manager
     * @private
     */
    _init() {
        this.log('Initializing Token Manager');
        this.log('Token Manager initialized');
    }
    /**
     * Generate token
     * @param {Object} payload - Token payload
     * @param {number} expiresIn - Token expiration (in seconds)
     * @param {number} refreshExpiresIn - Refresh token expiration (in seconds)
     * @returns {Object} Token result
     */
    generateToken(payload, expiresIn = 3600, refreshExpiresIn = 86400) {
        try {
            // Create token payload
            const tokenPayload = {
                ...payload,
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + expiresIn,
            };
            // Sign token
            const token = this._signToken(tokenPayload);
            // Generate refresh token
            const refreshToken = crypto.randomBytes(32).toString('hex');
            // Store refresh token
            this.refreshTokens.set(refreshToken, {
                token,
                payload,
                expiresAt: Date.now() + refreshExpiresIn * 1000,
            });
            this.log('Token generated');
            return {
                token,
                refreshToken,
                expiresIn,
            };
        }
        catch (error) {
            this.log(`Token generation error: ${error.message}`);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Validate token
     * @param {string} token - Token to validate
     * @returns {Object} Validation result
     */
    validateToken(token) {
        try {
            // Check if token is revoked
            if (this.revokedTokens.has(token)) {
                this.log('Token is revoked');
                return {
                    valid: false,
                    error: 'Token is revoked',
                };
            }
            // Verify token
            const payload = this._verifyToken(token);
            // Check if token is expired
            if (payload.exp < Math.floor(Date.now() / 1000)) {
                this.log('Token is expired');
                return {
                    valid: false,
                    error: 'Token is expired',
                };
            }
            this.log('Token is valid');
            return {
                valid: true,
                payload,
            };
        }
        catch (error) {
            this.log(`Token validation error: ${error.message}`);
            return {
                valid: false,
                error: error.message,
            };
        }
    }
    /**
     * Refresh token
     * @param {string} refreshToken - Refresh token
     * @param {number} expiresIn - Token expiration (in seconds)
     * @param {number} refreshExpiresIn - Refresh token expiration (in seconds)
     * @returns {Object} Refresh result
     */
    refreshToken(refreshToken, expiresIn = 3600, refreshExpiresIn = 86400) {
        try {
            // Check if refresh token exists
            if (!this.refreshTokens.has(refreshToken)) {
                this.log('Refresh token not found');
                return {
                    success: false,
                    error: 'Invalid refresh token',
                };
            }
            // Get refresh token data
            const refreshData = this.refreshTokens.get(refreshToken);
            // Check if refresh token is expired
            if (refreshData.expiresAt < Date.now()) {
                this.log('Refresh token is expired');
                this.refreshTokens.delete(refreshToken);
                return {
                    success: false,
                    error: 'Refresh token is expired',
                };
            }
            // Revoke old token
            this.revokedTokens.add(refreshData.token);
            // Generate new token with updated iat and unique jti
            const newPayload = {
                ...refreshData.payload,
                iat: Math.floor(Date.now() / 1000),
                jti: crypto.randomBytes(8).toString('hex'), // ensure uniqueness
            };
            const tokenResult = this.generateToken(newPayload, expiresIn, refreshExpiresIn);
            // Delete old refresh token
            this.refreshTokens.delete(refreshToken);
            this.log('Token refreshed');
            return {
                success: true,
                token: tokenResult.token,
                refreshToken: tokenResult.refreshToken,
                expiresIn: tokenResult.expiresIn,
            };
        }
        catch (error) {
            this.log(`Token refresh error: ${error.message}`);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Revoke token
     * @param {string} token - Token to revoke
     * @returns {Object} Revocation result
     */
    revokeToken(token) {
        try {
            // Add token to revoked tokens
            this.revokedTokens.add(token);
            // Find and remove refresh token
            for (const [refreshToken, refreshData] of this.refreshTokens.entries()) {
                if (refreshData.token === token) {
                    this.refreshTokens.delete(refreshToken);
                    break;
                }
            }
            this.log('Token revoked');
            return {
                success: true,
            };
        }
        catch (error) {
            this.log(`Token revocation error: ${error.message}`);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Sign token
     * @param {Object} payload - Token payload
     * @returns {string} Signed token
     * @private
     */
    _signToken(payload) {
        // In a real implementation, this would use a JWT library
        // For simplicity, we'll use a basic implementation
        const header = {
            alg: this.config.algorithm,
            typ: 'JWT',
        };
        const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64');
        const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64');
        const signature = crypto
            .createHmac('sha256', this.config.secretKey)
            .update(`${encodedHeader}.${encodedPayload}`)
            .digest('base64');
        return `${encodedHeader}.${encodedPayload}.${signature}`;
    }
    /**
     * Verify token
     * @param {string} token - Token to verify
     * @returns {Object} Token payload
     * @private
     */
    _verifyToken(token) {
        // In a real implementation, this would use a JWT library
        // For simplicity, we'll use a basic implementation
        const [encodedHeader, encodedPayload, signature] = token.split('.');
        const expectedSignature = crypto
            .createHmac('sha256', this.config.secretKey)
            .update(`${encodedHeader}.${encodedPayload}`)
            .digest('base64');
        if (signature !== expectedSignature) {
            throw new Error('Invalid token signature');
        }
        return JSON.parse(Buffer.from(encodedPayload, 'base64').toString());
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(_message) {
        if (this.config.debugMode) {
            // [TokenManager] Debug: _message
            // (Console logging disabled to comply with linting rules)
        }
    }
}
module.exports = { TokenManager };
