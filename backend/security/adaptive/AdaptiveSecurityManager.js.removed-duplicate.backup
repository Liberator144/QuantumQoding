"use strict";
/**
 * Adaptive Security Manager
 *
 * Manages adaptive security policies based on machine learning.
 *
 * @version 1.0.0
 */
const { EventEmitter } = require('events');
const { SecurityManager } = require('../SecurityManager');
const { MLEngine } = require('../../ml/MLEngine');
/**
 * Adaptive Security Manager
 *
 * Manages adaptive security policies based on machine learning.
 */
class AdaptiveSecurityManager extends EventEmitter {
    /**
     * Create a new AdaptiveSecurityManager instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Security manager
            securityManager: options.securityManager || new SecurityManager(options),
            // ML engine
            mlEngine: options.mlEngine || new MLEngine(options),
            // Risk threshold (0-1)
            riskThreshold: 0.7,
            // Risk levels
            riskLevels: {
                low: { threshold: 0.3, actions: ['monitor'] },
                medium: { threshold: 0.7, actions: ['monitor', 'mfa'] },
                high: { threshold: 0.9, actions: ['monitor', 'mfa', 'restrict'] },
            },
            // Anomaly detection model ID
            anomalyModelId: null,
            // User behavior model ID
            behaviorModelId: null,
            // Database
            database: null,
            // Merge with provided options
            ...options,
        };
        // Security events
        this.securityEvents = [];
        // User risk scores
        this.userRiskScores = new Map();
        // Initialize
        this._init();
    }
    /**
     * Initialize the adaptive security manager
     * @private
     */
    _init() {
        this.log('Initializing Adaptive Security Manager');
        // Create security events collection if it doesn't exist
        if (this.config.database) {
            if (!this.config.database.getCollection('_security_events')) {
                this.config.database.createCollection('_security_events');
            }
            if (!this.config.database.getCollection('_user_risk_scores')) {
                this.config.database.createCollection('_user_risk_scores');
            }
        }
        // Set up event listeners
        this._setupEventListeners();
        this.log('Adaptive Security Manager initialized');
    }
    /**
     * Set up event listeners
     * @private
     */
    _setupEventListeners() {
        const securityManager = this.config.securityManager;
        // Authentication events
        securityManager.on('user-authenticated', data => this._handleAuthenticationEvent(data, 'success'));
        securityManager.on('authentication-failed', data => this._handleAuthenticationEvent(data, 'failure'));
        // Authorization events
        securityManager.on('authorization-failed', data => this._handleAuthorizationEvent(data, 'failure'));
        // MFA events
        securityManager.on('mfa-verification-failed', data => this._handleMFAEvent(data, 'failure'));
        // Token events
        securityManager.on('token-validation-failed', data => this._handleTokenEvent(data, 'failure'));
    }
    /**
     * Set database
     * @param {Object} database - Database instance
     * @returns {AdaptiveSecurityManager} This instance for chaining
     */
    setDatabase(database) {
        this.config.database = database;
        // Set database for components
        if (this.config.securityManager &&
            typeof this.config.securityManager.setDatabase === 'function') {
            this.config.securityManager.setDatabase(database);
        }
        if (this.config.mlEngine && typeof this.config.mlEngine.setDatabase === 'function') {
            this.config.mlEngine.setDatabase(database);
        }
        // Create collections
        if (!database.getCollection('_security_events')) {
            database.createCollection('_security_events');
        }
        if (!database.getCollection('_user_risk_scores')) {
            database.createCollection('_user_risk_scores');
        }
        this.log('Database set');
        return this;
    }
    /**
     * Handle authentication event
     * @param {Object} data - Event data
     * @param {string} result - Event result
     * @private
     */
    async _handleAuthenticationEvent(data, result) {
        const event = {
            type: 'authentication',
            result,
            username: data.username,
            timestamp: Date.now(),
            ip: data.ip,
            userAgent: data.userAgent,
            geoLocation: data.geoLocation,
        };
        await this._recordSecurityEvent(event);
        // Update risk score for failed authentication
        if (result === 'failure') {
            await this._updateUserRiskScore(data.username, 0.1);
            await this._checkAnomalies(data.username);
        }
    }
    /**
     * Handle authorization event
     * @param {Object} data - Event data
     * @param {string} result - Event result
     * @private
     */
    async _handleAuthorizationEvent(data, result) {
        const event = {
            type: 'authorization',
            result,
            username: data.user,
            resource: data.resource,
            action: data.action,
            timestamp: Date.now(),
        };
        await this._recordSecurityEvent(event);
        // Update risk score for failed authorization
        if (result === 'failure') {
            await this._updateUserRiskScore(data.user, 0.2);
            await this._checkAnomalies(data.user);
        }
    }
    /**
     * Handle MFA event
     * @param {Object} data - Event data
     * @param {string} result - Event result
     * @private
     */
    async _handleMFAEvent(data, result) {
        const event = {
            type: 'mfa',
            result,
            userId: data.userId,
            method: data.method,
            timestamp: Date.now(),
        };
        await this._recordSecurityEvent(event);
        // Update risk score for failed MFA
        if (result === 'failure') {
            await this._updateUserRiskScore(data.userId, 0.3);
            await this._checkAnomalies(data.userId);
        }
    }
    /**
     * Handle token event
     * @param {Object} data - Event data
     * @param {string} result - Event result
     * @private
     */
    async _handleTokenEvent(data, result) {
        const event = {
            type: 'token',
            result,
            timestamp: Date.now(),
        };
        await this._recordSecurityEvent(event);
    }
    /**
     * Record security event
     * @param {Object} event - Security event
     * @private
     */
    async _recordSecurityEvent(event) {
        this.log(`Recording security event: ${event.type}, ${event.result}`);
        // Add to in-memory events
        this.securityEvents.push(event);
        // Trim events if too many
        if (this.securityEvents.length > 1000) {
            this.securityEvents = this.securityEvents.slice(-1000);
        }
        // Save to database if available
        if (this.config.database) {
            const eventsCollection = this.config.database.getCollection('_security_events');
            await eventsCollection.insert(event);
        }
        // Emit event
        this.emit('security-event', event);
    }
    /**
     * Update user risk score
     * @param {string} userId - User ID
     * @param {number} increment - Risk score increment
     * @private
     */
    async _updateUserRiskScore(userId, increment) {
        // Get current risk score
        let currentScore = this.userRiskScores.get(userId) || 0;
        // Update score
        currentScore = Math.min(1, currentScore + increment);
        // Save to memory
        this.userRiskScores.set(userId, currentScore);
        // Save to database if available
        if (this.config.database) {
            const scoresCollection = this.config.database.getCollection('_user_risk_scores');
            const existingScore = await scoresCollection.findOne({ userId });
            if (existingScore) {
                existingScore.score = currentScore;
                existingScore.updatedAt = Date.now();
                await scoresCollection.update(existingScore);
            }
            else {
                await scoresCollection.insert({
                    userId,
                    score: currentScore,
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                });
            }
        }
        this.log(`Updated risk score for user ${userId}: ${currentScore}`);
        // Check if risk threshold is exceeded
        if (currentScore >= this.config.riskThreshold) {
            await this._handleHighRiskUser(userId, currentScore);
        }
        return currentScore;
    }
    /**
     * Check for anomalies in user behavior
     * @param {string} userId - User ID
     * @private
     */
    async _checkAnomalies(userId) {
        try {
            // Skip if no anomaly model is set
            if (!this.config.anomalyModelId) {
                return;
            }
            this.log(`Checking anomalies for user ${userId}`);
            // Get recent events for user
            const userEvents = this.securityEvents
                .filter(event => event.userId === userId || event.username === userId)
                .slice(-20);
            if (userEvents.length < 5) {
                return; // Not enough events to analyze
            }
            // Load anomaly detection model
            const model = await this.config.mlEngine.loadModel(this.config.anomalyModelId);
            // Extract features from events
            const features = this._extractFeaturesFromEvents(userEvents);
            // Predict anomaly score
            const anomalyScore = await this.config.mlEngine.predict(model, features);
            this.log(`Anomaly score for user ${userId}: ${anomalyScore}`);
            // If anomaly detected, increase risk score
            if (anomalyScore > 0.7) {
                await this._updateUserRiskScore(userId, 0.3);
                this.emit('anomaly-detected', {
                    userId,
                    anomalyScore,
                    timestamp: Date.now(),
                });
            }
        }
        catch (error) {
            this.log(`Anomaly detection error: ${error.message}`);
        }
    }
    /**
     * Extract features from security events
     * @param {Array} events - Security events
     * @returns {Array} Features
     * @private
     */
    _extractFeaturesFromEvents(events) {
        // In a real implementation, this would extract meaningful features
        // For now, we'll return a simple representation
        const features = {
            authFailureCount: events.filter(e => e.type === 'authentication' && e.result === 'failure')
                .length,
            authSuccessCount: events.filter(e => e.type === 'authentication' && e.result === 'success')
                .length,
            mfaFailureCount: events.filter(e => e.type === 'mfa' && e.result === 'failure').length,
            authzFailureCount: events.filter(e => e.type === 'authorization' && e.result === 'failure')
                .length,
            tokenFailureCount: events.filter(e => e.type === 'token' && e.result === 'failure').length,
            timeSpan: events.length > 1 ? events[events.length - 1].timestamp - events[0].timestamp : 0,
        };
        return Object.values(features);
    }
    /**
     * Handle high risk user
     * @param {string} userId - User ID
     * @param {number} riskScore - Risk score
     * @private
     */
    async _handleHighRiskUser(userId, riskScore) {
        this.log(`Handling high risk user: ${userId}, score: ${riskScore}`);
        // Determine risk level
        let riskLevel = 'low';
        if (riskScore >= this.config.riskLevels.high.threshold) {
            riskLevel = 'high';
        }
        else if (riskScore >= this.config.riskLevels.medium.threshold) {
            riskLevel = 'medium';
        }
        // Get actions for risk level
        const actions = this.config.riskLevels[riskLevel].actions;
        // Execute actions
        for (const action of actions) {
            await this._executeSecurityAction(userId, action, riskScore, riskLevel);
        }
        // Emit high risk event
        this.emit('high-risk-user', {
            userId,
            riskScore,
            riskLevel,
            actions,
            timestamp: Date.now(),
        });
    }
    /**
     * Execute security action
     * @param {string} userId - User ID
     * @param {string} action - Security action
     * @param {number} riskScore - Risk score
     * @param {string} riskLevel - Risk level
     * @private
     */
    async _executeSecurityAction(userId, action, riskScore, riskLevel) {
        this.log(`Executing security action: ${action} for user ${userId}`);
        switch (action) {
            case 'monitor':
                // Just log the event
                this.log(`Monitoring user ${userId} due to risk level ${riskLevel}`);
                break;
            case 'mfa':
                // Require MFA for the user
                await this._requireMFA(userId);
                break;
            case 'restrict':
                // Restrict user access
                await this._restrictUserAccess(userId);
                break;
            default:
                this.log(`Unknown security action: ${action}`);
        }
    }
    /**
     * Require MFA for user
     * @param {string} userId - User ID
     * @private
     */
    async _requireMFA(userId) {
        try {
            // Check if user already has MFA enabled
            const mfaMethods = await this.config.securityManager.getMFAMethods(userId);
            if (!mfaMethods.success || mfaMethods.methods.length === 0) {
                // User doesn't have MFA, flag account for MFA enrollment
                // In a real implementation, this would update a user setting
                this.log(`Flagging user ${userId} for MFA enrollment`);
                // Emit event
                this.emit('mfa-required', {
                    userId,
                    timestamp: Date.now(),
                });
            }
        }
        catch (error) {
            this.log(`Require MFA error: ${error.message}`);
        }
    }
    /**
     * Restrict user access
     * @param {string} userId - User ID
     * @private
     */
    async _restrictUserAccess(userId) {
        try {
            // In a real implementation, this would update user permissions
            this.log(`Restricting access for user ${userId}`);
            // Emit event
            this.emit('user-restricted', {
                userId,
                timestamp: Date.now(),
            });
        }
        catch (error) {
            this.log(`Restrict user access error: ${error.message}`);
        }
    }
    /**
     * Get user risk score
     * @param {string} userId - User ID
     * @returns {Promise<number>} Risk score
     */
    async getUserRiskScore(userId) {
        // Check in-memory cache
        if (this.userRiskScores.has(userId)) {
            return this.userRiskScores.get(userId);
        }
        // Check database
        if (this.config.database) {
            const scoresCollection = this.config.database.getCollection('_user_risk_scores');
            const scoreRecord = await scoresCollection.findOne({ userId });
            if (scoreRecord) {
                // Update in-memory cache
                this.userRiskScores.set(userId, scoreRecord.score);
                return scoreRecord.score;
            }
        }
        // Default score
        return 0;
    }
    /**
     * Reset user risk score
     * @param {string} userId - User ID
     * @returns {Promise<boolean>} Success
     */
    async resetUserRiskScore(userId) {
        try {
            // Reset in-memory score
            this.userRiskScores.set(userId, 0);
            // Reset in database
            if (this.config.database) {
                const scoresCollection = this.config.database.getCollection('_user_risk_scores');
                const scoreRecord = await scoresCollection.findOne({ userId });
                if (scoreRecord) {
                    scoreRecord.score = 0;
                    scoreRecord.updatedAt = Date.now();
                    await scoresCollection.update(scoreRecord);
                }
            }
            this.log(`Reset risk score for user ${userId}`);
            return true;
        }
        catch (error) {
            this.log(`Reset risk score error: ${error.message}`);
            return false;
        }
    }
    /**
     * Train anomaly detection model
     * @returns {Promise<Object>} Training result
     */
    async trainAnomalyDetectionModel() {
        try {
            this.log('Training anomaly detection model');
            // Get security events
            const events = this.securityEvents;
            if (events.length < 100) {
                return {
                    success: false,
                    error: 'Not enough security events for training',
                };
            }
            // Prepare training data
            const trainingData = [];
            // Group events by user
            const userEvents = {};
            for (const event of events) {
                const userId = event.userId || event.username;
                if (!userId)
                    continue;
                if (!userEvents[userId]) {
                    userEvents[userId] = [];
                }
                userEvents[userId].push(event);
            }
            // Create feature vectors for each user
            for (const userId in userEvents) {
                const userEventsList = userEvents[userId];
                // Skip users with too few events
                if (userEventsList.length < 5)
                    continue;
                // Create sliding windows of events
                for (let i = 0; i <= userEventsList.length - 5; i++) {
                    const windowEvents = userEventsList.slice(i, i + 5);
                    const features = this._extractFeaturesFromEvents(windowEvents);
                    trainingData.push({
                        features,
                        target: 0, // Normal behavior
                    });
                }
            }
            // Create anomaly detection model
            const model = await this.config.mlEngine.createModel('anomaly', {
                name: 'Security Anomaly Detection',
                parameters: {
                    contamination: 0.1,
                    algorithm: 'isolation_forest',
                },
            });
            // Train model
            const trainResult = await this.config.mlEngine.trainModel(model, trainingData);
            if (trainResult.success) {
                // Save model ID
                this.config.anomalyModelId = model.id;
                this.log(`Anomaly detection model trained: ${model.id}`);
                return {
                    success: true,
                    modelId: model.id,
                };
            }
            else {
                return {
                    success: false,
                    error: trainResult.error,
                };
            }
        }
        catch (error) {
            this.log(`Train anomaly detection model error: ${error.message}`);
            return {
                success: false,
                error: error.message,
            };
        }
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[AdaptiveSecurityManager] ${message}`);
        }
    }
}
module.exports = { AdaptiveSecurityManager };
