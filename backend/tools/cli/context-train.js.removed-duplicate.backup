#!/usr/bin/env node
"use strict";
/**
 * Context Model Training CLI
 *
 * Command-line interface for training context detection models.
 *
 * @version 1.0.0
 */
const fs = require('fs');
const path = require('path');
const { program } = require('commander');
const chalk = require('chalk');
const { MLModelTrainer } = require('../context-detection/ml/MLModelTrainer');
// Set up CLI
program
    .name('context-train')
    .description('Train context detection models for the Quantum-Unified Database')
    .version('1.0.0');
// Add commands
program
    .command('train')
    .description('Train a new context detection model')
    .option('-d, --debug', 'Enable debug mode')
    .option('-t, --training-data <dir>', 'Training data directory')
    .option('-o, --output-dir <dir>', 'Model output directory')
    .option('-m, --model-type <type>', 'Model type (naive-bayes, decision-tree, random-forest, neural-network)', 'naive-bayes')
    .option('-n, --model-name <name>', 'Model name')
    .option('-e, --epochs <number>', 'Number of training epochs', '10')
    .option('-b, --batch-size <number>', 'Batch size', '32')
    .option('-l, --learning-rate <number>', 'Learning rate', '0.001')
    .option('-s, --validation-split <number>', 'Validation split', '0.2')
    .option('-x, --test-split <number>', 'Test split', '0.1')
    .action(async (options) => {
    try {
        // Create model trainer
        const trainer = new MLModelTrainer({
            debugMode: options.debug,
            trainingDataDir: options.trainingData,
            modelOutputDir: options.outputDir,
            model: {
                type: options.modelType,
                parameters: {},
            },
            training: {
                epochs: parseInt(options.epochs, 10),
                batchSize: parseInt(options.batchSize, 10),
                learningRate: parseFloat(options.learningRate),
                validationSplit: parseFloat(options.validationSplit),
                testSplit: parseFloat(options.testSplit),
            },
        });
        // Train model
        console.log(chalk.bold('Training context detection model...'));
        const result = await trainer.trainModel({
            modelName: options.modelName,
        });
        console.log(chalk.green(`Model trained successfully and saved to ${result.modelPath}`));
        console.log(chalk.cyan('\nEvaluation Results:'));
        console.log(`  Accuracy: ${(result.evaluation.accuracy * 100).toFixed(2)}%`);
        console.log(`  Precision: ${(result.evaluation.precision * 100).toFixed(2)}%`);
        console.log(`  Recall: ${(result.evaluation.recall * 100).toFixed(2)}%`);
        console.log(`  F1 Score: ${(result.evaluation.f1 * 100).toFixed(2)}%`);
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('evaluate')
    .description('Evaluate a trained context detection model')
    .option('-d, --debug', 'Enable debug mode')
    .option('-m, --model-path <path>', 'Path to the model file')
    .option('-t, --test-data <dir>', 'Test data directory')
    .action(async (options) => {
    try {
        // Create model trainer
        const trainer = new MLModelTrainer({
            debugMode: options.debug,
            trainingDataDir: options.testData,
        });
        // Load model
        console.log(chalk.bold(`Loading model from ${options.modelPath}...`));
        const model = await trainer.loadModel(options.modelPath);
        // Load test data
        console.log(chalk.bold('Loading test data...'));
        const testData = await trainer._loadTrainingData();
        // Evaluate model
        console.log(chalk.bold('Evaluating model...'));
        const evaluation = await trainer._evaluateModel(model, testData);
        console.log(chalk.cyan('\nEvaluation Results:'));
        console.log(`  Accuracy: ${(evaluation.accuracy * 100).toFixed(2)}%`);
        console.log(`  Precision: ${(evaluation.precision * 100).toFixed(2)}%`);
        console.log(`  Recall: ${(evaluation.recall * 100).toFixed(2)}%`);
        console.log(`  F1 Score: ${(evaluation.f1 * 100).toFixed(2)}%`);
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('create-dataset')
    .description('Create a training dataset from a directory')
    .option('-d, --debug', 'Enable debug mode')
    .option('-s, --source-dir <dir>', 'Source directory')
    .option('-o, --output-dir <dir>', 'Output directory')
    .option('-c, --contexts <contexts>', 'Comma-separated list of contexts to include')
    .option('-f, --force', 'Force overwrite of existing files')
    .action(async (options) => {
    try {
        // Validate options
        if (!options.sourceDir) {
            throw new Error('Source directory is required');
        }
        if (!options.outputDir) {
            throw new Error('Output directory is required');
        }
        // Create output directory
        if (!fs.existsSync(options.outputDir)) {
            fs.mkdirSync(options.outputDir, { recursive: true });
        }
        // Parse contexts
        const contexts = options.contexts
            ? options.contexts.split(',')
            : [
                'core',
                'flow',
                'verification',
                'visualization',
                'security',
                'caching',
                'schemas',
                'optimization',
                'ai',
                'testing',
                'documentation',
            ];
        // Create context directories
        for (const context of contexts) {
            const contextDir = path.join(options.outputDir, context);
            if (!fs.existsSync(contextDir)) {
                fs.mkdirSync(contextDir, { recursive: true });
            }
        }
        console.log(chalk.bold(`Creating training dataset from ${options.sourceDir}...`));
        console.log(chalk.cyan(`Contexts: ${contexts.join(', ')}`));
        // Create context detector
        const { MLContextDetector } = require('../context-detection/ml/MLContextDetector');
        const detector = new MLContextDetector({
            debugMode: options.debug,
            baseDir: options.sourceDir,
        });
        // Get all files
        const files = await getAllFiles(options.sourceDir);
        console.log(chalk.cyan(`Found ${files.length} files`));
        // Process files
        let processedCount = 0;
        for (const file of files) {
            try {
                // Detect context
                const result = await detector.detectContext(file);
                // Check if context is in the list
                if (contexts.includes(result.context)) {
                    // Copy file to context directory
                    const relativePath = path.relative(options.sourceDir, file);
                    const outputPath = path.join(options.outputDir, result.context, path.basename(file));
                    // Check if file already exists
                    if (fs.existsSync(outputPath) && !options.force) {
                        console.log(chalk.yellow(`Skipping ${relativePath} (already exists)`));
                        continue;
                    }
                    // Copy file
                    fs.copyFileSync(file, outputPath);
                    console.log(chalk.green(`Copied ${relativePath} to ${result.context} (confidence: ${(result.confidence * 100).toFixed(2)}%)`));
                    processedCount++;
                }
            }
            catch (error) {
                console.error(chalk.red(`Error processing ${file}: ${error.message}`));
            }
        }
        console.log(chalk.green(`\nDataset created successfully with ${processedCount} files`));
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
// Parse command line arguments
program.parse(process.argv);
// If no arguments, show help
if (process.argv.length === 2) {
    program.help();
}
/**
 * Get all files in a directory recursively
 * @param {string} dir - Directory path
 * @returns {Promise<Array>} Array of file paths
 */
async function getAllFiles(dir) {
    const files = [];
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            // Skip node_modules, .git, etc.
            if (['node_modules', '.git', 'dist', 'build', 'coverage'].includes(entry.name)) {
                continue;
            }
            files.push(...(await getAllFiles(fullPath)));
        }
        else if (entry.isFile()) {
            // Only include certain file types
            const ext = path.extname(entry.name);
            if (['.js', '.jsx', '.ts', '.tsx', '.md'].includes(ext)) {
                files.push(fullPath);
            }
        }
    }
    return files;
}
