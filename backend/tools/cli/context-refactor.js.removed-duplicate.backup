#!/usr/bin/env node
"use strict";
/**
 * Intelligent Refactoring CLI
 *
 * Command-line interface for context-aware code refactoring suggestions.
 *
 * @version 1.0.0
 */
const fs = require('fs');
const path = require('path');
const { program } = require('commander');
const chalk = require('chalk');
const { RefactoringEngine } = require('../context-refactoring/RefactoringEngine');
// Set up CLI
program
    .name('context-refactor')
    .description('Provide context-aware refactoring suggestions for the Quantum-Unified Database')
    .version('1.0.0');
// Add commands
program
    .command('analyze')
    .description('Analyze code for refactoring opportunities')
    .argument('<path>', 'Path to the file or directory to analyze')
    .option('-d, --debug', 'Enable debug mode')
    .option('-c, --context <context>', 'Force a specific context')
    .option('-r, --rules <rules...>', 'Specific rules to apply')
    .option('-o, --output <file>', 'Output file for results (JSON format)')
    .option('-f, --format <format>', 'Output format (text, json)', 'text')
    .option('-s, --severity <level>', 'Minimum severity level (low, medium, high, critical)', 'low')
    .action(async (targetPath, options) => {
    try {
        // Create refactoring engine
        const engine = new RefactoringEngine({
            debugMode: options.debug,
            baseDir: process.cwd(),
        });
        // Analyze code
        console.log(chalk.bold(`Analyzing ${targetPath} for refactoring opportunities...`));
        const result = await engine.analyzeCode({
            targetPath,
            context: options.context,
            rules: options.rules,
        });
        // Filter by severity
        const severityLevels = {
            low: 0,
            medium: 1,
            high: 2,
            critical: 3,
        };
        const minSeverity = severityLevels[options.severity] || 0;
        // Format and output results
        if (options.format === 'json') {
            const jsonResult = JSON.stringify(result, null, 2);
            if (options.output) {
                fs.writeFileSync(options.output, jsonResult);
                console.log(chalk.green(`Results written to ${options.output}`));
            }
            else {
                console.log(jsonResult);
            }
        }
        else {
            // Text output
            console.log(chalk.cyan(`\nContext: ${result.context}`));
            if (fs.statSync(targetPath).isDirectory()) {
                // Directory results
                console.log(chalk.cyan(`\nFound ${result.result.totalSuggestions} refactoring suggestions in ${result.result.fileCount} files`));
                for (const fileResult of result.result.fileResults) {
                    console.log(chalk.bold(`\n${path.relative(process.cwd(), fileResult.path)}`));
                    for (const suggestion of fileResult.result.suggestions) {
                        // Skip if below minimum severity
                        if (severityLevels[suggestion.severity] < minSeverity) {
                            continue;
                        }
                        console.log(chalk.yellow(`  ${suggestion.rule}: ${suggestion.suggestion}`));
                        for (const match of suggestion.matches) {
                            console.log(`    - Line ${match.lineStart}: ${match.text.substring(0, 50)}${match.text.length > 50 ? '...' : ''}`);
                        }
                    }
                }
            }
            else {
                // File results
                console.log(chalk.cyan(`\nFound ${result.result.suggestionCount} refactoring suggestions`));
                for (const suggestion of result.result.suggestions) {
                    // Skip if below minimum severity
                    if (severityLevels[suggestion.severity] < minSeverity) {
                        continue;
                    }
                    console.log(chalk.yellow(`\n${suggestion.rule} (${suggestion.severity}): ${suggestion.suggestion}`));
                    for (const match of suggestion.matches) {
                        console.log(`  - Line ${match.lineStart}: ${match.text.substring(0, 50)}${match.text.length > 50 ? '...' : ''}`);
                    }
                }
            }
            if (options.output) {
                fs.writeFileSync(options.output, JSON.stringify(result, null, 2));
                console.log(chalk.green(`\nResults also written to ${options.output}`));
            }
        }
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('list-rules')
    .description('List available refactoring rules')
    .option('-d, --debug', 'Enable debug mode')
    .option('-c, --context <context>', 'Filter by context')
    .action(async (options) => {
    try {
        // Create refactoring engine
        const engine = new RefactoringEngine({
            debugMode: options.debug,
            baseDir: process.cwd(),
        });
        // Get rules
        const rules = options.context
            ? engine.config.refactoringRules[options.context] || []
            : Object.entries(engine.config.refactoringRules);
        console.log(chalk.bold('Available Refactoring Rules:'));
        if (options.context) {
            console.log(chalk.cyan(`\nContext: ${options.context}`));
            for (const rule of rules) {
                console.log(chalk.yellow(`\n${rule.name} (${rule.severity})`));
                console.log(`  ${rule.description}`);
                console.log(`  Suggestion: ${rule.suggestion}`);
            }
        }
        else {
            for (const [context, contextRules] of rules) {
                console.log(chalk.cyan(`\nContext: ${context}`));
                for (const rule of contextRules) {
                    console.log(chalk.yellow(`\n  ${rule.name} (${rule.severity})`));
                    console.log(`    ${rule.description}`);
                    console.log(`    Suggestion: ${rule.suggestion}`);
                }
            }
        }
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('add-rule')
    .description('Add a custom refactoring rule')
    .option('-d, --debug', 'Enable debug mode')
    .option('-c, --context <context>', 'Rule context', 'general')
    .option('-n, --name <name>', 'Rule name')
    .option('-p, --pattern <pattern>', 'Regular expression pattern')
    .option('-s, --suggestion <suggestion>', 'Refactoring suggestion')
    .option('-v, --severity <level>', 'Severity level (low, medium, high, critical)', 'medium')
    .option('-D, --description <description>', 'Rule description')
    .option('-o, --output <file>', 'Output file for the custom rule')
    .action(async (options) => {
    try {
        // Validate options
        if (!options.name) {
            throw new Error('Rule name is required');
        }
        if (!options.pattern) {
            throw new Error('Regular expression pattern is required');
        }
        if (!options.suggestion) {
            throw new Error('Refactoring suggestion is required');
        }
        // Create rule
        const rule = {
            name: options.name,
            description: options.description || `Custom rule: ${options.name}`,
            pattern: options.pattern,
            suggestion: options.suggestion,
            severity: options.severity,
        };
        console.log(chalk.bold('Custom Refactoring Rule:'));
        console.log(chalk.cyan(`\nContext: ${options.context}`));
        console.log(chalk.yellow(`\n${rule.name} (${rule.severity})`));
        console.log(`  ${rule.description}`);
        console.log(`  Pattern: ${rule.pattern}`);
        console.log(`  Suggestion: ${rule.suggestion}`);
        // Save rule if output file is specified
        if (options.output) {
            let rules = {};
            if (fs.existsSync(options.output)) {
                try {
                    rules = JSON.parse(fs.readFileSync(options.output, 'utf8'));
                }
                catch (error) {
                    console.error(chalk.yellow(`Warning: Could not parse existing rules file. Creating a new one.`));
                    rules = {};
                }
            }
            // Add or update rule
            if (!rules[options.context]) {
                rules[options.context] = [];
            }
            const existingRuleIndex = rules[options.context].findIndex(r => r.name === rule.name);
            if (existingRuleIndex >= 0) {
                rules[options.context][existingRuleIndex] = rule;
            }
            else {
                rules[options.context].push(rule);
            }
            // Save rules
            fs.writeFileSync(options.output, JSON.stringify(rules, null, 2));
            console.log(chalk.green(`\nRule saved to ${options.output}`));
        }
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
// Parse command line arguments
program.parse(process.argv);
// If no arguments, show help
if (process.argv.length === 2) {
    program.help();
}
