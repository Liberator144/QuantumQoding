#!/usr/bin/env node
"use strict";
/**
 * Context-Aware Code Generation CLI
 *
 * Command-line interface for generating code based on context.
 *
 * @version 1.0.0
 */
const fs = require('fs');
const path = require('path');
const { program } = require('commander');
const chalk = require('chalk');
const { ContextCodeGenerator } = require('../context-generation/ContextCodeGenerator');
// Set up CLI
program
    .name('context-generate')
    .description('Generate code based on context for the Quantum-Unified Database')
    .version('1.0.0');
// Add commands
program
    .command('generate')
    .description('Generate code based on context')
    .argument('<path>', 'Path to the file to generate')
    .option('-d, --debug', 'Enable debug mode')
    .option('-t, --template <type>', 'Template type (class, function, etc.)', 'class')
    .option('-c, --context <context>', 'Force a specific context')
    .option('-v, --variable <variables...>', 'Template variables (key=value)')
    .option('-f, --force', 'Force overwrite of existing files')
    .option('-T, --template-dir <dir>', 'Template directory')
    .action(async (targetPath, options) => {
    try {
        // Check if file already exists
        if (fs.existsSync(targetPath) && !options.force) {
            console.error(chalk.red(`Error: File already exists: ${targetPath}`));
            console.error(chalk.yellow('Use --force to overwrite'));
            process.exit(1);
        }
        // Parse variables
        const variables = {};
        if (options.variable) {
            for (const variable of options.variable) {
                const [key, value] = variable.split('=');
                if (key && value) {
                    variables[key] = value;
                }
            }
        }
        // Create code generator
        const generator = new ContextCodeGenerator({
            debugMode: options.debug,
            baseDir: process.cwd(),
            templateDir: options.templateDir,
        });
        // Generate code
        console.log(chalk.bold(`Generating code at ${targetPath}...`));
        const result = await generator.generateCode({
            targetPath,
            templateType: options.template,
            context: options.context,
            variables,
        });
        console.log(chalk.green(`Code generated successfully at ${targetPath}`));
        console.log(chalk.cyan(`Context: ${result.context}`));
        console.log(chalk.cyan(`Template: ${result.template}`));
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('list-templates')
    .description('List available templates')
    .option('-d, --debug', 'Enable debug mode')
    .option('-c, --context <context>', 'Filter by context')
    .option('-T, --template-dir <dir>', 'Template directory')
    .action(async (options) => {
    try {
        // Create code generator
        const generator = new ContextCodeGenerator({
            debugMode: options.debug,
            baseDir: process.cwd(),
            templateDir: options.templateDir,
        });
        // Get available templates
        const templates = generator.getAvailableTemplates(options.context);
        console.log(chalk.bold('Available Templates:'));
        if (options.context) {
            console.log(chalk.cyan(`Context: ${options.context}`));
            for (const [type, templatePath] of Object.entries(templates)) {
                console.log(`  ${type}: ${templatePath}`);
            }
        }
        else {
            for (const [context, contextTemplates] of Object.entries(templates)) {
                console.log(chalk.cyan(`\nContext: ${context}`));
                for (const [type, templatePath] of Object.entries(contextTemplates)) {
                    console.log(`  ${type}: ${templatePath}`);
                }
            }
        }
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
program
    .command('create-template')
    .description('Create a new template')
    .argument('<path>', 'Path to the template file')
    .option('-d, --debug', 'Enable debug mode')
    .option('-c, --context <context>', 'Template context', 'general')
    .option('-t, --template <type>', 'Template type', 'class')
    .option('-T, --template-dir <dir>', 'Template directory')
    .option('-f, --force', 'Force overwrite of existing template')
    .action(async (templatePath, options) => {
    try {
        // Get template directory
        const templateDir = options.templateDir || path.join(process.cwd(), 'templates');
        // Create context directory
        const contextDir = path.join(templateDir, options.context);
        if (!fs.existsSync(contextDir)) {
            fs.mkdirSync(contextDir, { recursive: true });
        }
        // Create template path
        const fullTemplatePath = path.join(contextDir, `${options.template}.js.template`);
        // Check if template already exists
        if (fs.existsSync(fullTemplatePath) && !options.force) {
            console.error(chalk.red(`Error: Template already exists: ${fullTemplatePath}`));
            console.error(chalk.yellow('Use --force to overwrite'));
            process.exit(1);
        }
        // Create template
        console.log(chalk.bold(`Creating template at ${fullTemplatePath}...`));
        // Read source file
        const content = fs.readFileSync(templatePath, 'utf8');
        // Convert to template
        const templateContent = content
            .replace(/class\s+(\w+)/g, 'class {{ className }}')
            .replace(/function\s+(\w+)/g, 'function {{ functionName }}')
            .replace(/const\s+(\w+)\s*=/g, 'const {{ variableName }} =')
            .replace(/\/\*\*\n\s*\*\s*.*\n\s*\*\s*.*\n\s*\*\//g, '/**\n * {{ description }}\n * \n * @version 1.0.0\n */');
        // Write template
        fs.writeFileSync(fullTemplatePath, templateContent);
        console.log(chalk.green(`Template created successfully at ${fullTemplatePath}`));
    }
    catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
    }
});
// Parse command line arguments
program.parse(process.argv);
// If no arguments, show help
if (process.argv.length === 2) {
    program.help();
}
