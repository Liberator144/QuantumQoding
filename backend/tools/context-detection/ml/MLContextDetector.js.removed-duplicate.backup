"use strict";
/**
 * ML-based Context Detector
 *
 * Uses machine learning to detect the context of code files and directories.
 * This advanced detector goes beyond simple path-based detection by analyzing
 * the actual content of files to determine their purpose and context.
 *
 * @version 1.0.0
 */
const fs = require('fs');
const path = require('path');
const { EventEmitter } = require('events');
const { FeatureExtractor } = require('../../../ml/features/FeatureExtractor');
/**
 * ML-based Context Detector
 */
class MLContextDetector extends EventEmitter {
    /**
     * Create a new MLContextDetector instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: options.debugMode || false,
            // Base directory
            baseDir: options.baseDir || process.cwd(),
            // Include directories
            includeDirs: options.includeDirs || ['src', 'tests', 'docs'],
            // Exclude directories
            excludeDirs: options.excludeDirs || ['node_modules', 'dist', 'build', 'coverage'],
            // Include extensions
            includeExtensions: options.includeExtensions || [
                '.js',
                '.jsx',
                '.ts',
                '.tsx',
                '.md',
                '.json',
            ],
            // Exclude patterns
            excludePatterns: options.excludePatterns || [/\.min\.js$/, /\.bundle\.js$/],
            // Maximum depth for directory traversal
            maxDepth: options.maxDepth || 10,
            // Minimum confidence threshold for context detection
            confidenceThreshold: options.confidenceThreshold || 0.4, // Lowered from 0.7 to be more lenient
            // Context definitions
            contextDefinitions: options.contextDefinitions || {
                core: {
                    keywords: [
                        'core',
                        'base',
                        'foundation',
                        'fundamental',
                        'essential',
                        'component',
                        'initialize',
                    ],
                    patterns: [
                        /class\s+\w+\s*{/g,
                        /class\s+\w+Component/g,
                        /class\s+Core\w+/g,
                        /\w+\.initialize\(/g,
                        /interface\s+\w+\s*{/g,
                        /export\s+(default\s+)?class/g,
                        /module\.exports\s*=/g,
                        /constructor\s*\(/g,
                        /extends\s+\w+/g,
                    ],
                    filePatterns: [/Base\w+\.js$/, /Core\w+\.js$/, /index\.js$/, /\w+Component\.js$/],
                },
                flow: {
                    keywords: [
                        'flow',
                        'stream',
                        'pipeline',
                        'process',
                        'sequence',
                        'async',
                        'await',
                        'promise',
                    ],
                    patterns: [
                        /async\s+function/g,
                        /async\s+\w+/g,
                        /\.then\(/g,
                        /await\s+/g,
                        /new\s+Promise/g,
                        /\.pipe\(/g,
                        /\.process\(/g,
                        /\.next\(/g,
                        /yield/g,
                        /generator/gi,
                    ],
                    filePatterns: [
                        /Flow\w+\.js$/,
                        /Stream\w+\.js$/,
                        /Pipeline\w+\.js$/,
                        /\w+Flow\.js$/,
                        /Process\w+\.js$/,
                    ],
                },
                verification: {
                    keywords: ['verify', 'validate', 'test', 'assert', 'check', 'ensure'],
                    patterns: [/assert\(/g, /expect\(/g, /test\(/g, /describe\(/g, /it\(/g, /should\(/g],
                    filePatterns: [/Test\w+\.js$/, /\w+Test\.js$/, /\w+Spec\.js$/, /Verifier\.js$/],
                },
                visualization: {
                    keywords: ['visual', 'chart', 'graph', 'display', 'render', 'draw'],
                    patterns: [/render\(/g, /draw\(/g, /canvas/g, /svg/g, /d3\./g, /chart/gi],
                    filePatterns: [/Chart\w+\.js$/, /Graph\w+\.js$/, /Visualization\w+\.js$/],
                },
                security: {
                    keywords: ['security', 'auth', 'permission', 'role', 'access', 'encrypt'],
                    patterns: [/authenticate/g, /authorize/g, /encrypt/g, /decrypt/g, /password/g, /token/g],
                    filePatterns: [/Auth\w+\.js$/, /Security\w+\.js$/, /\w+Auth\.js$/],
                },
                caching: {
                    keywords: ['cache', 'store', 'memory', 'temporary', 'performance'],
                    patterns: [/cache\./g, /\.set\(/g, /\.get\(/g, /invalidate/g, /expire/g],
                    filePatterns: [/Cache\w+\.js$/, /\w+Cache\.js$/],
                },
                schemas: {
                    keywords: ['schema', 'model', 'structure', 'definition', 'type'],
                    patterns: [/schema/gi, /interface\s+\w+/g, /type\s+\w+\s*=/g, /mongoose/g, /sequelize/g],
                    filePatterns: [/Schema\w+\.js$/, /Model\w+\.js$/, /\w+Schema\.js$/, /\w+Model\.js$/],
                },
                optimization: {
                    keywords: ['optimize', 'performance', 'efficient', 'speed', 'fast'],
                    patterns: [/optimize/gi, /performance/gi, /benchmark/gi, /profil/gi, /measure/g],
                    filePatterns: [/Optimize\w+\.js$/, /Performance\w+\.js$/, /\w+Optimizer\.js$/],
                },
                ai: {
                    keywords: ['ai', 'ml', 'machine learning', 'neural', 'predict', 'train'],
                    patterns: [
                        /train\(/g,
                        /predict\(/g,
                        /model\./g,
                        /neural/gi,
                        /tensorflow/g,
                        /classifier/g,
                    ],
                    filePatterns: [/AI\w+\.js$/, /ML\w+\.js$/, /\w+Model\.js$/, /\w+Predictor\.js$/],
                },
                testing: {
                    keywords: [
                        'test',
                        'spec',
                        'assert',
                        'mock',
                        'stub',
                        'fixture',
                        'jest',
                        'mocha',
                        'chai',
                        'should',
                        'expect',
                    ],
                    patterns: [
                        /test\(/g,
                        /describe\(/g,
                        /it\(/g,
                        /expect\(/g,
                        /assert\(/g,
                        /mock\(/g,
                        /should\(/g,
                        /beforeEach\(/g,
                        /afterEach\(/g,
                        /beforeAll\(/g,
                        /afterAll\(/g,
                        /jest\./g,
                        /toEqual\(/g,
                        /toBe\(/g,
                        /toHaveBeenCalled/g,
                    ],
                    filePatterns: [
                        /\w+Test\.js$/,
                        /\w+Spec\.js$/,
                        /test\w+\.js$/,
                        /\.test\.js$/,
                        /\.spec\.js$/,
                    ],
                },
                documentation: {
                    keywords: [
                        'doc',
                        'document',
                        'guide',
                        'readme',
                        'tutorial',
                        'example',
                        'documentation',
                        'api',
                        'reference',
                        'manual',
                    ],
                    patterns: [
                        /\/\*\*/g,
                        /@param/g,
                        /@returns/g,
                        /@example/g,
                        /\* /g,
                        /#\s+/g,
                        /##\s+/g,
                        /###\s+/g,
                        /```/g,
                        /\[.*\]\(.*\)/g,
                        /\*\*.*\*\*/g,
                    ],
                    filePatterns: [
                        /\.md$/,
                        /README\.md$/,
                        /GUIDE\.md$/,
                        /Doc\w+\.js$/,
                        /\.markdown$/,
                        /CONTRIBUTING\.md$/,
                        /CHANGELOG\.md$/,
                    ],
                },
            },
            // Feature weights
            featureWeights: options.featureWeights || {
                path: 0.2,
                filename: 0.4, // Increased from 0.3 to give more weight to filename matches
                content: 0.6, // Increased from 0.5 to give more weight to content matches
            },
            // Model configuration
            model: options.model || {
                type: 'naive-bayes',
                parameters: {},
            },
            // Merge with provided options
            ...options,
        };
        // Initialize
        this._init();
    }
    /**
     * Initialize the detector
     * @private
     */
    _init() {
        this.log('Initializing ML Context Detector');
        // Create feature extractor
        this.featureExtractor = new FeatureExtractor({
            debugMode: this.config.debugMode,
        });
        // Initialize context cache
        this.contextCache = new Map();
        this.log('ML Context Detector initialized');
    }
    /**
     * Detect context for a file or directory
     * @param {string} targetPath - Path to file or directory
     * @param {Object} options - Detection options
     * @returns {Promise<Object>} Detection result
     */
    async detectContext(targetPath, options = {}) {
        try {
            const fullPath = path.resolve(this.config.baseDir, targetPath);
            // Check if path exists
            if (!fs.existsSync(fullPath)) {
                throw new Error(`Path does not exist: ${fullPath}`);
            }
            // Check if result is cached
            const cacheKey = `${fullPath}:${JSON.stringify(options)}`;
            if (this.contextCache.has(cacheKey)) {
                return this.contextCache.get(cacheKey);
            }
            // Detect context
            let result;
            if (fs.statSync(fullPath).isDirectory()) {
                result = await this._detectDirectoryContext(fullPath, options);
            }
            else {
                result = await this._detectFileContext(fullPath, options);
            }
            // Cache result
            this.contextCache.set(cacheKey, result);
            return result;
        }
        catch (error) {
            this.log(`Error detecting context: ${error.message}`);
            throw error;
        }
    }
    /**
     * Detect context for a file
     * @param {string} filePath - Path to file
     * @param {Object} options - Detection options
     * @returns {Promise<Object>} Detection result
     * @private
     */
    async _detectFileContext(filePath, options = {}) {
        this.log(`Detecting context for file: ${filePath}`);
        // Extract features
        const features = await this._extractFileFeatures(filePath);
        // Calculate context scores
        const scores = this._calculateContextScores(features);
        // Find best context
        const bestContext = this._findBestContext(scores);
        return {
            path: filePath,
            type: 'file',
            context: bestContext.context,
            confidence: bestContext.score,
            scores,
            features,
        };
    }
    /**
     * Detect context for a directory
     * @param {string} dirPath - Path to directory
     * @param {Object} options - Detection options
     * @returns {Promise<Object>} Detection result
     * @private
     */
    async _detectDirectoryContext(dirPath, options = {}) {
        this.log(`Detecting context for directory: ${dirPath}`);
        // Get files in directory
        const files = await this._getFilesInDirectory(dirPath, options);
        // Detect context for each file
        const fileContexts = [];
        for (const file of files) {
            try {
                const fileContext = await this._detectFileContext(file, options);
                fileContexts.push(fileContext);
            }
            catch (error) {
                this.log(`Error detecting context for file ${file}: ${error.message}`);
            }
        }
        // Aggregate contexts
        const aggregatedScores = this._aggregateContextScores(fileContexts);
        // Find best context
        const bestContext = this._findBestContext(aggregatedScores);
        return {
            path: dirPath,
            type: 'directory',
            context: bestContext.context,
            confidence: bestContext.score,
            scores: aggregatedScores,
            fileContexts,
        };
    }
    /**
     * Extract features from a file
     * @param {string} filePath - Path to file
     * @returns {Promise<Object>} Extracted features
     * @private
     */
    async _extractFileFeatures(filePath) {
        // Get file content
        const content = fs.readFileSync(filePath, 'utf8');
        // Extract path features
        const pathFeatures = this._extractPathFeatures(filePath);
        // Extract content features
        const contentFeatures = this._extractContentFeatures(content, path.extname(filePath));
        return {
            path: pathFeatures,
            content: contentFeatures,
        };
    }
    /**
     * Extract features from a file path
     * @param {string} filePath - Path to file
     * @returns {Object} Extracted features
     * @private
     */
    _extractPathFeatures(filePath) {
        const parsedPath = path.parse(filePath);
        const relativePath = path.relative(this.config.baseDir, filePath);
        const pathSegments = relativePath.split(path.sep);
        return {
            filename: parsedPath.base,
            basename: parsedPath.name,
            extension: parsedPath.ext,
            directory: parsedPath.dir,
            relativePath,
            pathSegments,
        };
    }
    /**
     * Extract features from file content
     * @param {string} content - File content
     * @param {string} extension - File extension
     * @returns {Object} Extracted features
     * @private
     */
    _extractContentFeatures(content, extension) {
        // Basic features
        const features = {
            length: content.length,
            lineCount: content.split('\n').length,
            wordCount: content.split(/\s+/).length,
            keywords: {},
            patterns: {},
        };
        // Extract keywords and patterns for each context
        for (const [context, definition] of Object.entries(this.config.contextDefinitions)) {
            // Check keywords
            features.keywords[context] = 0;
            for (const keyword of definition.keywords) {
                const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                const matches = content.match(regex);
                if (matches) {
                    features.keywords[context] += matches.length;
                }
            }
            // Check patterns
            features.patterns[context] = 0;
            for (const pattern of definition.patterns) {
                const matches = content.match(pattern);
                if (matches) {
                    features.patterns[context] += matches.length;
                }
            }
        }
        return features;
    }
    /**
     * Calculate context scores based on features
     * @param {Object} features - Extracted features
     * @returns {Object} Context scores
     * @private
     */
    _calculateContextScores(features) {
        const scores = {};
        // Initialize scores
        for (const context in this.config.contextDefinitions) {
            scores[context] = 0;
        }
        // Calculate path-based score
        this._calculatePathScores(features.path, scores);
        // Calculate content-based score
        this._calculateContentScores(features.content, scores);
        // Add bonus for filename matches
        this._calculateFilenameBonus(features.path.filename, scores);
        // Normalize scores
        const totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0);
        if (totalScore > 0) {
            for (const context in scores) {
                scores[context] /= totalScore;
            }
        }
        return scores;
    }
    /**
     * Calculate bonus scores for filename matches
     * @param {string} filename - Filename
     * @param {Object} scores - Context scores to update
     * @private
     */
    _calculateFilenameBonus(filename, scores) {
        for (const [context, definition] of Object.entries(this.config.contextDefinitions)) {
            // Check if filename matches any of the patterns
            for (const pattern of definition.filePatterns) {
                if (pattern.test(filename)) {
                    // Add a significant bonus for filename match
                    scores[context] += 15 * this.config.featureWeights.filename;
                    this.log(`Added filename bonus for ${context} based on ${filename}`);
                }
            }
        }
    }
    /**
     * Calculate path-based scores
     * @param {Object} pathFeatures - Path features
     * @param {Object} scores - Context scores to update
     * @private
     */
    _calculatePathScores(pathFeatures, scores) {
        const { filename, pathSegments } = pathFeatures;
        // Check each context definition
        for (const [context, definition] of Object.entries(this.config.contextDefinitions)) {
            // Check file patterns
            for (const pattern of definition.filePatterns) {
                if (pattern.test(filename)) {
                    scores[context] += 10 * this.config.featureWeights.filename;
                }
            }
            // Check path segments
            for (const segment of pathSegments) {
                for (const keyword of definition.keywords) {
                    if (segment.toLowerCase().includes(keyword.toLowerCase())) {
                        scores[context] += 5 * this.config.featureWeights.path;
                    }
                }
            }
        }
    }
    /**
     * Calculate content-based scores
     * @param {Object} contentFeatures - Content features
     * @param {Object} scores - Context scores to update
     * @private
     */
    _calculateContentScores(contentFeatures, scores) {
        const { keywords, patterns } = contentFeatures;
        // Add keyword scores
        for (const context in keywords) {
            scores[context] += keywords[context] * this.config.featureWeights.content;
        }
        // Add pattern scores
        for (const context in patterns) {
            scores[context] += patterns[context] * 2 * this.config.featureWeights.content;
        }
    }
    /**
     * Find the best context based on scores
     * @param {Object} scores - Context scores
     * @returns {Object} Best context and score
     * @private
     */
    _findBestContext(scores) {
        let bestContext = 'general';
        let bestScore = 0;
        for (const context in scores) {
            if (scores[context] > bestScore) {
                bestContext = context;
                bestScore = scores[context];
            }
        }
        // Check if score meets threshold
        if (bestScore < this.config.confidenceThreshold) {
            // Check if any context is close to the threshold
            const closeContexts = Object.entries(scores)
                .filter(([_, score]) => score >= this.config.confidenceThreshold * 0.8)
                .sort((a, b) => b[1] - a[1]);
            if (closeContexts.length > 0) {
                bestContext = closeContexts[0][0];
                bestScore = closeContexts[0][1];
                this.log(`Using close context match: ${bestContext} with score ${bestScore}`);
            }
            else {
                bestContext = 'general';
                bestScore = Math.max(bestScore, 0.5); // Minimum confidence for general context
            }
        }
        return {
            context: bestContext,
            score: bestScore,
        };
    }
    /**
     * Aggregate context scores from multiple files
     * @param {Array} fileContexts - File context results
     * @returns {Object} Aggregated scores
     * @private
     */
    _aggregateContextScores(fileContexts) {
        const aggregatedScores = {};
        // Initialize scores
        for (const context in this.config.contextDefinitions) {
            aggregatedScores[context] = 0;
        }
        // Add scores from each file
        for (const fileContext of fileContexts) {
            for (const context in fileContext.scores) {
                aggregatedScores[context] += fileContext.scores[context] * fileContext.confidence;
            }
        }
        // Normalize scores
        const totalScore = Object.values(aggregatedScores).reduce((sum, score) => sum + score, 0);
        if (totalScore > 0) {
            for (const context in aggregatedScores) {
                aggregatedScores[context] /= totalScore;
            }
        }
        return aggregatedScores;
    }
    /**
     * Get all files in a directory recursively
     * @param {string} dirPath - Directory path
     * @param {Object} options - Options
     * @param {number} depth - Current depth
     * @returns {Promise<Array>} Array of file paths
     * @private
     */
    async _getFilesInDirectory(dirPath, options = {}, depth = 0) {
        // Check max depth
        if (depth > this.config.maxDepth) {
            return [];
        }
        const files = [];
        const entries = fs.readdirSync(dirPath, { withFileTypes: true });
        for (const entry of entries) {
            const entryPath = path.join(dirPath, entry.name);
            // Skip excluded directories
            if (entry.isDirectory() && this.config.excludeDirs.includes(entry.name)) {
                continue;
            }
            if (entry.isDirectory()) {
                // Recursively get files in subdirectory
                const subFiles = await this._getFilesInDirectory(entryPath, options, depth + 1);
                files.push(...subFiles);
            }
            else if (entry.isFile()) {
                // Check file extension
                const ext = path.extname(entry.name);
                if (this.config.includeExtensions.includes(ext)) {
                    // Check exclude patterns
                    let excluded = false;
                    for (const pattern of this.config.excludePatterns) {
                        if (pattern.test(entry.name)) {
                            excluded = true;
                            break;
                        }
                    }
                    if (!excluded) {
                        files.push(entryPath);
                    }
                }
            }
        }
        return files;
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[MLContextDetector] ${message}`);
        }
    }
}
module.exports = { MLContextDetector };
