/**
 * Core Memory Bank service implementation
 */
import { EventEmitter } from 'events';
/**
 * Events emitted by the MemoryBank
 */
export var MemoryBankEvent;
(function (MemoryBankEvent) {
    MemoryBankEvent["MEMORY_CREATED"] = "memory-created";
    MemoryBankEvent["MEMORY_UPDATED"] = "memory-updated";
    MemoryBankEvent["MEMORY_DELETED"] = "memory-deleted";
    MemoryBankEvent["MEMORY_ACCESSED"] = "memory-accessed";
})(MemoryBankEvent || (MemoryBankEvent = {}));
/**
 * Core Memory Bank service
 * Provides the main interface for interacting with memories
 */
export class MemoryBank {
    constructor(storage) {
        this.storage = storage;
        this.eventEmitter = new EventEmitter();
    }
    /**
     * Store a new memory
     */
    async createMemory(content, type, tags = [], metadata = {}, options = {}) {
        const memory = await this.storage.storeMemory({
            content,
            type,
            tags,
            metadata,
            accessCount: 0,
            lastAccessedAt: new Date(),
            createdBy: options.createdBy || 'system',
            projectContext: options.projectContext,
            filePath: options.filePath,
        });
        this.eventEmitter.emit(MemoryBankEvent.MEMORY_CREATED, memory);
        return memory;
    }
    /**
     * Retrieve a memory by ID
     */
    async getMemory(id) {
        const memory = await this.storage.getMemory(id);
        if (memory) {
            await this.storage.recordAccess(id);
            this.eventEmitter.emit(MemoryBankEvent.MEMORY_ACCESSED, memory);
        }
        return memory;
    }
    /**
     * Update an existing memory
     */
    async updateMemory(id, updates) {
        const memory = await this.storage.updateMemory(id, updates);
        this.eventEmitter.emit(MemoryBankEvent.MEMORY_UPDATED, memory);
        return memory;
    }
    /**
     * Delete a memory
     */
    async deleteMemory(id) {
        const success = await this.storage.deleteMemory(id);
        if (success) {
            this.eventEmitter.emit(MemoryBankEvent.MEMORY_DELETED, { id });
        }
        return success;
    }
    /**
     * Query memories based on various criteria
     */
    async queryMemories(query) {
        return this.storage.queryMemories(query);
    }
    /**
     * Subscribe to memory events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from memory events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
    /**
     * Find related memories based on content similarity
     */
    async findRelatedMemories(memoryId, limit = 5) {
        const memory = await this.getMemory(memoryId);
        if (!memory) {
            return [];
        }
        // If the memory has predefined related memories, retrieve those
        if (memory.relatedMemories && memory.relatedMemories.length > 0) {
            const relatedMemories = await Promise.all(memory.relatedMemories.map(id => this.storage.getMemory(id)));
            return relatedMemories.filter(m => m !== null);
        }
        // Otherwise, find related memories based on tags and content
        const query = {
            tags: memory.tags,
            type: memory.type,
            limit,
            sortBy: 'priority',
            sortDirection: 'desc',
        };
        const result = await this.storage.queryMemories(query);
        return result.memories.filter(m => m.id !== memory.id);
    }
}
