/**
 * Visualization Manager for Knowledge Graph Visualization
 * Coordinates the visualization process
 */
import { EventEmitter } from 'events';
import { DEFAULT_VIS_OPTIONS, } from './types';
import { GraphConverter } from './graph-converter';
/**
 * Events emitted by the visualization manager
 */
export var VisualizationEvent;
(function (VisualizationEvent) {
    VisualizationEvent["GRAPH_LOADED"] = "graph-loaded";
    VisualizationEvent["GRAPH_FILTERED"] = "graph-filtered";
    VisualizationEvent["GRAPH_LAYOUT_CHANGED"] = "graph-layout-changed";
    VisualizationEvent["NODE_SELECTED"] = "node-selected";
    VisualizationEvent["EDGE_SELECTED"] = "edge-selected";
    VisualizationEvent["SELECTION_CHANGED"] = "selection-changed";
    VisualizationEvent["HOVER_CHANGED"] = "hover-changed";
    VisualizationEvent["EXPORT_COMPLETED"] = "export-completed";
})(VisualizationEvent || (VisualizationEvent = {}));
/**
 * Export format
 */
export var ExportFormat;
(function (ExportFormat) {
    ExportFormat["JSON"] = "json";
    ExportFormat["PNG"] = "png";
    ExportFormat["SVG"] = "svg";
    ExportFormat["DOT"] = "dot";
})(ExportFormat || (ExportFormat = {}));
/**
 * Layout algorithm
 */
export var LayoutAlgorithm;
(function (LayoutAlgorithm) {
    LayoutAlgorithm["FORCE_DIRECTED"] = "force-directed";
    LayoutAlgorithm["HIERARCHICAL"] = "hierarchical";
    LayoutAlgorithm["CIRCULAR"] = "circular";
    LayoutAlgorithm["GRID"] = "grid";
    LayoutAlgorithm["RADIAL"] = "radial";
})(LayoutAlgorithm || (LayoutAlgorithm = {}));
/**
 * Manages the visualization process
 */
export class VisualizationManager {
    constructor(graphBuilder, graphAnalyzer, options = {}) {
        this.currentGraph = null;
        this.currentVisGraph = null;
        this.currentFilter = null;
        this.selectedNodeIds = new Set();
        this.selectedEdgeIds = new Set();
        this.hoveredNodeId = null;
        this.hoveredEdgeId = null;
        this.graphBuilder = graphBuilder;
        this.graphAnalyzer = graphAnalyzer;
        this.graphConverter = new GraphConverter();
        this.currentOptions = {
            ...DEFAULT_VIS_OPTIONS,
            ...options,
        };
        this.eventEmitter = new EventEmitter();
    }
    /**
     * Load a knowledge graph
     */
    async loadGraph(graph, filter) {
        this.currentGraph = graph;
        this.currentFilter = filter || null;
        // Convert graph to visualization format
        this.currentVisGraph = this.graphConverter.convertToVisGraph(graph, filter, this.currentOptions);
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.GRAPH_LOADED, {
            graph: this.currentVisGraph,
            originalGraph: graph,
            filter,
        });
        return this.currentVisGraph;
    }
    /**
     * Apply filter to the current graph
     */
    applyFilter(filter) {
        if (!this.currentGraph) {
            throw new Error('No graph loaded');
        }
        this.currentFilter = filter;
        // Convert graph to visualization format with new filter
        this.currentVisGraph = this.graphConverter.convertToVisGraph(this.currentGraph, filter, this.currentOptions);
        // Clear selections
        this.selectedNodeIds.clear();
        this.selectedEdgeIds.clear();
        this.hoveredNodeId = null;
        this.hoveredEdgeId = null;
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.GRAPH_FILTERED, {
            graph: this.currentVisGraph,
            filter,
        });
        return this.currentVisGraph;
    }
    /**
     * Update visualization options
     */
    updateOptions(options) {
        this.currentOptions = {
            ...this.currentOptions,
            ...options,
        };
        if (!this.currentGraph) {
            return null;
        }
        // Convert graph to visualization format with new options
        this.currentVisGraph = this.graphConverter.convertToVisGraph(this.currentGraph, this.currentFilter || undefined, this.currentOptions);
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.GRAPH_LAYOUT_CHANGED, {
            graph: this.currentVisGraph,
            options: this.currentOptions,
        });
        return this.currentVisGraph;
    }
    /**
     * Change layout algorithm
     */
    changeLayout(algorithm) {
        // Update options based on algorithm
        switch (algorithm) {
            case LayoutAlgorithm.FORCE_DIRECTED:
                this.updateOptions({
                    layout: {
                        hierarchical: false,
                        improvedLayout: true,
                    },
                    physics: {
                        solver: 'forceAtlas2Based',
                        stabilization: {
                            iterations: 100,
                        },
                    },
                });
                break;
            case LayoutAlgorithm.HIERARCHICAL:
                this.updateOptions({
                    layout: {
                        hierarchical: {
                            direction: 'UD',
                            sortMethod: 'directed',
                            levelSeparation: 150,
                            nodeSpacing: 100,
                        },
                    },
                    physics: {
                        solver: 'hierarchicalRepulsion',
                    },
                });
                break;
            case LayoutAlgorithm.CIRCULAR:
                this.updateOptions({
                    layout: {
                        improvedLayout: true,
                    },
                    physics: {
                        solver: 'forceAtlas2Based',
                        stabilization: {
                            iterations: 100,
                        },
                    },
                });
                break;
            case LayoutAlgorithm.GRID:
                this.updateOptions({
                    layout: {
                        improvedLayout: true,
                    },
                    physics: false,
                });
                break;
            case LayoutAlgorithm.RADIAL:
                this.updateOptions({
                    layout: {
                        improvedLayout: true,
                    },
                    physics: {
                        solver: 'repulsion',
                    },
                });
                break;
        }
        return this.currentVisGraph;
    }
    /**
     * Handle visualization events
     */
    handleEvent(event) {
        switch (event.type) {
            case 'nodeClick':
                if (event.nodeId) {
                    this.handleNodeClick(event.nodeId);
                }
                break;
            case 'edgeClick':
                if (event.edgeId) {
                    this.handleEdgeClick(event.edgeId);
                }
                break;
            case 'nodeHover':
                this.handleNodeHover(event.nodeId || null);
                break;
            case 'edgeHover':
                this.handleEdgeHover(event.edgeId || null);
                break;
            case 'nodeSelect':
                this.handleSelectionChange(event.selectedNodeIds || [], event.selectedEdgeIds || []);
                break;
            case 'edgeSelect':
                this.handleSelectionChange(event.selectedNodeIds || [], event.selectedEdgeIds || []);
                break;
        }
    }
    /**
     * Handle node click
     */
    handleNodeClick(nodeId) {
        // Toggle selection
        if (this.selectedNodeIds.has(nodeId)) {
            this.selectedNodeIds.delete(nodeId);
        }
        else {
            this.selectedNodeIds.add(nodeId);
        }
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.NODE_SELECTED, {
            nodeId,
            selected: this.selectedNodeIds.has(nodeId),
            node: this.getVisNode(nodeId),
        });
    }
    /**
     * Handle edge click
     */
    handleEdgeClick(edgeId) {
        // Toggle selection
        if (this.selectedEdgeIds.has(edgeId)) {
            this.selectedEdgeIds.delete(edgeId);
        }
        else {
            this.selectedEdgeIds.add(edgeId);
        }
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.EDGE_SELECTED, {
            edgeId,
            selected: this.selectedEdgeIds.has(edgeId),
            edge: this.getVisEdge(edgeId),
        });
    }
    /**
     * Handle node hover
     */
    handleNodeHover(nodeId) {
        this.hoveredNodeId = nodeId;
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.HOVER_CHANGED, {
            hoveredNodeId: nodeId,
            hoveredEdgeId: this.hoveredEdgeId,
            hoveredNode: nodeId ? this.getVisNode(nodeId) : null,
            hoveredEdge: this.hoveredEdgeId ? this.getVisEdge(this.hoveredEdgeId) : null,
        });
    }
    /**
     * Handle edge hover
     */
    handleEdgeHover(edgeId) {
        this.hoveredEdgeId = edgeId;
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.HOVER_CHANGED, {
            hoveredNodeId: this.hoveredNodeId,
            hoveredEdgeId: edgeId,
            hoveredNode: this.hoveredNodeId ? this.getVisNode(this.hoveredNodeId) : null,
            hoveredEdge: edgeId ? this.getVisEdge(edgeId) : null,
        });
    }
    /**
     * Handle selection change
     */
    handleSelectionChange(selectedNodeIds, selectedEdgeIds) {
        this.selectedNodeIds = new Set(selectedNodeIds);
        this.selectedEdgeIds = new Set(selectedEdgeIds);
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.SELECTION_CHANGED, {
            selectedNodeIds: Array.from(this.selectedNodeIds),
            selectedEdgeIds: Array.from(this.selectedEdgeIds),
            selectedNodes: Array.from(this.selectedNodeIds)
                .map(id => this.getVisNode(id))
                .filter(Boolean),
            selectedEdges: Array.from(this.selectedEdgeIds)
                .map(id => this.getVisEdge(id))
                .filter(Boolean),
        });
    }
    /**
     * Get visualization node by ID
     */
    getVisNode(nodeId) {
        if (!this.currentVisGraph) {
            return null;
        }
        return this.currentVisGraph.nodes.find(node => node.id === nodeId) || null;
    }
    /**
     * Get visualization edge by ID
     */
    getVisEdge(edgeId) {
        if (!this.currentVisGraph) {
            return null;
        }
        return this.currentVisGraph.edges.find(edge => edge.id === edgeId) || null;
    }
    /**
     * Export visualization
     */
    async exportVisualization(format, options) {
        if (!this.currentVisGraph) {
            throw new Error('No graph loaded');
        }
        let result;
        switch (format) {
            case ExportFormat.JSON:
                result = JSON.stringify(this.currentVisGraph, null, 2);
                break;
            case ExportFormat.PNG:
            case ExportFormat.SVG:
            case ExportFormat.DOT:
                // These formats would require integration with a rendering engine
                throw new Error(`Export to ${format} not implemented`);
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
        // Emit event
        this.eventEmitter.emit(VisualizationEvent.EXPORT_COMPLETED, {
            format,
            result,
        });
        return result;
    }
    /**
     * Subscribe to visualization events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from visualization events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
}
