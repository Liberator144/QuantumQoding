/**
 * Knowledge Transfer Manager
 * Central manager for cross-project knowledge transfer
 */
import { EventEmitter } from 'events';
import { DEFAULT_KNOWLEDGE_TRANSFER_CONFIG, } from './types';
import { InMemoryKnowledgeStorage } from './knowledge-storage';
import { ProjectContextManager } from './project-context';
import { CrossProjectSearch } from './cross-project-search';
import { CodePatternExtractor } from './extractors/code-pattern-extractor';
/**
 * Events emitted by the knowledge transfer manager
 */
export var KnowledgeTransferEvent;
(function (KnowledgeTransferEvent) {
    KnowledgeTransferEvent["KNOWLEDGE_CREATED"] = "knowledge-created";
    KnowledgeTransferEvent["KNOWLEDGE_UPDATED"] = "knowledge-updated";
    KnowledgeTransferEvent["KNOWLEDGE_DELETED"] = "knowledge-deleted";
    KnowledgeTransferEvent["KNOWLEDGE_ACCESSED"] = "knowledge-accessed";
    KnowledgeTransferEvent["KNOWLEDGE_APPLIED"] = "knowledge-applied";
    KnowledgeTransferEvent["KNOWLEDGE_EXTRACTED"] = "knowledge-extracted";
    KnowledgeTransferEvent["KNOWLEDGE_SUGGESTED"] = "knowledge-suggested";
})(KnowledgeTransferEvent || (KnowledgeTransferEvent = {}));
/**
 * Central manager for cross-project knowledge transfer
 */
export class KnowledgeTransferManager {
    constructor(storage, projectManager, config = {}) {
        this.storage = storage || new InMemoryKnowledgeStorage();
        this.projectManager = projectManager || new ProjectContextManager();
        this.config = {
            ...DEFAULT_KNOWLEDGE_TRANSFER_CONFIG,
            ...config,
        };
        this.search = new CrossProjectSearch(this.storage, this.projectManager);
        this.extractors = new Map();
        this.eventEmitter = new EventEmitter();
        // Register default extractors
        this.registerExtractor(new CodePatternExtractor());
    }
    /**
     * Register a knowledge extractor
     */
    registerExtractor(extractor) {
        this.extractors.set(extractor.id, extractor);
    }
    /**
     * Unregister a knowledge extractor
     */
    unregisterExtractor(extractorId) {
        return this.extractors.delete(extractorId);
    }
    /**
     * Get a knowledge extractor
     */
    getExtractor(extractorId) {
        return this.extractors.get(extractorId);
    }
    /**
     * Get all knowledge extractors
     */
    getAllExtractors() {
        return Array.from(this.extractors.values());
    }
    /**
     * Create a new knowledge entity
     */
    async createKnowledge(type, title, description, content, sourceProject, tags = [], options = {}) {
        const knowledge = await this.storage.storeKnowledge({
            type,
            title,
            description,
            content,
            sourceProject,
            sourceFilePath: options.sourceFilePath,
            language: options.language,
            tags,
            createdBy: options.createdBy || 'user',
            compatibility: options.compatibility,
            metadata: options.metadata || {},
        });
        // Emit event
        this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_CREATED, knowledge);
        return knowledge;
    }
    /**
     * Get a knowledge entity
     */
    async getKnowledge(id) {
        const knowledge = await this.storage.getKnowledge(id);
        if (knowledge) {
            // Record access
            await this.storage.recordAccess(id);
            // Emit event
            this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_ACCESSED, knowledge);
        }
        return knowledge;
    }
    /**
     * Update a knowledge entity
     */
    async updateKnowledge(id, updates) {
        const knowledge = await this.storage.updateKnowledge(id, updates);
        // Emit event
        this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_UPDATED, knowledge);
        return knowledge;
    }
    /**
     * Delete a knowledge entity
     */
    async deleteKnowledge(id) {
        const knowledge = await this.storage.getKnowledge(id);
        if (!knowledge) {
            return false;
        }
        const success = await this.storage.deleteKnowledge(id);
        if (success) {
            // Emit event
            this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_DELETED, knowledge);
        }
        return success;
    }
    /**
     * Search for knowledge
     */
    async searchKnowledge(query, options = {}) {
        return this.search.search(query, options);
    }
    /**
     * Extract knowledge from content
     */
    async extractKnowledge(content, filePath, projectId, options = {}) {
        const { extractorIds, minConfidence = 0.7, maxResults = 5 } = options;
        // Get project
        const project = this.projectManager.getProject(projectId);
        if (!project) {
            throw new Error(`Project with ID ${projectId} not found`);
        }
        // Get applicable extractors
        let applicableExtractors;
        if (extractorIds && extractorIds.length > 0) {
            // Use specified extractors
            applicableExtractors = extractorIds
                .map(id => this.extractors.get(id))
                .filter(Boolean);
        }
        else {
            // Use all extractors that can handle this file
            applicableExtractors = Array.from(this.extractors.values()).filter(extractor => extractor.canHandle(filePath, content));
        }
        if (applicableExtractors.length === 0) {
            return [];
        }
        // Extract knowledge using all applicable extractors
        const extractionPromises = applicableExtractors.map(extractor => extractor.extractKnowledge(content, filePath, project, {
            minConfidence,
        }));
        const extractionResults = await Promise.all(extractionPromises);
        // Flatten and sort by confidence
        const allKnowledge = extractionResults
            .flat()
            .sort((a, b) => (b.metadata.confidence || 0) - (a.metadata.confidence || 0));
        // Limit results
        const limitedKnowledge = allKnowledge.slice(0, maxResults);
        // Store extracted knowledge
        const storedKnowledge = [];
        for (const knowledge of limitedKnowledge) {
            const stored = await this.storage.storeKnowledge({
                type: knowledge.type,
                title: knowledge.title,
                description: knowledge.description,
                content: knowledge.content,
                sourceProject: knowledge.sourceProject,
                sourceFilePath: knowledge.sourceFilePath,
                language: knowledge.language,
                tags: knowledge.tags,
                createdBy: 'system',
                compatibility: knowledge.compatibility,
                metadata: {
                    ...knowledge.metadata,
                    extractedBy: knowledge.metadata.extractorId || 'unknown',
                },
            });
            storedKnowledge.push(stored);
            // Emit event
            this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_EXTRACTED, stored);
        }
        return storedKnowledge;
    }
    /**
     * Apply knowledge to a target project
     */
    async applyKnowledge(knowledgeId, targetProjectId, options = {}) {
        // Get knowledge
        const knowledge = await this.storage.getKnowledge(knowledgeId);
        if (!knowledge) {
            throw new Error(`Knowledge with ID ${knowledgeId} not found`);
        }
        // Get target project
        const targetProject = this.projectManager.getProject(targetProjectId);
        if (!targetProject) {
            throw new Error(`Project with ID ${targetProjectId} not found`);
        }
        // Record application
        const application = await this.storage.recordApplication({
            knowledgeId,
            projectContext: targetProjectId,
            filePath: options.filePath,
            appliedAt: new Date(),
            appliedBy: options.appliedBy || 'user',
            successful: true,
            modifications: options.modifications,
            notes: options.notes,
        });
        // Emit event
        this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_APPLIED, {
            knowledge,
            application,
            targetProject,
        });
        return application;
    }
    /**
     * Get applications of a knowledge entity
     */
    async getKnowledgeApplications(knowledgeId) {
        return this.storage.getApplications(knowledgeId);
    }
    /**
     * Get applications in a project
     */
    async getProjectApplications(projectId) {
        return this.storage.getProjectApplications(projectId);
    }
    /**
     * Suggest knowledge for a context
     */
    async suggestKnowledge(projectId, context = {}) {
        // Get project
        const project = this.projectManager.getProject(projectId);
        if (!project) {
            throw new Error(`Project with ID ${projectId} not found`);
        }
        // Build search query
        const query = {};
        if (context.content) {
            // Extract key terms from content
            const keyTerms = this.extractKeyTerms(context.content);
            query.searchTerm = keyTerms.join(' ');
        }
        if (context.filePath) {
            // Determine language from file extension
            const extension = context.filePath.split('.').pop()?.toLowerCase();
            if (extension) {
                const languageMap = {
                    js: 'javascript',
                    ts: 'typescript',
                    py: 'python',
                    java: 'java',
                    cs: 'csharp',
                    go: 'go',
                    rb: 'ruby',
                };
                if (languageMap[extension]) {
                    query.language = languageMap[extension];
                }
            }
        }
        // Search for relevant knowledge
        const searchResults = await this.search.search(query, {
            targetProjectId: projectId,
            minRelevance: this.config.minSimilarityScore,
            limit: this.config.maxSuggestions,
        });
        // Convert search results to suggestions
        const suggestions = searchResults.map(result => {
            const suggestion = {
                knowledge: result.knowledge,
                relevance: result.relevance,
                context: {
                    projectContext: projectId,
                    filePath: context.filePath,
                    content: context.content,
                    additionalContext: context.additionalContext,
                },
                message: this.generateSuggestionMessage(result, project),
                createdAt: new Date(),
            };
            // Emit event for each suggestion
            this.eventEmitter.emit(KnowledgeTransferEvent.KNOWLEDGE_SUGGESTED, suggestion);
            return suggestion;
        });
        return suggestions;
    }
    /**
     * Subscribe to knowledge transfer events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from knowledge transfer events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
    /**
     * Extract key terms from content
     */
    extractKeyTerms(content) {
        // This is a simplified implementation
        // A real implementation would use NLP techniques
        // Remove common symbols and split into words
        const words = content
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(word => word.length > 3)
            .map(word => word.toLowerCase());
        // Count word frequencies
        const wordCounts = {};
        for (const word of words) {
            wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
        // Sort by frequency
        const sortedWords = Object.entries(wordCounts)
            .sort((a, b) => b[1] - a[1])
            .map(([word]) => word);
        // Return top words
        return sortedWords.slice(0, 10);
    }
    /**
     * Generate a suggestion message
     */
    generateSuggestionMessage(result, targetProject) {
        const { knowledge, relevance, compatibilityScore, compatibilityNotes } = result;
        let message = `Found relevant knowledge "${knowledge.title}" from project "${knowledge.sourceProject}"`;
        // Add relevance information
        if (relevance > 0.9) {
            message += ' that is highly relevant to your current context';
        }
        else if (relevance > 0.7) {
            message += ' that is relevant to your current context';
        }
        else {
            message += ' that might be relevant to your current context';
        }
        // Add compatibility information
        if (compatibilityScore > 0.9) {
            message += ' and is fully compatible with your project.';
        }
        else if (compatibilityScore > 0.7) {
            message += ' and is mostly compatible with your project.';
        }
        else if (compatibilityScore > 0.5) {
            message += ' but may need some adaptation for your project.';
        }
        else {
            message += ' but will require significant adaptation for your project.';
        }
        // Add compatibility notes if available
        if (compatibilityNotes.length > 0) {
            message += ` Note: ${compatibilityNotes.join(' ')}`;
        }
        return message;
    }
}
