/**
 * Knowledge Graph Model for Cross-Project Knowledge Transfer
 * Represents knowledge as a connected graph for advanced operations
 */
/**
 * Types of relationships between knowledge nodes
 */
export var KnowledgeRelationshipType;
(function (KnowledgeRelationshipType) {
    KnowledgeRelationshipType["RELATED"] = "related";
    KnowledgeRelationshipType["DEPENDS_ON"] = "depends_on";
    KnowledgeRelationshipType["EXTENDS"] = "extends";
    KnowledgeRelationshipType["IMPLEMENTS"] = "implements";
    KnowledgeRelationshipType["SIMILAR_TO"] = "similar_to";
    KnowledgeRelationshipType["CONTRADICTS"] = "contradicts";
    KnowledgeRelationshipType["REPLACES"] = "replaces";
    KnowledgeRelationshipType["CUSTOM"] = "custom";
})(KnowledgeRelationshipType || (KnowledgeRelationshipType = {}));
/**
 * Graph merge strategy
 */
export var GraphMergeStrategy;
(function (GraphMergeStrategy) {
    /** Keep all nodes and relationships from both graphs */
    GraphMergeStrategy["UNION"] = "union";
    /** Keep only nodes and relationships that exist in both graphs */
    GraphMergeStrategy["INTERSECTION"] = "intersection";
    /** Keep nodes and relationships from the first graph, add from second if not conflicting */
    GraphMergeStrategy["FIRST_PRIORITY"] = "first_priority";
    /** Keep nodes and relationships from the second graph, add from first if not conflicting */
    GraphMergeStrategy["SECOND_PRIORITY"] = "second_priority";
    /** Custom merge strategy */
    GraphMergeStrategy["CUSTOM"] = "custom";
})(GraphMergeStrategy || (GraphMergeStrategy = {}));
/**
 * Default graph merge options
 */
export const DEFAULT_GRAPH_MERGE_OPTIONS = {
    strategy: GraphMergeStrategy.UNION,
    mergeNodeMetadata: true,
    mergeRelationshipMetadata: true,
    minRelationshipStrength: 0.3,
    createCrossGraphRelationships: true,
    minCrossGraphSimilarity: 0.7,
    maxCrossGraphRelationships: 100,
};
