/**
 * IDE Integration for Predictive Knowledge Recommendation
 * Integrates recommendation engine with IDE
 */
import { EventEmitter } from 'events';
import { RelevanceLevel, } from '../types';
import { RecommendationEvent } from '../recommendation-engine';
/**
 * IDE integration events
 */
export var IDERecommendationEvent;
(function (IDERecommendationEvent) {
    IDERecommendationEvent["RECOMMENDATIONS_SHOWN"] = "recommendations-shown";
    IDERecommendationEvent["RECOMMENDATION_SELECTED"] = "recommendation-selected";
    IDERecommendationEvent["RECOMMENDATION_APPLIED"] = "recommendation-applied";
    IDERecommendationEvent["RECOMMENDATION_DISMISSED"] = "recommendation-dismissed";
    IDERecommendationEvent["RECOMMENDATION_FEEDBACK"] = "recommendation-feedback";
    IDERecommendationEvent["CONTEXT_CHANGED"] = "context-changed";
})(IDERecommendationEvent || (IDERecommendationEvent = {}));
/**
 * Default notification options
 */
export const DEFAULT_NOTIFICATION_OPTIONS = {
    showInline: true,
    showInPanel: true,
    showAsNotification: true,
    showCodePreview: true,
    autoDismiss: false,
    autoDismissTimeout: 10000,
};
/**
 * Integrates recommendation engine with IDE
 */
export class IDERecommendationIntegration {
    constructor(recommendationEngine, contextProvider, uiProvider, notificationOptions = {}) {
        this.activeRecommendations = [];
        this.lastContextChangeTime = 0;
        this.contextChangeDebounceTime = 500; // ms
        this.isProcessingContext = false;
        this.recommendationEngine = recommendationEngine;
        this.contextProvider = contextProvider;
        this.uiProvider = uiProvider;
        this.notificationOptions = {
            ...DEFAULT_NOTIFICATION_OPTIONS,
            ...notificationOptions,
        };
        this.eventEmitter = new EventEmitter();
        // Set up event listeners
        this.setupEventListeners();
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Listen for recommendation events
        this.recommendationEngine.on(RecommendationEvent.RECOMMENDATION_CREATED, this.handleRecommendationCreated.bind(this));
        this.recommendationEngine.on(RecommendationEvent.RECOMMENDATION_APPLIED, this.handleRecommendationApplied.bind(this));
        this.recommendationEngine.on(RecommendationEvent.RECOMMENDATION_DISMISSED, this.handleRecommendationDismissed.bind(this));
        this.recommendationEngine.on(RecommendationEvent.RECOMMENDATION_FEEDBACK, this.handleRecommendationFeedback.bind(this));
    }
    /**
     * Handle context change
     */
    async handleContextChange() {
        // Debounce context changes
        const now = Date.now();
        this.lastContextChangeTime = now;
        // Wait for debounce time
        setTimeout(async () => {
            // Skip if another context change happened during debounce time
            if (this.lastContextChangeTime !== now || this.isProcessingContext) {
                return;
            }
            this.isProcessingContext = true;
            try {
                // Get current context
                const context = this.getCurrentContext();
                // Emit context changed event
                this.eventEmitter.emit(IDERecommendationEvent.CONTEXT_CHANGED, context);
                // Generate recommendations
                const recommendations = await this.recommendationEngine.generateRecommendations(context);
                // Update active recommendations
                this.activeRecommendations = recommendations;
                // Show recommendations if any
                if (recommendations.length > 0) {
                    this.showRecommendations(recommendations);
                }
            }
            finally {
                this.isProcessingContext = false;
            }
        }, this.contextChangeDebounceTime);
    }
    /**
     * Get current context
     */
    getCurrentContext() {
        return {
            projectId: this.contextProvider.getCurrentProjectId(),
            filePath: this.contextProvider.getCurrentFilePath(),
            fileContent: this.contextProvider.getCurrentFileContent(),
            cursorPosition: this.contextProvider.getCursorPosition(),
            selection: this.contextProvider.getSelection(),
            recentFiles: this.contextProvider.getRecentFiles(),
            recentCommands: this.contextProvider.getRecentCommands(),
            recentErrors: this.contextProvider.getRecentErrors(),
            recentSearches: this.contextProvider.getRecentSearches(),
        };
    }
    /**
     * Show recommendations
     */
    showRecommendations(recommendations) {
        // Show inline if enabled and cursor position is available
        if (this.notificationOptions.showInline) {
            const cursorPosition = this.contextProvider.getCursorPosition();
            if (cursorPosition) {
                this.uiProvider.showInlineRecommendations(recommendations, cursorPosition);
            }
        }
        // Show in panel if enabled
        if (this.notificationOptions.showInPanel) {
            this.uiProvider.showPanelRecommendations(recommendations);
        }
        // Show notification for high relevance recommendations
        if (this.notificationOptions.showAsNotification) {
            const highRelevanceRecommendations = recommendations.filter(r => r.relevanceLevel === RelevanceLevel.CRITICAL || r.relevanceLevel === RelevanceLevel.HIGH);
            for (const recommendation of highRelevanceRecommendations) {
                this.uiProvider.showNotification(recommendation);
                // Mark as viewed
                this.recommendationEngine.markAsViewed(recommendation.id);
            }
        }
        // Emit recommendations shown event
        this.eventEmitter.emit(IDERecommendationEvent.RECOMMENDATIONS_SHOWN, recommendations);
    }
    /**
     * Handle recommendation created
     */
    handleRecommendationCreated(recommendation) {
        // This is handled by the showRecommendations method
    }
    /**
     * Handle recommendation applied
     */
    handleRecommendationApplied(recommendation) {
        // Emit recommendation applied event
        this.eventEmitter.emit(IDERecommendationEvent.RECOMMENDATION_APPLIED, recommendation);
    }
    /**
     * Handle recommendation dismissed
     */
    handleRecommendationDismissed(recommendation) {
        // Emit recommendation dismissed event
        this.eventEmitter.emit(IDERecommendationEvent.RECOMMENDATION_DISMISSED, recommendation);
    }
    /**
     * Handle recommendation feedback
     */
    handleRecommendationFeedback(data) {
        // Emit recommendation feedback event
        this.eventEmitter.emit(IDERecommendationEvent.RECOMMENDATION_FEEDBACK, data);
    }
    /**
     * Select recommendation
     */
    selectRecommendation(recommendationId) {
        const recommendation = this.activeRecommendations.find(r => r.id === recommendationId);
        if (recommendation) {
            // Mark as viewed
            this.recommendationEngine.markAsViewed(recommendation.id);
            // Emit recommendation selected event
            this.eventEmitter.emit(IDERecommendationEvent.RECOMMENDATION_SELECTED, recommendation);
        }
        return recommendation;
    }
    /**
     * Apply recommendation
     */
    async applyRecommendation(recommendationId) {
        const recommendation = this.activeRecommendations.find(r => r.id === recommendationId);
        if (!recommendation) {
            return false;
        }
        // Apply recommendation using UI provider
        const success = await this.uiProvider.applyRecommendation(recommendation);
        if (success) {
            // Mark as applied
            this.recommendationEngine.markAsApplied(recommendation.id);
        }
        return success;
    }
    /**
     * Dismiss recommendation
     */
    dismissRecommendation(recommendationId) {
        return this.recommendationEngine.dismissRecommendation(recommendationId);
    }
    /**
     * Provide feedback for recommendation
     */
    provideFeedback(recommendationId, rating, comment) {
        return this.recommendationEngine.provideFeedback(recommendationId, rating, comment);
    }
    /**
     * Show feedback UI for recommendation
     */
    showFeedbackUI(recommendationId) {
        const recommendation = this.activeRecommendations.find(r => r.id === recommendationId);
        if (recommendation) {
            this.uiProvider.showFeedbackUI(recommendation);
        }
    }
    /**
     * Hide recommendations
     */
    hideRecommendations() {
        this.uiProvider.hideRecommendations();
    }
    /**
     * Update notification options
     */
    updateNotificationOptions(options) {
        this.notificationOptions = {
            ...this.notificationOptions,
            ...options,
        };
    }
    /**
     * Subscribe to IDE recommendation events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from IDE recommendation events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
}
