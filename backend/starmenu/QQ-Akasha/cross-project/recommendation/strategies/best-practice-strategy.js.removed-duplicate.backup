/**
 * Best Practice Recommendation Strategy
 * Strategy for recommending best practices based on developer context
 */
import { RecommendationContext, RecommendationTrigger, } from '../types';
import { KnowledgeType } from '../../types';
import { BaseRecommendationStrategy } from './base-strategy';
/**
 * Strategy for recommending best practices
 */
export class BestPracticeStrategy extends BaseRecommendationStrategy {
    constructor() {
        super('best-practice-strategy', 'Best Practice Recommendation Strategy', [KnowledgeType.BEST_PRACTICE], [
            RecommendationContext.CODE_EDITING,
            RecommendationContext.ARCHITECTURE,
            RecommendationContext.PERFORMANCE,
            RecommendationContext.SECURITY,
            RecommendationContext.TESTING,
            RecommendationContext.DOCUMENTATION,
            RecommendationContext.GENERAL,
        ], [
            RecommendationTrigger.FILE_EDIT,
            RecommendationTrigger.FILE_CREATE,
            RecommendationTrigger.SEARCH,
            RecommendationTrigger.PERIODIC,
            RecommendationTrigger.MANUAL,
        ]);
    }
    /**
     * Calculate relevance score for a best practice
     */
    calculateRelevanceScore(knowledge, analysis, context) {
        let relevanceScore = 0;
        let factorsConsidered = 0;
        // Relevance based on context
        factorsConsidered++;
        switch (analysis.context) {
            case RecommendationContext.ARCHITECTURE:
                if (knowledge.tags.some(tag => tag.includes('architecture') ||
                    tag.includes('design') ||
                    tag.includes('pattern') ||
                    tag.includes('structure'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.PERFORMANCE:
                if (knowledge.tags.some(tag => tag.includes('performance') ||
                    tag.includes('optimization') ||
                    tag.includes('speed') ||
                    tag.includes('efficiency'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.SECURITY:
                if (knowledge.tags.some(tag => tag.includes('security') ||
                    tag.includes('auth') ||
                    tag.includes('validation') ||
                    tag.includes('sanitize'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.TESTING:
                if (knowledge.tags.some(tag => tag.includes('test') ||
                    tag.includes('quality') ||
                    tag.includes('assert') ||
                    tag.includes('coverage'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.DOCUMENTATION:
                if (knowledge.tags.some(tag => tag.includes('documentation') ||
                    tag.includes('comment') ||
                    tag.includes('doc') ||
                    tag.includes('readme'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            default:
                relevanceScore += 0.5;
        }
        // Relevance based on language match
        if (analysis.language && knowledge.language) {
            factorsConsidered++;
            if (analysis.language === knowledge.language) {
                relevanceScore += 1.0;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on framework match
        if (analysis.frameworks &&
            analysis.frameworks.length > 0 &&
            knowledge.compatibility?.frameworks) {
            factorsConsidered++;
            const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
            if (matchingFrameworks.length > 0) {
                relevanceScore += matchingFrameworks.length / analysis.frameworks.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on pattern match
        if (analysis.patterns && analysis.patterns.length > 0) {
            factorsConsidered++;
            const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
            if (matchingPatterns.length > 0) {
                relevanceScore += matchingPatterns.length / analysis.patterns.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on file content
        if (context.fileContent) {
            factorsConsidered++;
            const similarity = this.calculateTextSimilarity(context.fileContent, knowledge.content);
            relevanceScore += similarity;
        }
        // Relevance based on keyword match
        if (analysis.keywords.length > 0) {
            factorsConsidered++;
            const contentLower = knowledge.content.toLowerCase();
            const titleLower = knowledge.title.toLowerCase();
            const descriptionLower = knowledge.description.toLowerCase();
            const matchingKeywords = analysis.keywords.filter(keyword => contentLower.includes(keyword) ||
                titleLower.includes(keyword) ||
                descriptionLower.includes(keyword) ||
                knowledge.tags.some(tag => tag.toLowerCase().includes(keyword)));
            if (matchingKeywords.length > 0) {
                relevanceScore += matchingKeywords.length / analysis.keywords.length;
            }
            else {
                relevanceScore += 0.1;
            }
        }
        // Calculate final relevance score
        return factorsConsidered > 0 ? relevanceScore / factorsConsidered : 0.5;
    }
    /**
     * Generate recommendation reason
     */
    generateRecommendationReason(knowledge, analysis, context) {
        // Generate reason based on trigger and context
        switch (analysis.trigger) {
            case RecommendationTrigger.SEARCH:
                if (context.recentSearches && context.recentSearches.length > 0) {
                    const mostRecentSearch = context.recentSearches.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
                    return `This best practice is relevant to your search for "${mostRecentSearch.query}".`;
                }
                return `This best practice is relevant to your recent search.`;
            case RecommendationTrigger.FILE_CREATE:
                return `This best practice may be useful for the file you're creating.`;
            case RecommendationTrigger.PERIODIC:
                return `This best practice is recommended based on your recent activity.`;
            default:
                // Generate reason based on context
                switch (analysis.context) {
                    case RecommendationContext.ARCHITECTURE:
                        return `This best practice provides guidance on architecture and design patterns.`;
                    case RecommendationContext.PERFORMANCE:
                        return `This best practice can help improve performance in your code.`;
                    case RecommendationContext.SECURITY:
                        return `This best practice can help improve security in your code.`;
                    case RecommendationContext.TESTING:
                        return `This best practice can help improve testing in your code.`;
                    case RecommendationContext.DOCUMENTATION:
                        return `This best practice can help improve documentation in your code.`;
                    default:
                        // Generate reason based on matching factors
                        const factors = [];
                        if (analysis.language &&
                            knowledge.language &&
                            analysis.language === knowledge.language) {
                            factors.push(`it's specific to ${analysis.language}`);
                        }
                        if (analysis.frameworks &&
                            analysis.frameworks.length > 0 &&
                            knowledge.compatibility?.frameworks) {
                            const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
                            if (matchingFrameworks.length > 0) {
                                factors.push(`it's relevant for ${matchingFrameworks.join(', ')}`);
                            }
                        }
                        if (analysis.patterns && analysis.patterns.length > 0) {
                            const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
                            if (matchingPatterns.length > 0) {
                                factors.push(`it's related to the ${matchingPatterns.join(', ')} pattern(s)`);
                            }
                        }
                        if (factors.length > 0) {
                            return `This best practice is relevant because ${factors.join(' and ')}.`;
                        }
                        else {
                            return `This best practice may be relevant to your current task.`;
                        }
                }
        }
    }
    /**
     * Generate application method
     */
    generateApplicationMethod(knowledge, context) {
        // Best practices don't have a direct application method
        return undefined;
    }
}
