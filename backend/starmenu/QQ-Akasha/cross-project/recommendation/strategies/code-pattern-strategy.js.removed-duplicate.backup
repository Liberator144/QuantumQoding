/**
 * Code Pattern Recommendation Strategy
 * Strategy for recommending code patterns based on developer context
 */
import { RecommendationContext, RecommendationTrigger, } from '../types';
import { KnowledgeType } from '../../types';
import { BaseRecommendationStrategy } from './base-strategy';
/**
 * Strategy for recommending code patterns
 */
export class CodePatternStrategy extends BaseRecommendationStrategy {
    constructor() {
        super('code-pattern-strategy', 'Code Pattern Recommendation Strategy', [KnowledgeType.CODE_PATTERN], [
            RecommendationContext.CODE_EDITING,
            RecommendationContext.DEBUGGING,
            RecommendationContext.PERFORMANCE,
            RecommendationContext.SECURITY,
            RecommendationContext.TESTING,
        ], [
            RecommendationTrigger.FILE_EDIT,
            RecommendationTrigger.FILE_CREATE,
            RecommendationTrigger.ERROR_ENCOUNTER,
            RecommendationTrigger.SEARCH,
            RecommendationTrigger.MANUAL,
        ]);
    }
    /**
     * Calculate relevance score for a code pattern
     */
    calculateRelevanceScore(knowledge, analysis, context) {
        let relevanceScore = 0;
        let factorsConsidered = 0;
        // Relevance based on context
        factorsConsidered++;
        switch (analysis.context) {
            case RecommendationContext.DEBUGGING:
                if (knowledge.tags.some(tag => tag.includes('error') ||
                    tag.includes('debug') ||
                    tag.includes('exception') ||
                    tag.includes('handling'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.PERFORMANCE:
                if (knowledge.tags.some(tag => tag.includes('performance') ||
                    tag.includes('optimization') ||
                    tag.includes('cache') ||
                    tag.includes('speed'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.SECURITY:
                if (knowledge.tags.some(tag => tag.includes('security') ||
                    tag.includes('auth') ||
                    tag.includes('validation') ||
                    tag.includes('sanitize'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.TESTING:
                if (knowledge.tags.some(tag => tag.includes('test') ||
                    tag.includes('mock') ||
                    tag.includes('assert') ||
                    tag.includes('spec'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            default:
                relevanceScore += 0.5;
        }
        // Relevance based on language match
        if (analysis.language && knowledge.language) {
            factorsConsidered++;
            if (analysis.language === knowledge.language) {
                relevanceScore += 1.0;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on framework match
        if (analysis.frameworks &&
            analysis.frameworks.length > 0 &&
            knowledge.compatibility?.frameworks) {
            factorsConsidered++;
            const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
            if (matchingFrameworks.length > 0) {
                relevanceScore += matchingFrameworks.length / analysis.frameworks.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on pattern match
        if (analysis.patterns && analysis.patterns.length > 0) {
            factorsConsidered++;
            const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
            if (matchingPatterns.length > 0) {
                relevanceScore += matchingPatterns.length / analysis.patterns.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on code similarity
        if (context.selection?.text) {
            factorsConsidered++;
            const similarity = this.calculateTextSimilarity(context.selection.text, knowledge.content);
            relevanceScore += similarity;
        }
        // Relevance based on keyword match
        if (analysis.keywords.length > 0) {
            factorsConsidered++;
            const contentLower = knowledge.content.toLowerCase();
            const titleLower = knowledge.title.toLowerCase();
            const descriptionLower = knowledge.description.toLowerCase();
            const matchingKeywords = analysis.keywords.filter(keyword => contentLower.includes(keyword) ||
                titleLower.includes(keyword) ||
                descriptionLower.includes(keyword) ||
                knowledge.tags.some(tag => tag.toLowerCase().includes(keyword)));
            if (matchingKeywords.length > 0) {
                relevanceScore += matchingKeywords.length / analysis.keywords.length;
            }
            else {
                relevanceScore += 0.1;
            }
        }
        // Relevance based on error match
        if (context.recentErrors &&
            context.recentErrors.length > 0 &&
            analysis.trigger === RecommendationTrigger.ERROR_ENCOUNTER) {
            factorsConsidered++;
            // Check if the pattern is related to error handling
            if (knowledge.tags.some(tag => tag.includes('error') || tag.includes('exception') || tag.includes('handling'))) {
                relevanceScore += 1.0;
            }
            else {
                // Check if the error message is related to the pattern
                const errorMessages = context.recentErrors.map(e => e.message.toLowerCase());
                const patternContent = knowledge.content.toLowerCase();
                let errorRelevance = 0;
                for (const errorMessage of errorMessages) {
                    const similarity = this.calculateTextSimilarity(errorMessage, patternContent);
                    errorRelevance = Math.max(errorRelevance, similarity);
                }
                relevanceScore += errorRelevance;
            }
        }
        // Calculate final relevance score
        return factorsConsidered > 0 ? relevanceScore / factorsConsidered : 0.5;
    }
    /**
     * Generate recommendation reason
     */
    generateRecommendationReason(knowledge, analysis, context) {
        // Generate reason based on trigger and context
        switch (analysis.trigger) {
            case RecommendationTrigger.ERROR_ENCOUNTER:
                if (context.recentErrors && context.recentErrors.length > 0) {
                    const mostRecentError = context.recentErrors.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
                    return `This code pattern may help resolve the error: "${mostRecentError.message}"`;
                }
                return `This code pattern may help resolve the error you're encountering.`;
            case RecommendationTrigger.SEARCH:
                if (context.recentSearches && context.recentSearches.length > 0) {
                    const mostRecentSearch = context.recentSearches.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
                    return `This code pattern is relevant to your search for "${mostRecentSearch.query}".`;
                }
                return `This code pattern is relevant to your recent search.`;
            case RecommendationTrigger.FILE_CREATE:
                return `This code pattern may be useful for the file you're creating.`;
            default:
                // Generate reason based on matching factors
                const factors = [];
                if (analysis.language && knowledge.language && analysis.language === knowledge.language) {
                    factors.push(`it uses ${analysis.language}`);
                }
                if (analysis.frameworks &&
                    analysis.frameworks.length > 0 &&
                    knowledge.compatibility?.frameworks) {
                    const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
                    if (matchingFrameworks.length > 0) {
                        factors.push(`it's compatible with ${matchingFrameworks.join(', ')}`);
                    }
                }
                if (analysis.patterns && analysis.patterns.length > 0) {
                    const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
                    if (matchingPatterns.length > 0) {
                        factors.push(`it implements the ${matchingPatterns.join(', ')} pattern(s)`);
                    }
                }
                if (factors.length > 0) {
                    return `This code pattern is relevant because ${factors.join(' and ')}.`;
                }
                else {
                    return `This code pattern may be relevant to your current task.`;
                }
        }
    }
    /**
     * Generate application method
     */
    generateApplicationMethod(knowledge, context) {
        // Only generate application method if we have a file path and cursor position
        if (!context.filePath || !context.cursorPosition) {
            return undefined;
        }
        return {
            description: `Apply this code pattern to your code.`,
            codeSnippet: knowledge.content,
            targetFilePath: context.filePath,
            insertPosition: context.cursorPosition,
        };
    }
}
