/**
 * Code Generation Recommendation Strategy
 * Strategy for recommending generated code based on developer context
 */
import { RecommendationContext, RecommendationTrigger, } from '../types';
import { KnowledgeType } from '../../types';
import { BaseRecommendationStrategy } from './base-strategy';
import { extractContext } from '../code-generation/context/context-extractor';
import { extractMultiFileContext } from '../code-generation/context/multi-file/multi-file-context-extractor';
import { selectTemplates } from '../code-generation/engine/template-selector';
import { generateCode } from '../code-generation/engine/code-generator';
/**
 * Strategy for recommending generated code
 */
export class CodeGenerationStrategy extends BaseRecommendationStrategy {
    constructor(templateRepository) {
        super('code-generation-strategy', 'Code Generation Recommendation Strategy', [KnowledgeType.CODE_PATTERN], [
            RecommendationContext.CODE_EDITING,
            RecommendationContext.DEBUGGING,
            RecommendationContext.PERFORMANCE,
            RecommendationContext.SECURITY,
            RecommendationContext.TESTING,
        ], [
            RecommendationTrigger.FILE_EDIT,
            RecommendationTrigger.FILE_CREATE,
            RecommendationTrigger.ERROR_ENCOUNTER,
            RecommendationTrigger.SEARCH,
            RecommendationTrigger.MANUAL,
        ]);
        this.templateRepository = templateRepository;
    }
    /**
     * Calculate relevance score for a code pattern
     */
    calculateRelevanceScore(knowledge, analysis, context) {
        let relevanceScore = 0;
        let factorsConsidered = 0;
        // Relevance based on context
        factorsConsidered++;
        switch (analysis.context) {
            case RecommendationContext.DEBUGGING:
                if (knowledge.tags.some(tag => tag.includes('error') ||
                    tag.includes('debug') ||
                    tag.includes('exception') ||
                    tag.includes('handling'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.PERFORMANCE:
                if (knowledge.tags.some(tag => tag.includes('performance') ||
                    tag.includes('optimization') ||
                    tag.includes('cache') ||
                    tag.includes('speed'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.SECURITY:
                if (knowledge.tags.some(tag => tag.includes('security') ||
                    tag.includes('auth') ||
                    tag.includes('validation') ||
                    tag.includes('sanitize'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            case RecommendationContext.TESTING:
                if (knowledge.tags.some(tag => tag.includes('test') ||
                    tag.includes('mock') ||
                    tag.includes('assert') ||
                    tag.includes('spec'))) {
                    relevanceScore += 1.0;
                }
                else {
                    relevanceScore += 0.3;
                }
                break;
            default:
                relevanceScore += 0.5;
        }
        // Relevance based on language match
        if (analysis.language && knowledge.language) {
            factorsConsidered++;
            if (analysis.language === knowledge.language) {
                relevanceScore += 1.0;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on framework match
        if (analysis.frameworks &&
            analysis.frameworks.length > 0 &&
            knowledge.compatibility?.frameworks) {
            factorsConsidered++;
            const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
            if (matchingFrameworks.length > 0) {
                relevanceScore += matchingFrameworks.length / analysis.frameworks.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on pattern match
        if (analysis.patterns && analysis.patterns.length > 0) {
            factorsConsidered++;
            const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
            if (matchingPatterns.length > 0) {
                relevanceScore += matchingPatterns.length / analysis.patterns.length;
            }
            else {
                relevanceScore += 0.2;
            }
        }
        // Relevance based on code similarity
        if (context.selection?.text) {
            factorsConsidered++;
            const similarity = this.calculateTextSimilarity(context.selection.text, knowledge.content);
            relevanceScore += similarity;
        }
        // Relevance based on keyword match
        if (analysis.keywords.length > 0) {
            factorsConsidered++;
            const contentLower = knowledge.content.toLowerCase();
            const titleLower = knowledge.title.toLowerCase();
            const descriptionLower = knowledge.description.toLowerCase();
            const matchingKeywords = analysis.keywords.filter(keyword => contentLower.includes(keyword) ||
                titleLower.includes(keyword) ||
                descriptionLower.includes(keyword) ||
                knowledge.tags.some(tag => tag.toLowerCase().includes(keyword)));
            if (matchingKeywords.length > 0) {
                relevanceScore += matchingKeywords.length / analysis.keywords.length;
            }
            else {
                relevanceScore += 0.1;
            }
        }
        // Calculate final relevance score
        return factorsConsidered > 0 ? relevanceScore / factorsConsidered : 0.5;
    }
    /**
     * Generate recommendation reason
     */
    generateRecommendationReason(knowledge, analysis, context) {
        // Generate reason based on trigger and context
        switch (analysis.trigger) {
            case RecommendationTrigger.ERROR_ENCOUNTER:
                if (context.recentErrors && context.recentErrors.length > 0) {
                    const mostRecentError = context.recentErrors.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
                    return `Generated code that may help resolve the error: "${mostRecentError.message}"`;
                }
                return `Generated code that may help resolve the error you're encountering.`;
            case RecommendationTrigger.SEARCH:
                if (context.recentSearches && context.recentSearches.length > 0) {
                    const mostRecentSearch = context.recentSearches.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())[0];
                    return `Generated code based on your search for "${mostRecentSearch.query}".`;
                }
                return `Generated code based on your recent search.`;
            case RecommendationTrigger.FILE_CREATE:
                return `Generated code for the file you're creating.`;
            default:
                // Generate reason based on matching factors
                const factors = [];
                if (analysis.language && knowledge.language && analysis.language === knowledge.language) {
                    factors.push(`it uses ${analysis.language}`);
                }
                if (analysis.frameworks &&
                    analysis.frameworks.length > 0 &&
                    knowledge.compatibility?.frameworks) {
                    const matchingFrameworks = analysis.frameworks.filter(framework => knowledge.compatibility.frameworks.includes(framework));
                    if (matchingFrameworks.length > 0) {
                        factors.push(`it's compatible with ${matchingFrameworks.join(', ')}`);
                    }
                }
                if (analysis.patterns && analysis.patterns.length > 0) {
                    const matchingPatterns = analysis.patterns.filter(pattern => knowledge.tags.includes(pattern));
                    if (matchingPatterns.length > 0) {
                        factors.push(`it implements the ${matchingPatterns.join(', ')} pattern(s)`);
                    }
                }
                if (factors.length > 0) {
                    return `Generated code that is relevant because ${factors.join(' and ')}.`;
                }
                else {
                    return `Generated code that may be relevant to your current task.`;
                }
        }
    }
    /**
     * Generate application method
     */
    async generateApplicationMethod(knowledge, context) {
        // Only generate application method if we have a file path and cursor position
        if (!context.filePath || !context.cursorPosition) {
            return undefined;
        }
        try {
            // Determine if we should use multi-file context
            const useMultiFileContext = context.projectFiles && context.projectFiles.length > 0;
            // Extract context
            let extractionResult;
            if (useMultiFileContext) {
                // Extract multi-file context
                extractionResult = await extractMultiFileContext(context.filePath, context.fileContent ?? '', context.projectFiles, context.cursorPosition, context.selection);
            }
            else {
                // Extract single-file context
                extractionResult = await extractContext(context.filePath, context.fileContent ?? '', context.cursorPosition, context.selection);
            }
            // Select templates
            const selectionResult = selectTemplates(this.templateRepository, useMultiFileContext
                ? extractionResult.context.fileContexts.get(context.filePath)
                : extractionResult, {
                language: knowledge.language,
                tags: knowledge.tags,
            });
            // If no templates found, use the knowledge content
            if (selectionResult.templates.length === 0) {
                return {
                    description: `Apply this code pattern to your code.`,
                    codeSnippet: knowledge.content,
                    targetFilePath: context.filePath,
                    insertPosition: context.cursorPosition,
                };
            }
            // Generate code from the first template
            const template = selectionResult.templates[0];
            const generationResult = await generateCode(template, extractionResult, {
                useMultiFileContext,
                validateCrossFileConsistency: useMultiFileContext,
            });
            // If generation failed, use the knowledge content
            if (!generationResult.success) {
                return {
                    description: `Apply this code pattern to your code.`,
                    codeSnippet: knowledge.content,
                    targetFilePath: context.filePath,
                    insertPosition: context.cursorPosition,
                };
            }
            // Return the generated code
            return {
                description: useMultiFileContext
                    ? `Apply this generated code to your file (using multi-file context).`
                    : `Apply this generated code to your file.`,
                codeSnippet: generationResult.generatedCode,
                targetFilePath: context.filePath,
                insertPosition: context.cursorPosition,
            };
        }
        catch (error) {
            console.error('Error generating code:', error);
            // If an error occurs, use the knowledge content
            return {
                description: `Apply this code pattern to your code.`,
                codeSnippet: knowledge.content,
                targetFilePath: context.filePath,
                insertPosition: context.cursorPosition,
            };
        }
    }
}
