/**
 * Base Recommendation Strategy
 * Provides common functionality for all recommendation strategies
 */
import { RelevanceLevel, } from '../types';
import { v4 as uuidv4 } from 'uuid';
/**
 * Abstract base class for recommendation strategies
 */
export class BaseRecommendationStrategy {
    constructor(id, name, supportedKnowledgeTypes, supportedContexts, supportedTriggers) {
        this.id = id;
        this.name = name;
        this.supportedKnowledgeTypes = supportedKnowledgeTypes;
        this.supportedContexts = supportedContexts;
        this.supportedTriggers = supportedTriggers;
    }
    /**
     * Check if this strategy can handle a knowledge type
     */
    canHandleKnowledgeType(type) {
        return this.supportedKnowledgeTypes.includes(type);
    }
    /**
     * Check if this strategy can handle a context
     */
    canHandleContext(context) {
        return this.supportedContexts.includes(context);
    }
    /**
     * Check if this strategy can handle a trigger
     */
    canHandleTrigger(trigger) {
        return this.supportedTriggers.includes(trigger);
    }
    /**
     * Create a recommendation
     */
    createRecommendation(knowledge, relevanceScore, reason, analysis, context) {
        // Determine relevance level
        const relevanceLevel = this.determineRelevanceLevel(relevanceScore);
        // Generate application method
        const applicationMethod = this.generateApplicationMethod(knowledge, context);
        // Create recommendation
        return {
            id: uuidv4(),
            knowledge,
            relevanceScore,
            relevanceLevel,
            reason,
            trigger: analysis.trigger,
            context: analysis.context,
            timestamp: new Date(),
            viewed: false,
            applied: false,
            dismissed: false,
            applicationMethod,
        };
    }
    /**
     * Determine relevance level based on score
     */
    determineRelevanceLevel(score) {
        if (score >= 0.9) {
            return RelevanceLevel.CRITICAL;
        }
        else if (score >= 0.75) {
            return RelevanceLevel.HIGH;
        }
        else if (score >= 0.5) {
            return RelevanceLevel.MEDIUM;
        }
        else {
            return RelevanceLevel.LOW;
        }
    }
    /**
     * Calculate text similarity between two strings
     */
    calculateTextSimilarity(text1, text2) {
        // This is a simplified implementation using Jaccard similarity
        // A real implementation would use more sophisticated NLP techniques
        // Tokenize texts
        const tokens1 = new Set(text1
            .toLowerCase()
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(token => token.length > 3));
        const tokens2 = new Set(text2
            .toLowerCase()
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(token => token.length > 3));
        // Calculate Jaccard similarity
        const intersection = new Set([...tokens1].filter(token => tokens2.has(token)));
        const union = new Set([...tokens1, ...tokens2]);
        return union.size > 0 ? intersection.size / union.size : 0;
    }
}
