/**
 * Types for pattern-based code generation
 */
import { ProgrammingLanguage } from '../templates/types';
/**
 * Design pattern type
 */
export var DesignPatternType;
(function (DesignPatternType) {
    // Creational patterns
    DesignPatternType["SINGLETON"] = "singleton";
    DesignPatternType["FACTORY"] = "factory";
    DesignPatternType["ABSTRACT_FACTORY"] = "abstract-factory";
    DesignPatternType["BUILDER"] = "builder";
    DesignPatternType["PROTOTYPE"] = "prototype";
    // Structural patterns
    DesignPatternType["ADAPTER"] = "adapter";
    DesignPatternType["BRIDGE"] = "bridge";
    DesignPatternType["COMPOSITE"] = "composite";
    DesignPatternType["DECORATOR"] = "decorator";
    DesignPatternType["FACADE"] = "facade";
    DesignPatternType["FLYWEIGHT"] = "flyweight";
    DesignPatternType["PROXY"] = "proxy";
    // Behavioral patterns
    DesignPatternType["CHAIN_OF_RESPONSIBILITY"] = "chain-of-responsibility";
    DesignPatternType["COMMAND"] = "command";
    DesignPatternType["INTERPRETER"] = "interpreter";
    DesignPatternType["ITERATOR"] = "iterator";
    DesignPatternType["MEDIATOR"] = "mediator";
    DesignPatternType["MEMENTO"] = "memento";
    DesignPatternType["OBSERVER"] = "observer";
    DesignPatternType["STATE"] = "state";
    DesignPatternType["STRATEGY"] = "strategy";
    DesignPatternType["TEMPLATE_METHOD"] = "template-method";
    DesignPatternType["VISITOR"] = "visitor";
    // Architectural patterns
    DesignPatternType["MVC"] = "mvc";
    DesignPatternType["MVP"] = "mvp";
    DesignPatternType["MVVM"] = "mvvm";
    DesignPatternType["CLEAN_ARCHITECTURE"] = "clean-architecture";
    DesignPatternType["REPOSITORY"] = "repository";
    // Concurrency patterns
    DesignPatternType["PRODUCER_CONSUMER"] = "producer-consumer";
    DesignPatternType["READER_WRITER"] = "reader-writer";
    DesignPatternType["THREAD_POOL"] = "thread-pool";
    // Other patterns
    DesignPatternType["DEPENDENCY_INJECTION"] = "dependency-injection";
    DesignPatternType["LAZY_LOADING"] = "lazy-loading";
    DesignPatternType["MODULE"] = "module";
    DesignPatternType["MIDDLEWARE"] = "middleware";
    DesignPatternType["PIPELINE"] = "pipeline";
})(DesignPatternType || (DesignPatternType = {}));
/**
 * Design pattern category
 */
export var DesignPatternCategory;
(function (DesignPatternCategory) {
    DesignPatternCategory["CREATIONAL"] = "creational";
    DesignPatternCategory["STRUCTURAL"] = "structural";
    DesignPatternCategory["BEHAVIORAL"] = "behavioral";
    DesignPatternCategory["ARCHITECTURAL"] = "architectural";
    DesignPatternCategory["CONCURRENCY"] = "concurrency";
    DesignPatternCategory["OTHER"] = "other";
})(DesignPatternCategory || (DesignPatternCategory = {}));
/**
 * Pattern detection rule type
 */
export var PatternDetectionRuleType;
(function (PatternDetectionRuleType) {
    /** Check if a class has a private constructor */
    PatternDetectionRuleType["HAS_PRIVATE_CONSTRUCTOR"] = "has-private-constructor";
    /** Check if a class has a static instance */
    PatternDetectionRuleType["HAS_STATIC_INSTANCE"] = "has-static-instance";
    /** Check if a class has a static getInstance method */
    PatternDetectionRuleType["HAS_GET_INSTANCE_METHOD"] = "has-get-instance-method";
    /** Check if a class implements an interface */
    PatternDetectionRuleType["IMPLEMENTS_INTERFACE"] = "implements-interface";
    /** Check if a class extends another class */
    PatternDetectionRuleType["EXTENDS_CLASS"] = "extends-class";
    /** Check if a class has a factory method */
    PatternDetectionRuleType["HAS_FACTORY_METHOD"] = "has-factory-method";
    /** Check if a class has a builder method */
    PatternDetectionRuleType["HAS_BUILDER_METHOD"] = "has-builder-method";
    /** Check if a class has a specific method */
    PatternDetectionRuleType["HAS_METHOD"] = "has-method";
    /** Check if a class has a specific property */
    PatternDetectionRuleType["HAS_PROPERTY"] = "has-property";
    /** Check if a file has a specific import */
    PatternDetectionRuleType["HAS_IMPORT"] = "has-import";
    /** Check if a file has a specific pattern in its content */
    PatternDetectionRuleType["HAS_PATTERN"] = "has-pattern";
    /** Check if a file has a specific naming pattern */
    PatternDetectionRuleType["HAS_NAMING_PATTERN"] = "has-naming-pattern";
    /** Check if a class has a specific annotation */
    PatternDetectionRuleType["HAS_ANNOTATION"] = "has-annotation";
    /** Check if a class has a specific decorator */
    PatternDetectionRuleType["HAS_DECORATOR"] = "has-decorator";
    /** Check if a file has a specific structure */
    PatternDetectionRuleType["HAS_STRUCTURE"] = "has-structure";
    /** Composite rule that requires all sub-rules to match */
    PatternDetectionRuleType["ALL_OF"] = "all-of";
    /** Composite rule that requires any sub-rule to match */
    PatternDetectionRuleType["ANY_OF"] = "any-of";
    /** Composite rule that requires none of the sub-rules to match */
    PatternDetectionRuleType["NONE_OF"] = "none-of";
})(PatternDetectionRuleType || (PatternDetectionRuleType = {}));
/**
 * Default pattern adaptation options
 */
export const DEFAULT_PATTERN_ADAPTATION_OPTIONS = {
    language: ProgrammingLanguage.TYPESCRIPT,
    namingConventions: {
        classes: 'PascalCase',
        interfaces: 'PascalCase',
        methods: 'camelCase',
        variables: 'camelCase',
    },
    includeComments: true,
    includeExamples: true,
    includeImports: true,
};
