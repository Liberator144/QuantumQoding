/**
 * Pattern composer for composing multiple design patterns
 */
import { DEFAULT_PATTERN_ADAPTATION_OPTIONS, } from './types';
import { adaptPattern } from './pattern-adapter';
import { patternRegistry } from './pattern-registry';
import { isLanguageSupported, getLanguageProcessor } from '../language/processor-registry';
/**
 * Default pattern composition options
 */
export const DEFAULT_PATTERN_COMPOSITION_OPTIONS = {
    ...DEFAULT_PATTERN_ADAPTATION_OPTIONS,
    mergeImports: true,
    mergeInterfaces: true,
    mergeClasses: false,
    mergeMethods: false,
    mergeUsageExamples: true,
    compositionStrategy: 'auto',
};
/**
 * Compose multiple patterns
 */
export function composePatterns(patternTypes, fileContext, options = {}) {
    const errors = [];
    const warnings = [];
    const patternResults = [];
    try {
        // Merge options with defaults
        const mergedOptions = {
            ...DEFAULT_PATTERN_COMPOSITION_OPTIONS,
            ...options,
        };
        // Check if there are patterns to compose
        if (patternTypes.length === 0) {
            errors.push('No patterns to compose');
            return {
                code: '',
                patterns: [],
                errors,
                warnings,
                patternResults,
            };
        }
        // If there's only one pattern, just adapt it
        if (patternTypes.length === 1) {
            const result = adaptPattern(patternTypes[0], fileContext, mergedOptions);
            patternResults.push(result);
            return {
                code: result.code,
                patterns: patternTypes,
                errors: result.errors,
                warnings: result.warnings,
                patternResults,
            };
        }
        // Adapt each pattern
        for (const patternType of patternTypes) {
            const result = adaptPattern(patternType, fileContext, mergedOptions);
            patternResults.push(result);
            if (result.errors.length > 0) {
                errors.push(...result.errors.map(error => `Error adapting pattern ${patternType}: ${error}`));
            }
            if (result.warnings.length > 0) {
                warnings.push(...result.warnings.map(warning => `Warning adapting pattern ${patternType}: ${warning}`));
            }
        }
        // Determine composition strategy
        const compositionStrategy = determineCompositionStrategy(patternTypes, mergedOptions.compositionStrategy);
        // Compose patterns based on strategy
        let composedCode = '';
        switch (compositionStrategy) {
            case 'inheritance':
                composedCode = composeWithInheritance(patternResults, mergedOptions);
                break;
            case 'composition':
                composedCode = composeWithComposition(patternResults, mergedOptions);
                break;
            case 'delegation':
                composedCode = composeWithDelegation(patternResults, mergedOptions);
                break;
            default:
                // Default to simple concatenation
                composedCode = composeWithConcatenation(patternResults, mergedOptions);
        }
        // Format composed code
        if (mergedOptions.formatCode && isLanguageSupported(mergedOptions.language)) {
            const processor = getLanguageProcessor(mergedOptions.language);
            if (processor) {
                composedCode = processor.formatCode(composedCode);
            }
        }
        return {
            code: composedCode,
            patterns: patternTypes,
            errors,
            warnings,
            patternResults,
        };
    }
    catch (error) {
        errors.push(`Failed to compose patterns: ${error}`);
        return {
            code: '',
            patterns: patternTypes,
            errors,
            warnings,
            patternResults,
        };
    }
}
/**
 * Determine composition strategy
 */
function determineCompositionStrategy(patternTypes, strategy) {
    if (strategy !== 'auto') {
        return strategy;
    }
    // Get patterns from registry
    const patterns = patternTypes.map(type => patternRegistry.getPattern(type)).filter(Boolean);
    // Check if patterns can be composed with inheritance
    const canUseInheritance = canComposeWithInheritance(patterns);
    if (canUseInheritance) {
        return 'inheritance';
    }
    // Check if patterns can be composed with composition
    const canUseComposition = canComposeWithComposition(patterns);
    if (canUseComposition) {
        return 'composition';
    }
    // Check if patterns can be composed with delegation
    const canUseDelegation = canComposeWithDelegation(patterns);
    if (canUseDelegation) {
        return 'delegation';
    }
    // Default to concatenation
    return 'concatenation';
}
/**
 * Check if patterns can be composed with inheritance
 */
function canComposeWithInheritance(patterns) {
    // This is a simplified implementation
    // In a real implementation, this would check if the patterns can be composed with inheritance
    // For now, just return false to avoid using inheritance
    return false;
}
/**
 * Check if patterns can be composed with composition
 */
function canComposeWithComposition(patterns) {
    // This is a simplified implementation
    // In a real implementation, this would check if the patterns can be composed with composition
    // For now, just return true if there are at least 2 patterns
    return patterns.length >= 2;
}
/**
 * Check if patterns can be composed with delegation
 */
function canComposeWithDelegation(patterns) {
    // This is a simplified implementation
    // In a real implementation, this would check if the patterns can be composed with delegation
    // For now, just return true if there are at least 2 patterns
    return patterns.length >= 2;
}
/**
 * Compose patterns with inheritance
 */
function composeWithInheritance(patternResults, options) {
    // This is a placeholder implementation
    // In a real implementation, this would compose patterns using inheritance
    // For now, just concatenate the code
    return composeWithConcatenation(patternResults, options);
}
/**
 * Compose patterns with composition
 */
function composeWithComposition(patternResults, options) {
    // This is a simplified implementation
    // In a real implementation, this would compose patterns using composition
    // Extract code sections from each pattern
    const sections = patternResults.map(result => extractCodeSections(result.code));
    // Merge imports
    const imports = options.mergeImports
        ? mergeImports(sections.map(section => section.imports))
        : sections.map(section => section.imports).join('\n\n');
    // Merge interfaces
    const interfaces = options.mergeInterfaces
        ? mergeInterfaces(sections.map(section => section.interfaces))
        : sections.map(section => section.interfaces).join('\n\n');
    // Merge classes
    const classes = options.mergeClasses
        ? mergeClasses(sections.map(section => section.classes))
        : sections.map(section => section.classes).join('\n\n');
    // Merge usage examples
    const usageExamples = options.mergeUsageExamples
        ? mergeUsageExamples(sections.map(section => section.usageExamples))
        : sections.map(section => section.usageExamples).join('\n\n');
    // Combine sections
    return [imports, interfaces, classes, usageExamples].filter(Boolean).join('\n\n');
}
/**
 * Compose patterns with delegation
 */
function composeWithDelegation(patternResults, options) {
    // This is a placeholder implementation
    // In a real implementation, this would compose patterns using delegation
    // For now, just concatenate the code
    return composeWithConcatenation(patternResults, options);
}
/**
 * Compose patterns with concatenation
 */
function composeWithConcatenation(patternResults, options) {
    // Simply concatenate the code from each pattern
    return patternResults
        .map(result => result.code)
        .filter(Boolean)
        .join('\n\n// ===== Next Pattern =====\n\n');
}
/**
 * Extract code sections from code
 */
function extractCodeSections(code) {
    // This is a simplified implementation
    // In a real implementation, this would use a proper parser
    const lines = code.split('\n');
    const importLines = [];
    const interfaceLines = [];
    const classLines = [];
    const usageExampleLines = [];
    let currentSection = null;
    let bracketCount = 0;
    for (const line of lines) {
        // Detect section
        if (line.includes('import ')) {
            currentSection = 'imports';
            importLines.push(line);
        }
        else if (line.includes('interface ')) {
            currentSection = 'interfaces';
            interfaceLines.push(line);
            if (line.includes('{'))
                bracketCount++;
        }
        else if (line.includes('class ')) {
            currentSection = 'classes';
            classLines.push(line);
            if (line.includes('{'))
                bracketCount++;
        }
        else if (line.includes('// Usage') || line.includes('// Example')) {
            currentSection = 'usageExamples';
            usageExampleLines.push(line);
        }
        else if (currentSection) {
            // Add line to current section
            switch (currentSection) {
                case 'imports':
                    importLines.push(line);
                    break;
                case 'interfaces':
                    interfaceLines.push(line);
                    if (line.includes('{'))
                        bracketCount++;
                    if (line.includes('}'))
                        bracketCount--;
                    if (bracketCount === 0)
                        currentSection = null;
                    break;
                case 'classes':
                    classLines.push(line);
                    if (line.includes('{'))
                        bracketCount++;
                    if (line.includes('}'))
                        bracketCount--;
                    if (bracketCount === 0)
                        currentSection = null;
                    break;
                case 'usageExamples':
                    usageExampleLines.push(line);
                    break;
            }
        }
        else {
            // If line doesn't belong to any section, add it to usage examples
            usageExampleLines.push(line);
        }
    }
    return {
        imports: importLines.join('\n'),
        interfaces: interfaceLines.join('\n'),
        classes: classLines.join('\n'),
        usageExamples: usageExampleLines.join('\n'),
    };
}
/**
 * Merge imports
 */
function mergeImports(importSections) {
    // This is a simplified implementation
    // In a real implementation, this would merge imports more intelligently
    const importLines = new Set();
    for (const section of importSections) {
        const lines = section.split('\n');
        for (const line of lines) {
            if (line.trim().startsWith('import ')) {
                importLines.add(line);
            }
        }
    }
    return Array.from(importLines).join('\n');
}
/**
 * Merge interfaces
 */
function mergeInterfaces(interfaceSections) {
    // This is a simplified implementation
    // In a real implementation, this would merge interfaces more intelligently
    // For now, just concatenate the interfaces
    return interfaceSections.join('\n\n');
}
/**
 * Merge classes
 */
function mergeClasses(classSections) {
    // This is a simplified implementation
    // In a real implementation, this would merge classes more intelligently
    // For now, just concatenate the classes
    return classSections.join('\n\n');
}
/**
 * Merge usage examples
 */
function mergeUsageExamples(usageExampleSections) {
    // This is a simplified implementation
    // In a real implementation, this would merge usage examples more intelligently
    // For now, just concatenate the usage examples
    return usageExampleSections.join('\n\n');
}
