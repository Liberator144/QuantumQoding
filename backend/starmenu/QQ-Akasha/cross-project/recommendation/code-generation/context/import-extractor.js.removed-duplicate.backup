/**
 * Import extractor for extracting import declarations from code
 */
import { ProgrammingLanguage } from '../templates/types';
/**
 * Extract import declarations from code
 */
export function extractImports(content, language) {
    switch (language) {
        case ProgrammingLanguage.JAVASCRIPT:
        case ProgrammingLanguage.TYPESCRIPT:
            return extractJavaScriptImports(content);
        case ProgrammingLanguage.PYTHON:
            return extractPythonImports(content);
        case ProgrammingLanguage.JAVA:
            return extractJavaImports(content);
        case ProgrammingLanguage.CSHARP:
            return extractCSharpImports(content);
        case ProgrammingLanguage.GO:
            return extractGoImports(content);
        case ProgrammingLanguage.RUST:
            return extractRustImports(content);
        default:
            return [];
    }
}
/**
 * Extract JavaScript/TypeScript import declarations
 */
function extractJavaScriptImports(content) {
    const imports = [];
    // ES6 imports
    // import defaultExport from "module-name";
    // import * as name from "module-name";
    // import { export1, export2 } from "module-name";
    // import { export1 as alias1, export2 as alias2 } from "module-name";
    // import defaultExport, { export1, export2 } from "module-name";
    // import defaultExport, * as name from "module-name";
    // import "module-name";
    const es6ImportRegex = /import\s+(?:(type)\s+)?(?:([^{*,\s]+)\s*,?\s*)?(?:(?:\*\s+as\s+([^{},\s]+))|(?:{([^{}]+)}))?(?:\s+from)?\s+['"]([^'"]+)['"]/g;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip lines that are inside multi-line comments or strings
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Reset regex to search from the beginning of the content
        es6ImportRegex.lastIndex = 0;
        while ((match = es6ImportRegex.exec(line)) !== null) {
            const isTypeOnly = !!match[1];
            const defaultImport = match[2];
            const namespaceImport = match[3];
            const namedImports = match[4];
            const source = match[5];
            const elements = [];
            // Add named imports
            if (namedImports) {
                const namedImportRegex = /([^{},\s]+)(?:\s+as\s+([^{},\s]+))?/g;
                let namedMatch;
                while ((namedMatch = namedImportRegex.exec(namedImports)) !== null) {
                    elements.push(namedMatch[2] || namedMatch[1]);
                }
            }
            imports.push({
                source,
                elements,
                defaultImport,
                namespaceImport,
                isTypeOnly,
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
        // CommonJS require
        // const module = require('module-name');
        // const { export1, export2 } = require('module-name');
        const requireRegex = /(?:const|let|var)\s+(?:([^{},\s]+)|{([^{}]+)})\s*=\s*require\(['"]([^'"]+)['"]\)/g;
        // Reset regex to search from the beginning of the content
        requireRegex.lastIndex = 0;
        while ((match = requireRegex.exec(line)) !== null) {
            const defaultImport = match[1];
            const namedImports = match[2];
            const source = match[3];
            const elements = [];
            // Add named imports
            if (namedImports) {
                const namedImportRegex = /([^{},\s]+)(?:\s*:\s*([^{},\s]+))?/g;
                let namedMatch;
                while ((namedMatch = namedImportRegex.exec(namedImports)) !== null) {
                    elements.push(namedMatch[2] || namedMatch[1]);
                }
            }
            imports.push({
                source,
                elements,
                defaultImport,
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
    }
    return imports;
}
/**
 * Extract Python import declarations
 */
function extractPythonImports(content) {
    const imports = [];
    // import module
    // import module as alias
    // from module import name
    // from module import name as alias, name2
    const importRegex = /^(?:import\s+([^,\s]+)(?:\s+as\s+([^,\s]+))?|from\s+([^,\s]+)\s+import\s+(.+))$/gm;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip comments
        if (line.trim().startsWith('#')) {
            continue;
        }
        // Reset regex to search from the beginning of the line
        importRegex.lastIndex = 0;
        while ((match = importRegex.exec(line)) !== null) {
            const moduleImport = match[1];
            const moduleAlias = match[2];
            const fromModule = match[3];
            const fromImports = match[4];
            if (moduleImport) {
                // import module [as alias]
                imports.push({
                    source: moduleImport,
                    elements: [],
                    defaultImport: moduleAlias || moduleImport,
                    startPosition: {
                        line: lineCount,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineCount,
                        column: match.index + match[0].length,
                    },
                });
            }
            else if (fromModule && fromImports) {
                // from module import name [as alias], name2 [as alias2], ...
                const elements = [];
                const importRegex = /([^,\s]+)(?:\s+as\s+([^,\s]+))?/g;
                let importMatch;
                while ((importMatch = importRegex.exec(fromImports)) !== null) {
                    elements.push(importMatch[2] || importMatch[1]);
                }
                imports.push({
                    source: fromModule,
                    elements,
                    startPosition: {
                        line: lineCount,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineCount,
                        column: match.index + match[0].length,
                    },
                });
            }
        }
    }
    return imports;
}
/**
 * Extract Java import declarations
 */
function extractJavaImports(content) {
    const imports = [];
    // import package.name.Class;
    // import package.name.*;
    // import static package.name.Class.method;
    const importRegex = /^import\s+(?:static\s+)?([^;]+);/gm;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip comments
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Reset regex to search from the beginning of the line
        importRegex.lastIndex = 0;
        while ((match = importRegex.exec(line)) !== null) {
            const importPath = match[1];
            const isWildcard = importPath.endsWith('.*');
            const source = isWildcard
                ? importPath.substring(0, importPath.length - 2)
                : importPath.substring(0, importPath.lastIndexOf('.'));
            const elements = isWildcard ? [] : [importPath.substring(importPath.lastIndexOf('.') + 1)];
            imports.push({
                source,
                elements,
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
    }
    return imports;
}
/**
 * Extract C# using declarations
 */
function extractCSharpImports(content) {
    const imports = [];
    // using System;
    // using System.Collections.Generic;
    // using static System.Math;
    // using Alias = Namespace.Type;
    const usingRegex = /^using\s+(?:static\s+)?([^;=]+)(?:\s*=\s*([^;]+))?;/gm;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip comments
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Reset regex to search from the beginning of the line
        usingRegex.lastIndex = 0;
        while ((match = usingRegex.exec(line)) !== null) {
            const namespace = match[1].trim();
            const alias = match[2]?.trim();
            imports.push({
                source: alias || namespace,
                elements: [],
                namespaceImport: alias ? namespace : undefined,
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
    }
    return imports;
}
/**
 * Extract Go import declarations
 */
function extractGoImports(content) {
    const imports = [];
    // Single import: import "package"
    const singleImportRegex = /^import\s+"([^"]+)"/gm;
    // Multiple imports: import ( "package1" "package2" )
    const multipleImportRegex = /^import\s+\(([^)]+)\)/gm;
    // Named import: import alias "package"
    const namedImportRegex = /^import\s+([^\s"]+)\s+"([^"]+)"/gm;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip comments
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Single import
        singleImportRegex.lastIndex = 0;
        while ((match = singleImportRegex.exec(line)) !== null) {
            imports.push({
                source: match[1],
                elements: [],
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
        // Named import
        namedImportRegex.lastIndex = 0;
        while ((match = namedImportRegex.exec(line)) !== null) {
            imports.push({
                source: match[2],
                elements: [],
                defaultImport: match[1],
                startPosition: {
                    line: lineCount,
                    column: match.index,
                },
                endPosition: {
                    line: lineCount,
                    column: match.index + match[0].length,
                },
            });
        }
    }
    // Multiple imports
    multipleImportRegex.lastIndex = 0;
    while ((match = multipleImportRegex.exec(content)) !== null) {
        const importBlock = match[1];
        const importLines = importBlock.split('\n');
        for (const importLine of importLines) {
            const trimmedLine = importLine.trim();
            if (!trimmedLine)
                continue;
            // Named import inside block: alias "package"
            const namedMatch = trimmedLine.match(/^([^\s"]+)\s+"([^"]+)"$/);
            if (namedMatch) {
                imports.push({
                    source: namedMatch[2],
                    elements: [],
                    defaultImport: namedMatch[1],
                    startPosition: {
                        line: 0, // We don't track exact line numbers in blocks
                        column: 0,
                    },
                    endPosition: {
                        line: 0,
                        column: 0,
                    },
                });
                continue;
            }
            // Regular import inside block: "package"
            const regularMatch = trimmedLine.match(/^"([^"]+)"$/);
            if (regularMatch) {
                imports.push({
                    source: regularMatch[1],
                    elements: [],
                    startPosition: {
                        line: 0, // We don't track exact line numbers in blocks
                        column: 0,
                    },
                    endPosition: {
                        line: 0,
                        column: 0,
                    },
                });
            }
        }
    }
    return imports;
}
/**
 * Extract Rust import declarations
 */
function extractRustImports(content) {
    const imports = [];
    // use std::io;
    // use std::io::prelude::*;
    // use std::io::{self, Read, Write};
    // use std::io::prelude::Read as IoRead;
    const useRegex = /^use\s+([^;]+);/gm;
    let match;
    let lineCount = 0;
    const lines = content.split('\n');
    for (const line of lines) {
        lineCount++;
        // Skip comments
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Reset regex to search from the beginning of the line
        useRegex.lastIndex = 0;
        while ((match = useRegex.exec(line)) !== null) {
            const importPath = match[1];
            // Handle simple imports: use std::io;
            if (!importPath.includes('{') && !importPath.includes('as ')) {
                const source = importPath.includes('::*')
                    ? importPath.substring(0, importPath.lastIndexOf('::'))
                    : importPath;
                imports.push({
                    source,
                    elements: [],
                    startPosition: {
                        line: lineCount,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineCount,
                        column: match.index + match[0].length,
                    },
                });
                continue;
            }
            // Handle imports with aliases: use std::io::Read as IoRead;
            if (importPath.includes('as ') && !importPath.includes('{')) {
                const parts = importPath.split(' as ');
                const source = parts[0].includes('::')
                    ? parts[0].substring(0, parts[0].lastIndexOf('::'))
                    : parts[0];
                const element = parts[0].substring(parts[0].lastIndexOf('::') + 2);
                const alias = parts[1];
                imports.push({
                    source,
                    elements: [alias],
                    startPosition: {
                        line: lineCount,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineCount,
                        column: match.index + match[0].length,
                    },
                });
                continue;
            }
            // Handle grouped imports: use std::io::{self, Read, Write};
            if (importPath.includes('{')) {
                const basePath = importPath.substring(0, importPath.indexOf('{'));
                const source = basePath.endsWith('::')
                    ? basePath.substring(0, basePath.length - 2)
                    : basePath;
                const groupContent = importPath.substring(importPath.indexOf('{') + 1, importPath.lastIndexOf('}'));
                const elements = [];
                const groupItems = groupContent.split(',').map(item => item.trim());
                for (const item of groupItems) {
                    if (!item)
                        continue;
                    if (item === 'self') {
                        // self refers to the module itself
                        elements.push(source.substring(source.lastIndexOf('::') + 2));
                    }
                    else if (item.includes('as ')) {
                        // Handle aliases in groups
                        const aliasParts = item.split(' as ');
                        elements.push(aliasParts[1]);
                    }
                    else {
                        elements.push(item);
                    }
                }
                imports.push({
                    source,
                    elements,
                    startPosition: {
                        line: lineCount,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineCount,
                        column: match.index + match[0].length,
                    },
                });
            }
        }
    }
    return imports;
}
