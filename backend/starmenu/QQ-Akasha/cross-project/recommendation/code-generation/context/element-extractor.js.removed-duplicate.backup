/**
 * Element extractor for extracting code elements from code
 */
import { v4 as uuidv4 } from 'uuid';
import { CodeElementScope, CodeElementType, CodeElementVisibility } from './types';
import { ProgrammingLanguage } from '../templates/types';
/**
 * Extract code elements from content
 */
export function extractCodeElements(content, language, maxElements = 1000) {
    switch (language) {
        case ProgrammingLanguage.JAVASCRIPT:
        case ProgrammingLanguage.TYPESCRIPT:
            return extractJavaScriptElements(content, maxElements, language === ProgrammingLanguage.TYPESCRIPT);
        case ProgrammingLanguage.PYTHON:
            return extractPythonElements(content, maxElements);
        case ProgrammingLanguage.JAVA:
            return extractJavaElements(content, maxElements);
        case ProgrammingLanguage.CSHARP:
            return extractCSharpElements(content, maxElements);
        default:
            // For unsupported languages, return an empty array
            return [];
    }
}
/**
 * Extract JavaScript/TypeScript code elements
 */
function extractJavaScriptElements(content, maxElements, isTypeScript) {
    const elements = [];
    const lines = content.split('\n');
    // Track scope stack
    const scopeStack = [];
    // Variable declarations
    // const x = 1;
    // let y = 2;
    // var z = 3;
    const variableRegex = /(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?::\s*([a-zA-Z_$][a-zA-Z0-9_$<>[\].,|&]*))?\s*=\s*([^;]+)/g;
    // Function declarations
    // function foo() {}
    // const bar = function() {}
    // const baz = () => {}
    const functionRegex = /(?:function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)|(?:const|let|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:function|async function)|\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(?:\([^)]*\)|async\s*\([^)]*\))\s*=>)/g;
    // Class declarations
    // class Foo {}
    // class Bar extends Baz {}
    const classRegex = /class\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:extends\s+([a-zA-Z_$][a-zA-Z0-9_$]*))?/g;
    // Interface declarations (TypeScript only)
    // interface Foo {}
    // interface Bar extends Baz {}
    const interfaceRegex = /interface\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:extends\s+([a-zA-Z_$][a-zA-Z0-9_$]*))?/g;
    // Type declarations (TypeScript only)
    // type Foo = string;
    // type Bar<T> = T[];
    const typeRegex = /type\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?:<[^>]+>)?\s*=/g;
    // Enum declarations (TypeScript only)
    // enum Foo {}
    const enumRegex = /enum\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;
    // Method declarations
    // foo() {}
    // async bar() {}
    // get baz() {}
    // set qux(value) {}
    const methodRegex = /(?:async\s+)?(?:get|set)?\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\([^)]*\)\s*{/g;
    // Property declarations
    // this.foo = 1;
    // this._bar = 2;
    const propertyRegex = /this\.([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=/g;
    let lineNumber = 0;
    for (const line of lines) {
        lineNumber++;
        // Skip if we've reached the maximum number of elements
        if (elements.length >= maxElements) {
            break;
        }
        // Skip comments
        if (line.trim().startsWith('//') ||
            line.trim().startsWith('/*') ||
            line.trim().startsWith('*')) {
            continue;
        }
        // Reset regex to search from the beginning of the line
        variableRegex.lastIndex = 0;
        functionRegex.lastIndex = 0;
        classRegex.lastIndex = 0;
        methodRegex.lastIndex = 0;
        propertyRegex.lastIndex = 0;
        if (isTypeScript) {
            interfaceRegex.lastIndex = 0;
            typeRegex.lastIndex = 0;
            enumRegex.lastIndex = 0;
        }
        // Extract variables
        let match;
        while ((match = variableRegex.exec(line)) !== null) {
            const name = match[1];
            const dataType = match[2];
            const value = match[3].trim();
            // Determine if it's a constant
            const isConstant = line.trim().startsWith('const') &&
                !value.startsWith('function') &&
                !value.startsWith('class') &&
                !value.includes('=>');
            // Create element
            const element = {
                id: uuidv4(),
                type: isConstant ? CodeElementType.VARIABLE : CodeElementType.VARIABLE,
                name,
                value,
                dataType,
                scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                startPosition: {
                    line: lineNumber,
                    column: match.index,
                },
                endPosition: {
                    line: lineNumber,
                    column: match.index + match[0].length,
                },
            };
            // Set parent ID if in a scope
            if (scopeStack.length > 0) {
                element.parentId = scopeStack[scopeStack.length - 1].id;
            }
            elements.push(element);
        }
        // Extract functions
        while ((match = functionRegex.exec(line)) !== null) {
            const name = match[1] || match[2] || match[3];
            // Skip if name is undefined
            if (!name)
                continue;
            // Create element
            const element = {
                id: uuidv4(),
                type: CodeElementType.FUNCTION,
                name,
                scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                startPosition: {
                    line: lineNumber,
                    column: match.index,
                },
                endPosition: {
                    line: lineNumber,
                    column: match.index + match[0].length,
                },
            };
            // Set parent ID if in a scope
            if (scopeStack.length > 0) {
                element.parentId = scopeStack[scopeStack.length - 1].id;
            }
            elements.push(element);
            // Add to scope stack if the line contains an opening brace
            if (line.includes('{')) {
                scopeStack.push(element);
            }
        }
        // Extract classes
        while ((match = classRegex.exec(line)) !== null) {
            const name = match[1];
            // Create element
            const element = {
                id: uuidv4(),
                type: CodeElementType.CLASS,
                name,
                scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                startPosition: {
                    line: lineNumber,
                    column: match.index,
                },
                endPosition: {
                    line: lineNumber,
                    column: match.index + match[0].length,
                },
            };
            // Set parent ID if in a scope
            if (scopeStack.length > 0) {
                element.parentId = scopeStack[scopeStack.length - 1].id;
            }
            elements.push(element);
            // Add to scope stack if the line contains an opening brace
            if (line.includes('{')) {
                scopeStack.push(element);
            }
        }
        // TypeScript-specific elements
        if (isTypeScript) {
            // Extract interfaces
            while ((match = interfaceRegex.exec(line)) !== null) {
                const name = match[1];
                // Create element
                const element = {
                    id: uuidv4(),
                    type: CodeElementType.INTERFACE,
                    name,
                    scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                    startPosition: {
                        line: lineNumber,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineNumber,
                        column: match.index + match[0].length,
                    },
                };
                // Set parent ID if in a scope
                if (scopeStack.length > 0) {
                    element.parentId = scopeStack[scopeStack.length - 1].id;
                }
                elements.push(element);
                // Add to scope stack if the line contains an opening brace
                if (line.includes('{')) {
                    scopeStack.push(element);
                }
            }
            // Extract types
            while ((match = typeRegex.exec(line)) !== null) {
                const name = match[1];
                // Create element
                const element = {
                    id: uuidv4(),
                    type: CodeElementType.TYPE,
                    name,
                    scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                    startPosition: {
                        line: lineNumber,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineNumber,
                        column: match.index + match[0].length,
                    },
                };
                // Set parent ID if in a scope
                if (scopeStack.length > 0) {
                    element.parentId = scopeStack[scopeStack.length - 1].id;
                }
                elements.push(element);
            }
            // Extract enums
            while ((match = enumRegex.exec(line)) !== null) {
                const name = match[1];
                // Create element
                const element = {
                    id: uuidv4(),
                    type: CodeElementType.ENUM,
                    name,
                    scope: scopeStack.length > 0 ? CodeElementScope.LOCAL : CodeElementScope.GLOBAL,
                    startPosition: {
                        line: lineNumber,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineNumber,
                        column: match.index + match[0].length,
                    },
                };
                // Set parent ID if in a scope
                if (scopeStack.length > 0) {
                    element.parentId = scopeStack[scopeStack.length - 1].id;
                }
                elements.push(element);
                // Add to scope stack if the line contains an opening brace
                if (line.includes('{')) {
                    scopeStack.push(element);
                }
            }
        }
        // Extract methods (only if we're inside a class)
        if (scopeStack.length > 0 && scopeStack[scopeStack.length - 1].type === CodeElementType.CLASS) {
            while ((match = methodRegex.exec(line)) !== null) {
                const name = match[1];
                // Skip constructor
                if (name === 'constructor')
                    continue;
                // Determine visibility
                let visibility = CodeElementVisibility.PUBLIC;
                if (name.startsWith('_')) {
                    visibility = CodeElementVisibility.PRIVATE;
                }
                else if (name.startsWith('#')) {
                    visibility = CodeElementVisibility.PRIVATE;
                }
                // Create element
                const element = {
                    id: uuidv4(),
                    type: CodeElementType.METHOD,
                    name,
                    scope: CodeElementScope.CLASS,
                    visibility,
                    startPosition: {
                        line: lineNumber,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineNumber,
                        column: match.index + match[0].length,
                    },
                    parentId: scopeStack[scopeStack.length - 1].id,
                };
                elements.push(element);
                // Add to scope stack if the line contains an opening brace
                if (line.includes('{')) {
                    scopeStack.push(element);
                }
            }
        }
        // Extract properties (only if we're inside a method in a class)
        if (scopeStack.length > 1 &&
            scopeStack[scopeStack.length - 2].type === CodeElementType.CLASS &&
            (scopeStack[scopeStack.length - 1].type === CodeElementType.METHOD ||
                scopeStack[scopeStack.length - 1].type === CodeElementType.FUNCTION)) {
            while ((match = propertyRegex.exec(line)) !== null) {
                const name = match[1];
                // Determine visibility
                let visibility = CodeElementVisibility.PUBLIC;
                if (name.startsWith('_')) {
                    visibility = CodeElementVisibility.PRIVATE;
                }
                else if (name.startsWith('#')) {
                    visibility = CodeElementVisibility.PRIVATE;
                }
                // Create element
                const element = {
                    id: uuidv4(),
                    type: CodeElementType.PROPERTY,
                    name,
                    scope: CodeElementScope.CLASS,
                    visibility,
                    startPosition: {
                        line: lineNumber,
                        column: match.index,
                    },
                    endPosition: {
                        line: lineNumber,
                        column: match.index + match[0].length,
                    },
                    parentId: scopeStack[scopeStack.length - 2].id,
                };
                elements.push(element);
            }
        }
        // Update scope stack based on braces
        const openBraces = (line.match(/{/g) || []).length;
        const closeBraces = (line.match(/}/g) || []).length;
        // Pop from scope stack for each closing brace
        for (let i = 0; i < closeBraces; i++) {
            if (scopeStack.length > 0) {
                scopeStack.pop();
            }
        }
    }
    return elements;
}
/**
 * Extract Python code elements
 */
function extractPythonElements(content, maxElements) {
    // Placeholder implementation
    return [];
}
/**
 * Extract Java code elements
 */
function extractJavaElements(content, maxElements) {
    // Placeholder implementation
    return [];
}
/**
 * Extract C# code elements
 */
function extractCSharpElements(content, maxElements) {
    // Placeholder implementation
    return [];
}
