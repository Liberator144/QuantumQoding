/**
 * Context extractor for extracting context from code files
 */
import { ProgrammingLanguage } from '../templates/types';
import { detectLanguage } from './language-detector';
import { extractImports } from './import-extractor';
import { detectCodeStyle } from './style-detector';
import { detectNamingConventions } from './naming-detector';
import { extractCodeElements } from './element-extractor';
import { findElementsInScope } from './scope-analyzer';
/**
 * Default context extraction options
 */
export const DEFAULT_EXTRACTION_OPTIONS = {
    extractImports: true,
    extractElements: true,
    detectStyle: true,
    detectNaming: true,
    analyzeScope: true,
    extractProjectContext: false,
    maxElements: 1000,
};
/**
 * Extract context from a file
 */
export async function extractContext(filePath, content, cursorPosition, selection, options = DEFAULT_EXTRACTION_OPTIONS) {
    const errors = [];
    const warnings = [];
    // Merge options with defaults
    const mergedOptions = {
        ...DEFAULT_EXTRACTION_OPTIONS,
        ...options,
    };
    try {
        // Detect language
        const language = detectLanguage(filePath, content);
        // Initialize file context
        const fileContext = {
            filePath,
            content,
            language,
            elements: [],
            imports: [],
            style: {
                indentationType: 'space',
                indentationSize: 2,
                lineEnding: 'lf',
            },
            namingConventions: {
                variables: 'camelCase',
                functions: 'camelCase',
                classes: 'PascalCase',
                interfaces: 'PascalCase',
                enums: 'PascalCase',
                constants: 'UPPER_CASE',
                privateMembers: 'camelCase',
            },
            cursorPosition,
            selection,
        };
        // Extract imports
        if (mergedOptions.extractImports) {
            try {
                fileContext.imports = extractImports(content, language);
            }
            catch (error) {
                warnings.push(`Failed to extract imports: ${error}`);
            }
        }
        // Extract code elements
        if (mergedOptions.extractElements) {
            try {
                fileContext.elements = extractCodeElements(content, language, mergedOptions.maxElements);
            }
            catch (error) {
                warnings.push(`Failed to extract code elements: ${error}`);
            }
        }
        // Detect code style
        if (mergedOptions.detectStyle) {
            try {
                fileContext.style = detectCodeStyle(content);
            }
            catch (error) {
                warnings.push(`Failed to detect code style: ${error}`);
            }
        }
        // Detect naming conventions
        if (mergedOptions.detectNaming) {
            try {
                fileContext.namingConventions = detectNamingConventions(fileContext.elements);
            }
            catch (error) {
                warnings.push(`Failed to detect naming conventions: ${error}`);
            }
        }
        // Analyze scope
        if (mergedOptions.analyzeScope && cursorPosition) {
            try {
                const scopeAnalysis = findElementsInScope(fileContext.elements, cursorPosition);
                fileContext.currentScope = scopeAnalysis.currentScope;
                fileContext.variablesInScope = scopeAnalysis.variables;
                fileContext.functionsInScope = scopeAnalysis.functions;
                fileContext.classesInScope = scopeAnalysis.classes;
                fileContext.interfacesInScope = scopeAnalysis.interfaces;
                fileContext.typesInScope = scopeAnalysis.types;
            }
            catch (error) {
                warnings.push(`Failed to analyze scope: ${error}`);
            }
        }
        // Extract project context
        let projectContext;
        if (mergedOptions.extractProjectContext) {
            try {
                projectContext = await extractProjectContext(filePath);
            }
            catch (error) {
                warnings.push(`Failed to extract project context: ${error}`);
            }
        }
        return {
            fileContext,
            projectContext,
            errors,
            warnings,
        };
    }
    catch (error) {
        errors.push(`Failed to extract context: ${error}`);
        // Return minimal context
        return {
            fileContext: {
                filePath,
                content,
                language: ProgrammingLanguage.JAVASCRIPT, // Default to JavaScript
                elements: [],
                imports: [],
                style: {
                    indentationType: 'space',
                    indentationSize: 2,
                    lineEnding: 'lf',
                },
                namingConventions: {
                    variables: 'camelCase',
                    functions: 'camelCase',
                    classes: 'PascalCase',
                    interfaces: 'PascalCase',
                    enums: 'PascalCase',
                    constants: 'UPPER_CASE',
                    privateMembers: 'camelCase',
                },
            },
            errors,
            warnings,
        };
    }
}
/**
 * Extract project context
 */
async function extractProjectContext(filePath) {
    // This is a placeholder implementation
    // In a real implementation, this would analyze project files, package.json, etc.
    return {
        rootPath: filePath.split('/').slice(0, -1).join('/'),
        name: 'unknown-project',
        type: 'other',
        dependencies: {},
        devDependencies: {},
        scripts: {},
        configFiles: [],
        sourceFiles: [],
        testFiles: [],
        documentationFiles: [],
        structure: {},
    };
}
