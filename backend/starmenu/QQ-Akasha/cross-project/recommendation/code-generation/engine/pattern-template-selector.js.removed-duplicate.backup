/**
 * Pattern-based template selector for selecting templates based on detected patterns
 */
import { TemplateCategory, } from '../templates/types';
import { DesignPatternType } from '../patterns/types';
import { detectPatterns } from '../patterns/pattern-detector';
import { DEFAULT_TEMPLATE_SELECTION_OPTIONS, } from './types';
/**
 * Default pattern-based template selection options
 */
export const DEFAULT_PATTERN_TEMPLATE_SELECTION_OPTIONS = {
    ...DEFAULT_TEMPLATE_SELECTION_OPTIONS,
    prioritizePatternTemplates: true,
    minPatternConfidence: 0.6,
    maxPatterns: 3,
};
/**
 * Select templates based on detected patterns
 */
export function selectTemplatesBasedOnPatterns(repository, fileContext, options = {}) {
    // Merge options with defaults
    const mergedOptions = {
        ...DEFAULT_PATTERN_TEMPLATE_SELECTION_OPTIONS,
        ...options,
    };
    // Detect patterns in the file
    const detectedPatterns = detectPatterns(fileContext);
    // Filter patterns by confidence threshold
    const filteredPatterns = detectedPatterns.filter(pattern => pattern.confidence >= mergedOptions.minPatternConfidence);
    // Limit number of patterns
    const limitedPatterns = filteredPatterns.slice(0, mergedOptions.maxPatterns);
    // If no patterns detected, return empty result
    if (limitedPatterns.length === 0) {
        return {
            templates: [],
            matchingCriteria: {},
            errors: [],
            warnings: [`No patterns detected with confidence >= ${mergedOptions.minPatternConfidence}`],
        };
    }
    // Build query options based on detected patterns
    const queryOptions = buildQueryOptionsFromPatterns(limitedPatterns, fileContext);
    // Query templates from repository
    const queryResult = repository.queryTemplates(queryOptions);
    // If no templates found, return empty result
    if (queryResult.templates.length === 0) {
        return {
            templates: [],
            matchingCriteria: queryOptions,
            errors: [],
            warnings: ['No templates found matching detected patterns'],
        };
    }
    // Calculate relevance scores for templates
    const templatesWithScores = queryResult.templates.map(template => ({
        template,
        score: calculatePatternTemplateRelevance(template, limitedPatterns, fileContext),
    }));
    // Sort templates by relevance score (highest first)
    templatesWithScores.sort((a, b) => b.score - a.score);
    // Extract templates from sorted list
    const sortedTemplates = templatesWithScores.map(item => item.template);
    return {
        templates: sortedTemplates,
        matchingCriteria: queryOptions,
        errors: queryResult.errors,
        warnings: queryResult.warnings,
    };
}
/**
 * Build query options from detected patterns
 */
function buildQueryOptionsFromPatterns(patterns, fileContext) {
    const queryOptions = {
        language: fileContext.language,
        tags: [],
    };
    // Add pattern types as tags
    for (const pattern of patterns) {
        queryOptions.tags.push(pattern.pattern);
    }
    // Add category based on patterns
    if (patterns.some(p => p.pattern === DesignPatternType.SINGLETON ||
        p.pattern === DesignPatternType.FACTORY ||
        p.pattern === DesignPatternType.ABSTRACT_FACTORY ||
        p.pattern === DesignPatternType.BUILDER ||
        p.pattern === DesignPatternType.PROTOTYPE)) {
        queryOptions.category = TemplateCategory.CREATIONAL;
    }
    else if (patterns.some(p => p.pattern === DesignPatternType.ADAPTER ||
        p.pattern === DesignPatternType.BRIDGE ||
        p.pattern === DesignPatternType.COMPOSITE ||
        p.pattern === DesignPatternType.DECORATOR ||
        p.pattern === DesignPatternType.FACADE ||
        p.pattern === DesignPatternType.FLYWEIGHT ||
        p.pattern === DesignPatternType.PROXY)) {
        queryOptions.category = TemplateCategory.STRUCTURAL;
    }
    else if (patterns.some(p => p.pattern === DesignPatternType.CHAIN_OF_RESPONSIBILITY ||
        p.pattern === DesignPatternType.COMMAND ||
        p.pattern === DesignPatternType.INTERPRETER ||
        p.pattern === DesignPatternType.ITERATOR ||
        p.pattern === DesignPatternType.MEDIATOR ||
        p.pattern === DesignPatternType.MEMENTO ||
        p.pattern === DesignPatternType.OBSERVER ||
        p.pattern === DesignPatternType.STATE ||
        p.pattern === DesignPatternType.STRATEGY ||
        p.pattern === DesignPatternType.TEMPLATE_METHOD ||
        p.pattern === DesignPatternType.VISITOR)) {
        queryOptions.category = TemplateCategory.BEHAVIORAL;
    }
    return queryOptions;
}
/**
 * Calculate relevance score for a template based on detected patterns
 */
function calculatePatternTemplateRelevance(template, patterns, fileContext) {
    let score = 0;
    // Check if template tags match detected patterns
    for (const pattern of patterns) {
        if (template.tags.includes(pattern.pattern)) {
            // Add pattern confidence to score
            score += pattern.confidence;
        }
    }
    // Check if template category matches detected patterns
    if (template.category === TemplateCategory.CREATIONAL &&
        patterns.some(p => p.pattern === DesignPatternType.SINGLETON ||
            p.pattern === DesignPatternType.FACTORY ||
            p.pattern === DesignPatternType.ABSTRACT_FACTORY ||
            p.pattern === DesignPatternType.BUILDER ||
            p.pattern === DesignPatternType.PROTOTYPE)) {
        score += 0.5;
    }
    else if (template.category === TemplateCategory.STRUCTURAL &&
        patterns.some(p => p.pattern === DesignPatternType.ADAPTER ||
            p.pattern === DesignPatternType.BRIDGE ||
            p.pattern === DesignPatternType.COMPOSITE ||
            p.pattern === DesignPatternType.DECORATOR ||
            p.pattern === DesignPatternType.FACADE ||
            p.pattern === DesignPatternType.FLYWEIGHT ||
            p.pattern === DesignPatternType.PROXY)) {
        score += 0.5;
    }
    else if (template.category === TemplateCategory.BEHAVIORAL &&
        patterns.some(p => p.pattern === DesignPatternType.CHAIN_OF_RESPONSIBILITY ||
            p.pattern === DesignPatternType.COMMAND ||
            p.pattern === DesignPatternType.INTERPRETER ||
            p.pattern === DesignPatternType.ITERATOR ||
            p.pattern === DesignPatternType.MEDIATOR ||
            p.pattern === DesignPatternType.MEMENTO ||
            p.pattern === DesignPatternType.OBSERVER ||
            p.pattern === DesignPatternType.STATE ||
            p.pattern === DesignPatternType.STRATEGY ||
            p.pattern === DesignPatternType.TEMPLATE_METHOD ||
            p.pattern === DesignPatternType.VISITOR)) {
        score += 0.5;
    }
    // Check if template language matches file language
    if (template.language === fileContext.language) {
        score += 0.5;
    }
    return score;
}
