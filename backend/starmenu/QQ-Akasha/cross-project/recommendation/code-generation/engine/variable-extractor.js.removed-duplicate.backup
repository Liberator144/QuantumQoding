/**
 * Variable extractor for extracting variable values from context
 */
import { CodeElementType, } from '../context/types';
import { VariableType } from '../templates/types';
/**
 * Extract variable values from context
 */
export function extractVariableValues(template, context) {
    const variableValues = [];
    // Extract values for each template variable
    for (const variable of template.variables) {
        const value = extractVariableValue(variable, context);
        if (value) {
            variableValues.push(value);
        }
    }
    return variableValues;
}
/**
 * Extract a variable value from context
 */
function extractVariableValue(variable, context) {
    const { fileContext } = context;
    // Try different extraction strategies based on variable type
    switch (variable.type) {
        case VariableType.IDENTIFIER:
            return extractIdentifier(variable, fileContext);
        case VariableType.TYPE:
            return extractType(variable, fileContext);
        case VariableType.IMPORT:
            return extractImport(variable, fileContext);
        case VariableType.STRING:
        case VariableType.NUMBER:
        case VariableType.BOOLEAN:
            return extractPrimitive(variable, fileContext);
        case VariableType.EXPRESSION:
        case VariableType.STATEMENT:
        case VariableType.BLOCK:
            return extractCode(variable, fileContext);
        case VariableType.PARAMETER:
        case VariableType.ARGUMENT:
            return extractParameter(variable, fileContext);
        case VariableType.PROPERTY:
        case VariableType.METHOD:
            return extractMember(variable, fileContext);
        case VariableType.CLASS:
        case VariableType.INTERFACE:
        case VariableType.ENUM:
        case VariableType.FUNCTION:
        case VariableType.VARIABLE:
            return extractDeclaration(variable, fileContext);
        case VariableType.CUSTOM:
            return extractCustom(variable, fileContext);
        default:
            // Use default value if available
            if (variable.defaultValue !== undefined) {
                return {
                    name: variable.name,
                    value: variable.defaultValue,
                    source: 'default',
                };
            }
            return undefined;
    }
}
/**
 * Extract an identifier from context
 */
function extractIdentifier(variable, fileContext) {
    // Try to find a suitable identifier from the context
    // Check if there's a current scope
    if (fileContext.currentScope) {
        // Use the current scope name with a suffix
        const scopeName = fileContext.currentScope.name;
        // Generate a name based on the variable description
        const nameParts = variable.description.toLowerCase().split(' ');
        const nameWords = nameParts.filter(part => part.length > 2 && !['the', 'and', 'for', 'with', 'that', 'this'].includes(part));
        if (nameWords.length > 0) {
            // Use the first word as the base name
            const baseName = nameWords[0];
            // Format according to naming convention
            const namingConvention = fileContext.namingConventions.variables;
            switch (namingConvention) {
                case 'camelCase':
                    return {
                        name: variable.name,
                        value: baseName,
                        source: 'context',
                    };
                case 'snake_case':
                    return {
                        name: variable.name,
                        value: baseName.replace(/([A-Z])/g, '_$1').toLowerCase(),
                        source: 'context',
                    };
                case 'PascalCase':
                    return {
                        name: variable.name,
                        value: baseName.charAt(0).toUpperCase() + baseName.slice(1),
                        source: 'context',
                    };
                case 'UPPER_CASE':
                    return {
                        name: variable.name,
                        value: baseName.toUpperCase(),
                        source: 'context',
                    };
                default:
                    return {
                        name: variable.name,
                        value: baseName,
                        source: 'context',
                    };
            }
        }
    }
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    return undefined;
}
/**
 * Extract a type from context
 */
function extractType(variable, fileContext) {
    // Try to find a suitable type from the context
    // Check if there are types in scope
    if (fileContext.typesInScope && fileContext.typesInScope.length > 0) {
        // Use the first type in scope
        const type = fileContext.typesInScope[0];
        return {
            name: variable.name,
            value: type.name,
            source: 'context',
        };
    }
    // Check if there are interfaces in scope
    if (fileContext.interfacesInScope && fileContext.interfacesInScope.length > 0) {
        // Use the first interface in scope
        const iface = fileContext.interfacesInScope[0];
        return {
            name: variable.name,
            value: iface.name,
            source: 'context',
        };
    }
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Use a generic type based on the language
    switch (fileContext.language) {
        case 'typescript':
            return {
                name: variable.name,
                value: 'any',
                source: 'derived',
            };
        case 'java':
        case 'csharp':
            return {
                name: variable.name,
                value: 'Object',
                source: 'derived',
            };
        default:
            return undefined;
    }
}
/**
 * Extract an import from context
 */
function extractImport(variable, fileContext) {
    // Try to find a suitable import from the context
    // Check if there are imports
    if (fileContext.imports && fileContext.imports.length > 0) {
        // Use the first import
        const importDecl = fileContext.imports[0];
        return {
            name: variable.name,
            value: importDecl.source,
            source: 'context',
        };
    }
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    return undefined;
}
/**
 * Extract a primitive value from context
 */
function extractPrimitive(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Generate a value based on the variable type
    switch (variable.type) {
        case VariableType.STRING:
            return {
                name: variable.name,
                value: `"${variable.name}"`,
                source: 'derived',
            };
        case VariableType.NUMBER:
            return {
                name: variable.name,
                value: '0',
                source: 'derived',
            };
        case VariableType.BOOLEAN:
            return {
                name: variable.name,
                value: 'false',
                source: 'derived',
            };
        default:
            return undefined;
    }
}
/**
 * Extract code from context
 */
function extractCode(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Generate a value based on the variable type
    switch (variable.type) {
        case VariableType.EXPRESSION:
            return {
                name: variable.name,
                value: 'true',
                source: 'derived',
            };
        case VariableType.STATEMENT:
            return {
                name: variable.name,
                value: 'console.log("Hello, world!");',
                source: 'derived',
            };
        case VariableType.BLOCK:
            return {
                name: variable.name,
                value: '{\n  console.log("Hello, world!");\n}',
                source: 'derived',
            };
        default:
            return undefined;
    }
}
/**
 * Extract a parameter from context
 */
function extractParameter(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Generate a parameter based on the naming convention
    const namingConvention = fileContext.namingConventions.variables;
    switch (namingConvention) {
        case 'camelCase':
            return {
                name: variable.name,
                value: 'param',
                source: 'derived',
            };
        case 'snake_case':
            return {
                name: variable.name,
                value: 'param_name',
                source: 'derived',
            };
        case 'PascalCase':
            return {
                name: variable.name,
                value: 'ParamName',
                source: 'derived',
            };
        case 'UPPER_CASE':
            return {
                name: variable.name,
                value: 'PARAM_NAME',
                source: 'derived',
            };
        default:
            return {
                name: variable.name,
                value: 'param',
                source: 'derived',
            };
    }
}
/**
 * Extract a member from context
 */
function extractMember(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Generate a member based on the naming convention
    const namingConvention = variable.type === VariableType.METHOD
        ? fileContext.namingConventions.functions
        : fileContext.namingConventions.variables;
    switch (namingConvention) {
        case 'camelCase':
            return {
                name: variable.name,
                value: variable.type === VariableType.METHOD ? 'doSomething' : 'memberName',
                source: 'derived',
            };
        case 'snake_case':
            return {
                name: variable.name,
                value: variable.type === VariableType.METHOD ? 'do_something' : 'member_name',
                source: 'derived',
            };
        case 'PascalCase':
            return {
                name: variable.name,
                value: variable.type === VariableType.METHOD ? 'DoSomething' : 'MemberName',
                source: 'derived',
            };
        case 'UPPER_CASE':
            return {
                name: variable.name,
                value: variable.type === VariableType.METHOD ? 'DO_SOMETHING' : 'MEMBER_NAME',
                source: 'derived',
            };
        default:
            return {
                name: variable.name,
                value: variable.type === VariableType.METHOD ? 'doSomething' : 'memberName',
                source: 'derived',
            };
    }
}
/**
 * Extract a declaration from context
 */
function extractDeclaration(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Generate a declaration based on the variable type and naming convention
    let namingConvention;
    let defaultName;
    switch (variable.type) {
        case VariableType.CLASS:
            namingConvention = fileContext.namingConventions.classes;
            defaultName = 'MyClass';
            break;
        case VariableType.INTERFACE:
            namingConvention = fileContext.namingConventions.interfaces;
            defaultName = 'MyInterface';
            break;
        case VariableType.ENUM:
            namingConvention = fileContext.namingConventions.enums;
            defaultName = 'MyEnum';
            break;
        case VariableType.FUNCTION:
            namingConvention = fileContext.namingConventions.functions;
            defaultName = 'myFunction';
            break;
        case VariableType.VARIABLE:
            namingConvention = fileContext.namingConventions.variables;
            defaultName = 'myVariable';
            break;
        default:
            namingConvention = 'camelCase';
            defaultName = 'myName';
    }
    switch (namingConvention) {
        case 'camelCase':
            return {
                name: variable.name,
                value: defaultName.charAt(0).toLowerCase() + defaultName.slice(1),
                source: 'derived',
            };
        case 'snake_case':
            return {
                name: variable.name,
                value: defaultName.replace(/([A-Z])/g, '_$1').toLowerCase(),
                source: 'derived',
            };
        case 'PascalCase':
            return {
                name: variable.name,
                value: defaultName.charAt(0).toUpperCase() + defaultName.slice(1),
                source: 'derived',
            };
        case 'UPPER_CASE':
            return {
                name: variable.name,
                value: defaultName.toUpperCase(),
                source: 'derived',
            };
        default:
            return {
                name: variable.name,
                value: defaultName,
                source: 'derived',
            };
    }
}
/**
 * Extract a custom variable from context
 */
function extractCustom(variable, fileContext) {
    // Use default value if available
    if (variable.defaultValue !== undefined) {
        return {
            name: variable.name,
            value: variable.defaultValue,
            source: 'default',
        };
    }
    // Use a custom extraction strategy based on the variable name
    // Extract file name
    if (variable.name.includes('fileName') || variable.name.includes('file_name')) {
        const fileName = fileContext.filePath.split('/').pop() || '';
        const baseName = fileName.split('.')[0];
        return {
            name: variable.name,
            value: baseName,
            source: 'context',
        };
    }
    // Extract class name
    if (variable.name.includes('className') || variable.name.includes('class_name')) {
        // Try to find a class in the file
        const classElement = fileContext.elements.find(e => e.type === CodeElementType.CLASS);
        if (classElement) {
            return {
                name: variable.name,
                value: classElement.name,
                source: 'context',
            };
        }
        // Generate a class name from the file name
        const fileName = fileContext.filePath.split('/').pop() || '';
        const baseName = fileName.split('.')[0];
        // Convert to PascalCase
        const className = baseName
            .replace(/[^a-zA-Z0-9]/g, ' ')
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join('');
        return {
            name: variable.name,
            value: className,
            source: 'derived',
        };
    }
    // Extract function name
    if (variable.name.includes('functionName') || variable.name.includes('function_name')) {
        // Try to find a function in the file
        const functionElement = fileContext.elements.find(e => e.type === CodeElementType.FUNCTION || e.type === CodeElementType.METHOD);
        if (functionElement) {
            return {
                name: variable.name,
                value: functionElement.name,
                source: 'context',
            };
        }
        // Generate a function name from the file name
        const fileName = fileContext.filePath.split('/').pop() || '';
        const baseName = fileName.split('.')[0];
        // Convert to camelCase
        const functionName = baseName
            .replace(/[^a-zA-Z0-9]/g, ' ')
            .split(' ')
            .map((word, index) => index === 0
            ? word.charAt(0).toLowerCase() + word.slice(1)
            : word.charAt(0).toUpperCase() + word.slice(1))
            .join('');
        return {
            name: variable.name,
            value: functionName,
            source: 'derived',
        };
    }
    return undefined;
}
