/**
 * Template validator for validating code templates
 */
import { VariableType } from './types';
/**
 * Validate a template
 */
export function validateTemplate(template) {
    const errors = [];
    const warnings = [];
    // Validate required fields
    if (!template.id) {
        errors.push('Template ID is required');
    }
    else if (!/^[a-z0-9-_]+$/i.test(template.id)) {
        errors.push('Template ID must contain only letters, numbers, hyphens, and underscores');
    }
    if (!template.name) {
        errors.push('Template name is required');
    }
    if (!template.description) {
        warnings.push('Template description is missing');
    }
    if (!template.language) {
        errors.push('Template language is required');
    }
    if (!template.category) {
        errors.push('Template category is required');
    }
    if (!template.content) {
        errors.push('Template content is required');
    }
    if (!template.variables || !Array.isArray(template.variables)) {
        errors.push('Template variables must be an array');
    }
    if (!template.tags || !Array.isArray(template.tags)) {
        warnings.push('Template tags should be an array');
    }
    if (!template.version) {
        warnings.push('Template version is missing');
    }
    // Validate variables
    if (template.variables && Array.isArray(template.variables)) {
        // Check for duplicate variable names
        const variableNames = new Set();
        for (const variable of template.variables) {
            if (variableNames.has(variable.name)) {
                errors.push(`Duplicate variable name: ${variable.name}`);
            }
            else {
                variableNames.add(variable.name);
            }
        }
        // Validate each variable
        for (const variable of template.variables) {
            const variableErrors = validateVariable(variable);
            errors.push(...variableErrors);
        }
        // Check if all variables in content are defined
        const variablesInContent = extractVariablesFromContent(template.content);
        for (const variableName of variablesInContent) {
            if (!template.variables.some(v => v.name === variableName)) {
                errors.push(`Variable ${variableName} is used in content but not defined`);
            }
        }
        // Check if all defined variables are used in content
        for (const variable of template.variables) {
            if (!variablesInContent.includes(variable.name)) {
                warnings.push(`Variable ${variable.name} is defined but not used in content`);
            }
        }
    }
    // Validate content syntax based on language
    // This would be more complex in a real implementation
    return {
        valid: errors.length === 0,
        errors,
        warnings,
    };
}
/**
 * Validate a template variable
 */
function validateVariable(variable) {
    const errors = [];
    // Validate required fields
    if (!variable.name) {
        errors.push('Variable name is required');
    }
    else if (!/^[a-zA-Z0-9_]+$/.test(variable.name)) {
        errors.push(`Variable name ${variable.name} must contain only letters, numbers, and underscores`);
    }
    if (!variable.type) {
        errors.push(`Variable ${variable.name} type is required`);
    }
    else if (!Object.values(VariableType).includes(variable.type)) {
        errors.push(`Variable ${variable.name} has invalid type: ${variable.type}`);
    }
    if (!variable.description) {
        errors.push(`Variable ${variable.name} description is required`);
    }
    // Validate validation pattern if provided
    if (variable.validationPattern) {
        try {
            new RegExp(variable.validationPattern);
        }
        catch (error) {
            errors.push(`Variable ${variable.name} has invalid validation pattern: ${error}`);
        }
    }
    // Validate default value against validation pattern
    if (variable.defaultValue && variable.validationPattern) {
        try {
            const regex = new RegExp(variable.validationPattern);
            if (!regex.test(variable.defaultValue)) {
                errors.push(`Variable ${variable.name} default value does not match validation pattern`);
            }
        }
        catch (error) {
            // Error already reported above
        }
    }
    // Validate possible values
    if (variable.possibleValues) {
        if (!Array.isArray(variable.possibleValues)) {
            errors.push(`Variable ${variable.name} possible values must be an array`);
        }
        else if (variable.possibleValues.length === 0) {
            errors.push(`Variable ${variable.name} possible values array is empty`);
        }
        else if (variable.defaultValue && !variable.possibleValues.includes(variable.defaultValue)) {
            errors.push(`Variable ${variable.name} default value is not in possible values`);
        }
    }
    return errors;
}
/**
 * Extract variables from template content
 */
export function extractVariablesFromContent(content) {
    // This is a simple implementation that looks for ${variableName} patterns
    // A real implementation would be more sophisticated and language-specific
    const variableRegex = /\${([a-zA-Z0-9_]+)}/g;
    const variables = [];
    let match;
    while ((match = variableRegex.exec(content)) !== null) {
        variables.push(match[1]);
    }
    // Remove duplicates
    return [...new Set(variables)];
}
