/**
 * Personalization Manager
 * Central manager for personalization features
 */
import { EventEmitter } from 'events';
import { DEFAULT_PERSONALIZATION_CONFIG, PreferenceCategory, } from './types';
import { InMemoryProfileStorage } from './profile-storage';
import { InteractionTracker } from './interaction-tracker';
import { PreferenceLearner } from './preference-learner';
/**
 * Events emitted by the personalization manager
 */
export var PersonalizationEvent;
(function (PersonalizationEvent) {
    PersonalizationEvent["PROFILE_CREATED"] = "profile-created";
    PersonalizationEvent["PROFILE_UPDATED"] = "profile-updated";
    PersonalizationEvent["PREFERENCE_CHANGED"] = "preference-changed";
    PersonalizationEvent["INTERACTION_RECORDED"] = "interaction-recorded";
})(PersonalizationEvent || (PersonalizationEvent = {}));
/**
 * Central manager for personalization features
 */
export class PersonalizationManager {
    constructor(storage, config = {}) {
        this.currentUser = null;
        this.storage = storage || new InMemoryProfileStorage();
        this.config = {
            ...DEFAULT_PERSONALIZATION_CONFIG,
            ...config,
        };
        this.eventEmitter = new EventEmitter();
        // Initialize components
        this.tracker = new InteractionTracker(this.storage);
        this.learner = new PreferenceLearner(this.storage, this.tracker, this.config);
        // Set up event listeners
        this.setupEventListeners();
    }
    /**
     * Set the current user
     */
    setCurrentUser(userId) {
        this.currentUser = userId;
    }
    /**
     * Get the current user
     */
    getCurrentUser() {
        return this.currentUser;
    }
    /**
     * Create a new user profile
     */
    async createUserProfile(name, metadata = {}) {
        const profile = await this.storage.createProfile(name, metadata);
        // Initialize with default preferences
        await this.learner.initializeUserPreferences(profile.id);
        // Emit event
        this.eventEmitter.emit(PersonalizationEvent.PROFILE_CREATED, profile);
        return profile;
    }
    /**
     * Get a user profile
     */
    async getUserProfile(userId) {
        return this.storage.getProfile(userId);
    }
    /**
     * Update a user profile
     */
    async updateUserProfile(userId, updates) {
        const profile = await this.storage.updateProfile(userId, updates);
        // Emit event
        this.eventEmitter.emit(PersonalizationEvent.PROFILE_UPDATED, profile);
        return profile;
    }
    /**
     * Track a user interaction
     */
    async trackInteraction(userId, type, context, metadata) {
        const interaction = await this.tracker.trackInteraction(userId, type, context, metadata);
        // Emit event
        this.eventEmitter.emit(PersonalizationEvent.INTERACTION_RECORDED, interaction);
        return interaction;
    }
    /**
     * Set a user preference explicitly
     */
    async setPreference(userId, category, key, value) {
        const preference = await this.learner.setExplicitPreference(userId, category, key, value);
        // Emit event
        this.eventEmitter.emit(PersonalizationEvent.PREFERENCE_CHANGED, {
            userId,
            preference,
        });
        return preference;
    }
    /**
     * Get a user preference
     */
    async getPreference(userId, category, key, defaultValue) {
        return this.learner.getPreference(userId, category, key, defaultValue);
    }
    /**
     * Get all preferences for a user
     */
    async getAllPreferences(userId) {
        return this.storage.getPreferences(userId);
    }
    /**
     * Get preferences by category
     */
    async getPreferencesByCategory(userId, category) {
        return this.storage.getPreferences(userId, category);
    }
    /**
     * Personalize content based on user preferences
     */
    async personalizeContent(userId, content, contentType) {
        // Get relevant preferences based on content type
        let relevantCategories = [];
        switch (contentType) {
            case 'code':
                relevantCategories = [PreferenceCategory.CODE_STYLE];
                break;
            case 'documentation':
                relevantCategories = [PreferenceCategory.DOCUMENTATION_STYLE];
                break;
            case 'response':
                relevantCategories = [PreferenceCategory.RESPONSE_STYLE];
                break;
            case 'visualization':
                relevantCategories = [PreferenceCategory.VISUALIZATION_STYLE];
                break;
            default:
                relevantCategories = [PreferenceCategory.CONTENT_FORMAT, PreferenceCategory.RESPONSE_STYLE];
        }
        // Get all relevant preferences
        const allPreferences = [];
        for (const category of relevantCategories) {
            const prefs = await this.storage.getPreferences(userId, category);
            allPreferences.push(...prefs);
        }
        // Apply preferences to content
        let personalizedContent = content;
        // Only apply preferences with sufficient confidence
        const applicablePreferences = allPreferences.filter(p => p.confidence >= this.config.minConfidence);
        // Apply personalization based on content type
        switch (contentType) {
            case 'code':
                personalizedContent = this.personalizeCode(content, applicablePreferences);
                break;
            case 'documentation':
                personalizedContent = this.personalizeDocumentation(content, applicablePreferences);
                break;
            case 'response':
                personalizedContent = this.personalizeResponse(content, applicablePreferences);
                break;
            case 'visualization':
                personalizedContent = this.personalizeVisualization(content, applicablePreferences);
                break;
            default:
                // Generic personalization
                personalizedContent = this.applyGenericPersonalization(content, applicablePreferences);
        }
        return personalizedContent;
    }
    /**
     * Subscribe to personalization events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from personalization events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
    /**
     * Get the interaction tracker
     */
    getInteractionTracker() {
        return this.tracker;
    }
    /**
     * Get the preference learner
     */
    getPreferenceLearner() {
        return this.learner;
    }
    /**
     * Personalize code based on preferences
     */
    personalizeCode(code, preferences) {
        // This is a simplified implementation
        // A real implementation would be much more sophisticated
        let personalizedCode = code;
        // Apply indentation preference
        const indentPref = preferences.find(p => p.category === PreferenceCategory.CODE_STYLE && p.key === 'indentation');
        if (indentPref && typeof personalizedCode === 'string') {
            if (indentPref.value === 'spaces' && personalizedCode.includes('\t')) {
                // Replace tabs with spaces
                personalizedCode = personalizedCode.replace(/\t/g, '  ');
            }
            else if (indentPref.value === 'tabs' && personalizedCode.includes('  ')) {
                // Replace spaces with tabs (simplistic)
                personalizedCode = personalizedCode.replace(/^(  )+/gm, match => {
                    return '\t'.repeat(match.length / 2);
                });
            }
        }
        return personalizedCode;
    }
    /**
     * Personalize documentation based on preferences
     */
    personalizeDocumentation(documentation, preferences) {
        // This is a simplified implementation
        // A real implementation would be much more sophisticated
        // If documentation is a string, apply text-based personalization
        if (typeof documentation === 'string') {
            let personalizedDoc = documentation;
            // Apply verbosity preference
            const verbosityPref = preferences.find(p => p.category === PreferenceCategory.DOCUMENTATION_STYLE && p.key === 'verbosity');
            if (verbosityPref) {
                if (verbosityPref.value === 'concise' && personalizedDoc.length > 500) {
                    // Simplistic approach to making it more concise
                    personalizedDoc = personalizedDoc
                        .replace(/\n\n+/g, '\n\n')
                        .replace(/( that is| which is| in order to| due to the fact that)/g, '');
                }
                else if (verbosityPref.value === 'detailed' && personalizedDoc.length < 200) {
                    // This is very simplistic - a real implementation would be more sophisticated
                    personalizedDoc += '\n\nFor more information, refer to the related documentation.';
                }
            }
            return personalizedDoc;
        }
        return documentation;
    }
    /**
     * Personalize response based on preferences
     */
    personalizeResponse(response, preferences) {
        // This is a simplified implementation
        // A real implementation would be much more sophisticated
        // If response is a string, apply text-based personalization
        if (typeof response === 'string') {
            let personalizedResponse = response;
            // Apply verbosity preference
            const verbosityPref = preferences.find(p => p.category === PreferenceCategory.RESPONSE_STYLE && p.key === 'verbosity');
            if (verbosityPref) {
                if (verbosityPref.value === 'concise' && personalizedResponse.length > 300) {
                    // Simplistic approach to making it more concise
                    personalizedResponse = personalizedResponse
                        .replace(/\n\n+/g, '\n\n')
                        .replace(/( that is| which is| in order to| due to the fact that)/g, '');
                    // Add a TL;DR if it's still long
                    if (personalizedResponse.length > 500) {
                        const firstSentence = personalizedResponse.split('.')[0] + '.';
                        personalizedResponse = `TL;DR: ${firstSentence}\n\n${personalizedResponse}`;
                    }
                }
                else if (verbosityPref.value === 'detailed' && personalizedResponse.length < 200) {
                    // This is very simplistic - a real implementation would be more sophisticated
                    personalizedResponse +=
                        '\n\nWould you like me to provide more details on any aspect of this response?';
                }
            }
            return personalizedResponse;
        }
        return response;
    }
    /**
     * Personalize visualization based on preferences
     */
    personalizeVisualization(visualization, preferences) {
        // This is a simplified implementation
        // A real implementation would be much more sophisticated
        // If visualization is an object, apply visualization-specific personalization
        if (typeof visualization === 'object' && visualization !== null) {
            const personalizedViz = { ...visualization };
            // Apply color scheme preference
            const colorPref = preferences.find(p => p.category === PreferenceCategory.VISUALIZATION_STYLE && p.key === 'colorScheme');
            if (colorPref && personalizedViz.metadata) {
                personalizedViz.metadata.colorScheme = colorPref.value;
            }
            // Apply layout preference
            const layoutPref = preferences.find(p => p.category === PreferenceCategory.VISUALIZATION_STYLE && p.key === 'layout');
            if (layoutPref && personalizedViz.metadata) {
                personalizedViz.metadata.layout = layoutPref.value;
            }
            return personalizedViz;
        }
        return visualization;
    }
    /**
     * Apply generic personalization
     */
    applyGenericPersonalization(content, preferences) {
        // This is a simplified implementation
        // A real implementation would be much more sophisticated
        // If content is a string, apply text-based personalization
        if (typeof content === 'string') {
            return this.personalizeResponse(content, preferences);
        }
        // If content is an object, apply object-based personalization
        if (typeof content === 'object' && content !== null) {
            // Clone the object to avoid modifying the original
            const personalizedContent = { ...content };
            // Apply format preferences if available
            const formatPref = preferences.find(p => p.category === PreferenceCategory.CONTENT_FORMAT && p.key === 'format');
            if (formatPref && personalizedContent.metadata) {
                personalizedContent.metadata.format = formatPref.value;
            }
            return personalizedContent;
        }
        return content;
    }
    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Example: Log preference changes
        this.eventEmitter.on(PersonalizationEvent.PREFERENCE_CHANGED, data => {
            console.log(`Preference changed for user ${data.userId}: ${data.preference.category}.${data.preference.key} = ${data.preference.value}`);
        });
    }
}
