/**
 * Copilot Adapter for Personalization System
 * Integrates personalization with GitHub Copilot
 */
import { InteractionType } from '../types';
import { AIAdapter } from './ai-adapter';
/**
 * Adapter for integrating with GitHub Copilot
 */
export class CopilotAdapter extends AIAdapter {
    constructor(personalizationManager) {
        super(personalizationManager);
        this.personalizationManager = personalizationManager;
    }
    /**
     * Process a Copilot request
     */
    async processRequest(request) {
        // First apply general AI personalization
        const personalizedRequest = await super.personalizeRequest(request);
        // Track Copilot-specific interaction data
        await this.personalizationManager.trackInteraction(request.userId, InteractionType.QUERY, {
            fileExtension: request.fileExtension,
            lineNumber: request.lineNumber,
            columnNumber: request.columnNumber,
            precedingCodeLength: request.precedingCode.length,
            followingCodeLength: request.followingCode.length,
        }, { source: 'copilot' });
        return personalizedRequest;
    }
    /**
     * Process a Copilot response
     */
    async processResponse(response, request) {
        // First apply general AI personalization
        const personalizedResponse = (await super.personalizeResponse(response, request));
        // Personalize the suggested code
        const personalizedCode = await this.personalizationManager.personalizeContent(request.userId, response.suggestedCode, 'code');
        personalizedResponse.suggestedCode = personalizedCode;
        // Personalize alternative suggestions if present
        if (personalizedResponse.alternatives && personalizedResponse.alternatives.length > 0) {
            const personalizedAlternatives = [];
            for (const alternative of personalizedResponse.alternatives) {
                const personalizedAlt = await this.personalizationManager.personalizeContent(request.userId, alternative, 'code');
                personalizedAlternatives.push(personalizedAlt);
            }
            personalizedResponse.alternatives = personalizedAlternatives;
        }
        // Track response interaction
        await this.personalizationManager.trackInteraction(request.userId, InteractionType.FEEDBACK, {
            fileExtension: request.fileExtension,
            suggestedCodeLength: response.suggestedCode.length,
            alternativeCount: response.alternatives?.length || 0,
            confidence: response.confidence,
        }, { source: 'copilot' });
        return personalizedResponse;
    }
    /**
     * Track code acceptance from Copilot
     */
    async trackCodeAcceptance(userId, suggestedCode, fileExtension, accepted, edited) {
        await this.personalizationManager.trackInteraction(userId, InteractionType.FEEDBACK, {
            action: 'code-acceptance',
            fileExtension,
            suggestedCodeLength: suggestedCode.length,
            accepted,
            edited,
        }, { source: 'copilot-acceptance' });
        // If code was accepted, store it as a code style example
        if (accepted) {
            await this.personalizationManager.trackInteraction(userId, InteractionType.MEMORY_CREATION, {
                type: 'code',
                content: suggestedCode,
                fileExtension,
            }, { source: 'copilot-accepted-code' });
        }
    }
    /**
     * Track inline code completion
     */
    async trackInlineCompletion(userId, precedingCode, completion, fileExtension, accepted) {
        await this.personalizationManager.trackInteraction(userId, InteractionType.CUSTOM, {
            action: 'inline-completion',
            fileExtension,
            precedingCodeLength: precedingCode.length,
            completionLength: completion.length,
            accepted,
        }, { source: 'copilot-inline' });
    }
}
