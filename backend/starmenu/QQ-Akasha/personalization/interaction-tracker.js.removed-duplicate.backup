/**
 * Interaction Tracker for Personalization System
 */
import { EventEmitter } from 'events';
/**
 * Events emitted by the interaction tracker
 */
export var InteractionEvent;
(function (InteractionEvent) {
    InteractionEvent["INTERACTION_RECORDED"] = "interaction-recorded";
    InteractionEvent["PATTERN_DETECTED"] = "pattern-detected";
})(InteractionEvent || (InteractionEvent = {}));
/**
 * Tracks user interactions for personalization
 */
export class InteractionTracker {
    constructor(storage) {
        this.storage = storage;
        this.eventEmitter = new EventEmitter();
        this.patternDetectors = new Map();
    }
    /**
     * Record a user interaction
     */
    async trackInteraction(userId, type, context, metadata) {
        const interaction = await this.storage.addInteraction({
            userId,
            type,
            timestamp: new Date(),
            context,
            metadata,
        });
        // Emit event
        this.eventEmitter.emit(InteractionEvent.INTERACTION_RECORDED, interaction);
        // Run pattern detectors
        for (const detector of this.patternDetectors.values()) {
            try {
                await detector(interaction);
            }
            catch (error) {
                console.error('Error in pattern detector:', error);
            }
        }
        return interaction;
    }
    /**
     * Get recent interactions for a user
     */
    async getRecentInteractions(userId, limit = 20) {
        return this.storage.getInteractions(userId, limit);
    }
    /**
     * Get interactions of a specific type
     */
    async getInteractionsByType(userId, type, limit) {
        const interactions = await this.storage.getInteractions(userId);
        const filtered = interactions.filter(i => i.type === type);
        // Sort by timestamp (newest first)
        const sorted = filtered.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
        // Apply limit if specified
        if (limit !== undefined) {
            return sorted.slice(0, limit);
        }
        return sorted;
    }
    /**
     * Register a pattern detector
     */
    registerPatternDetector(id, detector) {
        this.patternDetectors.set(id, detector);
    }
    /**
     * Unregister a pattern detector
     */
    unregisterPatternDetector(id) {
        return this.patternDetectors.delete(id);
    }
    /**
     * Subscribe to interaction events
     */
    on(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    /**
     * Unsubscribe from interaction events
     */
    off(event, listener) {
        this.eventEmitter.off(event, listener);
    }
    /**
     * Emit a pattern detected event
     */
    emitPatternDetected(patternType, userId, details) {
        this.eventEmitter.emit(InteractionEvent.PATTERN_DETECTED, {
            patternType,
            userId,
            timestamp: new Date(),
            details,
        });
    }
}
