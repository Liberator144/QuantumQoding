/**
 * Dimensional Protocol Manager
 *
 * Manages dimensional protocol harmonization for database entities.
 *
 * @version 1.0.0
 */
import { EventEmitter } from 'events';
import { MetadataType } from '../metadata/MetadataManager';
/**
 * Protocol type
 */
export var ProtocolType;
(function (ProtocolType) {
    ProtocolType["REST"] = "rest";
    ProtocolType["GRAPHQL"] = "graphql";
    ProtocolType["GRPC"] = "grpc";
    ProtocolType["WEBSOCKET"] = "websocket";
    ProtocolType["MQTT"] = "mqtt";
    ProtocolType["CUSTOM"] = "custom";
})(ProtocolType || (ProtocolType = {}));
/**
 * Protocol format
 */
export var ProtocolFormat;
(function (ProtocolFormat) {
    ProtocolFormat["JSON"] = "json";
    ProtocolFormat["XML"] = "xml";
    ProtocolFormat["PROTOBUF"] = "protobuf";
    ProtocolFormat["AVRO"] = "avro";
    ProtocolFormat["THRIFT"] = "thrift";
    ProtocolFormat["BSON"] = "bson";
    ProtocolFormat["MSGPACK"] = "msgpack";
    ProtocolFormat["CUSTOM"] = "custom";
})(ProtocolFormat || (ProtocolFormat = {}));
/**
 * Default dimensional protocol manager options
 */
const DEFAULT_OPTIONS = {
    protocolMappingsCollection: '_protocol_mappings',
    cacheEnabled: true,
    cacheTTL: 60000,
    debugMode: false
};
/**
 * Dimensional protocol manager
 */
export class DimensionalProtocolManager extends EventEmitter {
    /**
     * Constructor
     * @param metadataManager - Metadata manager
     * @param options - Dimensional protocol manager options
     */
    constructor(metadataManager, options = {}) {
        super();
        /** Protocol mappings */
        this.protocolMappings = new Map();
        /** Cache */
        this.cache = new Map();
        /** Is initialized */
        this.isInitialized = false;
        this.metadataManager = metadataManager;
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    /**
     * Initialize dimensional protocol manager
     * @returns Promise resolving to initialization success
     */
    async initialize() {
        try {
            // Check if metadata manager is initialized
            if (!this.metadataManager) {
                throw new Error('Metadata manager is required');
            }
            // Load protocol mappings
            await this.loadProtocolMappings();
            this.isInitialized = true;
            this.log('Dimensional protocol manager initialized');
            return true;
        }
        catch (error) {
            this.logError('Failed to initialize dimensional protocol manager', error);
            return false;
        }
    }
    /**
     * Ensure initialized
     * @throws Error if not initialized
     */
    ensureInitialized() {
        if (!this.isInitialized) {
            throw new Error('Dimensional protocol manager not initialized');
        }
    }
    /**
     * Load protocol mappings
     */
    async loadProtocolMappings() {
        try {
            // Get protocol mappings from metadata
            const mappings = await this.metadataManager.getMetadataByType(MetadataType.MAPPING);
            // Clear existing mappings
            this.protocolMappings.clear();
            // Add mappings
            for (const mapping of mappings) {
                if (mapping.key.startsWith('protocol_mapping:') && mapping.value) {
                    const key = mapping.key.substring('protocol_mapping:'.length);
                    this.protocolMappings.set(key, mapping.value);
                }
            }
            this.log(`Loaded ${this.protocolMappings.size} protocol mappings`);
        }
        catch (error) {
            this.logError('Failed to load protocol mappings', error);
            throw error;
        }
    }
    /**
     * Register protocol mapping
     * @param sourceProtocol - Source protocol
     * @param targetProtocol - Target protocol
     * @param sourceFormat - Source format
     * @param targetFormat - Target format
     * @param fieldMappings - Field mappings
     * @param transformFunctions - Transform functions
     * @param customMappingLogic - Custom mapping logic
     * @returns Promise resolving to registration success
     */
    async registerProtocolMapping(sourceProtocol, targetProtocol, sourceFormat, targetFormat, fieldMappings, transformFunctions, customMappingLogic) {
        this.ensureInitialized();
        try {
            // Create mapping
            const mapping = {
                sourceProtocol,
                targetProtocol,
                sourceFormat,
                targetFormat,
                fieldMappings,
                transformFunctions,
                customMappingLogic
            };
            // Generate key
            const key = this.getProtocolMappingKey(sourceProtocol, targetProtocol, sourceFormat, targetFormat);
            // Store mapping
            await this.metadataManager.setMetadata(`protocol_mapping:${key}`, mapping, MetadataType.MAPPING);
            // Add to mappings
            this.protocolMappings.set(key, mapping);
            // Emit event
            this.emit('mapping-registered', mapping);
            return true;
        }
        catch (error) {
            this.logError('Failed to register protocol mapping', error);
            throw error;
        }
    }
    /**
     * Get protocol mapping
     * @param sourceProtocol - Source protocol
     * @param targetProtocol - Target protocol
     * @param sourceFormat - Source format
     * @param targetFormat - Target format
     * @returns Protocol mapping or null
     */
    getProtocolMapping(sourceProtocol, targetProtocol, sourceFormat, targetFormat) {
        this.ensureInitialized();
        // Generate key
        const key = this.getProtocolMappingKey(sourceProtocol, targetProtocol, sourceFormat, targetFormat);
        // Get mapping
        return this.protocolMappings.get(key) || null;
    }
    /**
     * Get protocol mapping key
     * @param sourceProtocol - Source protocol
     * @param targetProtocol - Target protocol
     * @param sourceFormat - Source format
     * @param targetFormat - Target format
     * @returns Protocol mapping key
     */
    getProtocolMappingKey(sourceProtocol, targetProtocol, sourceFormat, targetFormat) {
        return `${sourceProtocol}:${targetProtocol}:${sourceFormat}:${targetFormat}`;
    }
    /**
     * Translate data
     * @param data - Data to translate
     * @param sourceProtocol - Source protocol
     * @param targetProtocol - Target protocol
     * @param sourceFormat - Source format
     * @param targetFormat - Target format
     * @returns Promise resolving to translation result
     */
    async translateData(data, sourceProtocol, targetProtocol, sourceFormat, targetFormat) {
        this.ensureInitialized();
        try {
            // Check cache
            const cacheKey = this.getCacheKey(data, sourceProtocol, targetProtocol, sourceFormat, targetFormat);
            const cached = this.getFromCache(cacheKey);
            if (cached) {
                return cached;
            }
            // Get mapping
            const mapping = this.getProtocolMapping(sourceProtocol, targetProtocol, sourceFormat, targetFormat);
            if (!mapping) {
                return {
                    success: false,
                    errors: [`No mapping found for ${sourceProtocol}/${sourceFormat} to ${targetProtocol}/${targetFormat}`]
                };
            }
            // Translate data
            const result = await this.translateWithMapping(data, mapping);
            // Cache result
            this.setInCache(cacheKey, result);
            return result;
        }
        catch (error) {
            this.logError('Failed to translate data', error);
            return {
                success: false,
                errors: [error.message || 'Unknown error']
            };
        }
    }
    /**
     * Translate with mapping
     * @param data - Data to translate
     * @param mapping - Protocol mapping
     * @returns Promise resolving to translation result
     */
    async translateWithMapping(data, mapping) {
        try {
            // Parse data if needed
            let parsedData = data;
            if (typeof data === 'string') {
                try {
                    switch (mapping.sourceFormat) {
                        case ProtocolFormat.JSON:
                            parsedData = JSON.parse(data);
                            break;
                        case ProtocolFormat.XML:
                            // Use XML parser
                            parsedData = this.parseXML(data);
                            break;
                        // Add other format parsers as needed
                        default:
                            // Unknown format
                            return {
                                success: false,
                                errors: [`Unsupported source format: ${mapping.sourceFormat}`]
                            };
                    }
                }
                catch (error) {
                    return {
                        success: false,
                        errors: [`Failed to parse data: ${error.message}`]
                    };
                }
            }
            // Apply field mappings
            const translatedData = {};
            const warnings = [];
            for (const [targetField, sourceField] of Object.entries(mapping.fieldMappings)) {
                try {
                    // Get source value
                    const sourceValue = this.getNestedValue(parsedData, sourceField);
                    // Apply transform function if available
                    let targetValue = sourceValue;
                    if (mapping.transformFunctions && mapping.transformFunctions[targetField]) {
                        targetValue = this.applyTransformFunction(sourceValue, mapping.transformFunctions[targetField]);
                    }
                    // Set target value
                    this.setNestedValue(translatedData, targetField, targetValue);
                }
                catch (error) {
                    warnings.push(`Failed to map field ${sourceField} to ${targetField}: ${error.message}`);
                }
            }
            // Apply custom mapping logic if available
            if (mapping.customMappingLogic) {
                try {
                    const customLogicFn = new Function('data', 'translatedData', mapping.customMappingLogic);
                    customLogicFn(parsedData, translatedData);
                }
                catch (error) {
                    warnings.push(`Failed to apply custom mapping logic: ${error.message}`);
                }
            }
            // Format result
            let formattedData = translatedData;
            if (mapping.targetFormat !== ProtocolFormat.JSON) {
                try {
                    switch (mapping.targetFormat) {
                        case ProtocolFormat.XML:
                            // Convert to XML
                            formattedData = this.convertToXML(translatedData);
                            break;
                        // Add other format converters as needed
                        default:
                            warnings.push(`Unsupported target format: ${mapping.targetFormat}, returning JSON`);
                            break;
                    }
                }
                catch (error) {
                    warnings.push(`Failed to format data: ${error.message}, returning JSON`);
                }
            }
            return {
                success: true,
                data: formattedData,
                warnings: warnings.length > 0 ? warnings : undefined
            };
        }
        catch (error) {
            return {
                success: false,
                errors: [error.message || 'Unknown error']
            };
        }
    }
    /**
     * Get nested value
     * @param obj - Object
     * @param path - Path
     * @returns Nested value
     */
    getNestedValue(obj, path) {
        const parts = path.split('.');
        let value = obj;
        for (const part of parts) {
            if (value === null || value === undefined) {
                return undefined;
            }
            value = value[part];
        }
        return value;
    }
    /**
     * Set nested value
     * @param obj - Object
     * @param path - Path
     * @param value - Value
     */
    setNestedValue(obj, path, value) {
        const parts = path.split('.');
        let current = obj;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (current[part] === undefined) {
                current[part] = {};
            }
            current = current[part];
        }
        current[parts[parts.length - 1]] = value;
    }
    /**
     * Apply transform function
     * @param value - Value
     * @param transformFunction - Transform function
     * @returns Transformed value
     */
    applyTransformFunction(value, transformFunction) {
        try {
            const fn = new Function('value', transformFunction);
            return fn(value);
        }
        catch (error) {
            throw new Error(`Failed to apply transform function: ${error.message}`);
        }
    }
    /**
     * Parse XML
     * @param xml - XML string
     * @returns Parsed XML
     */
    parseXML(xml) {
        // Simple XML parser
        // In a real implementation, use a proper XML parser library
        const result = {};
        // Extract root element
        const rootMatch = xml.match(/<([^\s>]+)([^>]*)>([\s\S]*)<\/\1>/);
        if (!rootMatch) {
            throw new Error('Invalid XML');
        }
        const rootName = rootMatch[1];
        const rootContent = rootMatch[3];
        // Extract attributes
        const attributes = {};
        const attrMatches = rootMatch[2].matchAll(/([^\s=]+)="([^"]*)"/g);
        for (const match of attrMatches) {
            attributes[match[1]] = match[2];
        }
        // Extract child elements
        const childElements = {};
        const childMatches = rootContent.matchAll(/<([^\s>]+)([^>]*)>([\s\S]*?)<\/\1>/g);
        for (const match of childMatches) {
            const childName = match[1];
            const childContent = match[3];
            if (childElements[childName]) {
                if (Array.isArray(childElements[childName])) {
                    childElements[childName].push(childContent);
                }
                else {
                    childElements[childName] = [childElements[childName], childContent];
                }
            }
            else {
                childElements[childName] = childContent;
            }
        }
        result[rootName] = {
            _attributes: attributes,
            ...childElements
        };
        return result;
    }
    /**
     * Convert to XML
     * @param obj - Object
     * @returns XML string
     */
    convertToXML(obj) {
        // Simple XML converter
        // In a real implementation, use a proper XML library
        let xml = '';
        for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'object' && value !== null) {
                // Handle attributes
                let attributes = '';
                let content = '';
                for (const [k, v] of Object.entries(value)) {
                    if (k === '_attributes') {
                        for (const [attrKey, attrValue] of Object.entries(v)) {
                            attributes += ` ${attrKey}="${attrValue}"`;
                        }
                    }
                    else {
                        content += this.convertToXML({ [k]: v });
                    }
                }
                xml += `<${key}${attributes}>${content}</${key}>`;
            }
            else {
                xml += `<${key}>${value}</${key}>`;
            }
        }
        return xml;
    }
    /**
     * Get cache key
     * @param data - Data
     * @param sourceProtocol - Source protocol
     * @param targetProtocol - Target protocol
     * @param sourceFormat - Source format
     * @param targetFormat - Target format
     * @returns Cache key
     */
    getCacheKey(data, sourceProtocol, targetProtocol, sourceFormat, targetFormat) {
        const dataHash = this.hashData(data);
        return `${sourceProtocol}:${targetProtocol}:${sourceFormat}:${targetFormat}:${dataHash}`;
    }
    /**
     * Hash data
     * @param data - Data
     * @returns Data hash
     */
    hashData(data) {
        // Simple hash function
        // In a real implementation, use a proper hash function
        const str = typeof data === 'string' ? data : JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash.toString(16);
    }
    /**
     * Get from cache
     * @param key - Cache key
     * @returns Cached data or undefined
     */
    getFromCache(key) {
        if (!this.options.cacheEnabled) {
            return undefined;
        }
        const cached = this.cache.get(key);
        if (!cached) {
            return undefined;
        }
        // Check if expired
        if (cached.expires < Date.now()) {
            this.cache.delete(key);
            return undefined;
        }
        return cached.data;
    }
    /**
     * Set in cache
     * @param key - Cache key
     * @param data - Data to cache
     */
    setInCache(key, data) {
        if (!this.options.cacheEnabled) {
            return;
        }
        const expires = Date.now() + (this.options.cacheTTL || 60000);
        this.cache.set(key, {
            data,
            expires
        });
    }
    /**
     * Clear cache
     */
    clearCache() {
        if (!this.options.cacheEnabled) {
            return;
        }
        this.cache.clear();
        this.log('Cache cleared');
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[DimensionalProtocolManager] ${message}`);
        }
    }
    /**
     * Log error
     * @param message - Error message
     * @param error - Error object
     */
    logError(message, error) {
        console.error(`[DimensionalProtocolManager] ${message}`, error);
    }
}
export default DimensionalProtocolManager;
