/**
 * MongoDB Adapter
 *
 * Provides a MongoDB implementation of the DatabaseAdapter interface.
 *
 * @version 1.0.0
 */
import { MongoClient } from 'mongodb';
/**
 * MongoDB adapter
 */
export class MongoDBAdapter {
    /**
     * Constructor
     * @param options - MongoDB adapter options
     */
    constructor(options) {
        /** Adapter name */
        this.name = 'mongodb';
        /** MongoDB client */
        this.client = null;
        /** MongoDB database */
        this.db = null;
        /** Collections cache */
        this.collections = new Map();
        /** Is connected */
        this._isConnected = false;
        this.options = options;
    }
    /**
     * Get is connected
     */
    get isConnected() {
        return this._isConnected;
    }
    /**
     * Connect to MongoDB
     * @returns Promise resolving to connection success
     */
    async connect() {
        try {
            // Create client
            this.client = new MongoClient(this.options.uri, this.options.options);
            // Connect to MongoDB
            await this.client.connect();
            // Get database
            this.db = this.client.db(this.options.database);
            this._isConnected = true;
            this.log('Connected to MongoDB');
            return true;
        }
        catch (error) {
            this.logError('Failed to connect to MongoDB', error);
            return false;
        }
    }
    /**
     * Disconnect from MongoDB
     * @returns Promise resolving to disconnection success
     */
    async disconnect() {
        try {
            if (this.client) {
                await this.client.close();
                this.client = null;
                this.db = null;
                this.collections.clear();
            }
            this._isConnected = false;
            this.log('Disconnected from MongoDB');
            return true;
        }
        catch (error) {
            this.logError('Failed to disconnect from MongoDB', error);
            return false;
        }
    }
    /**
     * Get collection
     * @param name - Collection name
     * @returns Collection
     */
    getCollection(name) {
        if (!this.isConnected || !this.db) {
            throw new Error('Not connected to MongoDB');
        }
        // Check cache
        if (this.collections.has(name)) {
            return this.collections.get(name);
        }
        // Get collection
        const collection = this.db.collection(name);
        // Cache collection
        this.collections.set(name, collection);
        return collection;
    }
    /**
     * Collection exists
     * @param name - Collection name
     * @returns Promise resolving to existence
     */
    async collectionExists(name) {
        try {
            if (!this.isConnected || !this.db) {
                throw new Error('Not connected to MongoDB');
            }
            const collections = await this.db.listCollections({ name }).toArray();
            return collections.length > 0;
        }
        catch (error) {
            this.logError(`Failed to check if collection exists: ${name}`, error);
            throw error;
        }
    }
    /**
     * Create collection
     * @param name - Collection name
     * @returns Promise resolving to creation success
     */
    async createCollection(name) {
        try {
            if (!this.isConnected || !this.db) {
                throw new Error('Not connected to MongoDB');
            }
            await this.db.createCollection(name);
            // Clear collection cache
            this.collections.delete(name);
            return true;
        }
        catch (error) {
            this.logError(`Failed to create collection: ${name}`, error);
            throw error;
        }
    }
    /**
     * Drop collection
     * @param name - Collection name
     * @returns Promise resolving to drop success
     */
    async dropCollection(name) {
        try {
            if (!this.isConnected || !this.db) {
                throw new Error('Not connected to MongoDB');
            }
            const exists = await this.collectionExists(name);
            if (!exists) {
                return false;
            }
            await this.db.dropCollection(name);
            // Clear collection cache
            this.collections.delete(name);
            return true;
        }
        catch (error) {
            this.logError(`Failed to drop collection: ${name}`, error);
            throw error;
        }
    }
    /**
     * Find entities
     * @param collection - Collection name
     * @param query - Query object
     * @param options - Query options
     * @returns Promise resolving to found entities
     */
    async find(collection, query = {}, options = {}) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert ID to ObjectId if needed
            if (query.id) {
                query._id = query.id;
                delete query.id;
            }
            // Create cursor
            let cursor = coll.find(query);
            // Apply options
            if (options.sort) {
                cursor = cursor.sort(options.sort);
            }
            if (options.skip) {
                cursor = cursor.skip(options.skip);
            }
            if (options.limit) {
                cursor = cursor.limit(options.limit);
            }
            // Get results
            const results = await cursor.toArray();
            // Convert _id to id
            return results.map(result => {
                const { _id, ...rest } = result;
                return { id: _id.toString(), ...rest };
            });
        }
        catch (error) {
            this.logError(`Failed to find entities in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Find one entity
     * @param collection - Collection name
     * @param query - Query object
     * @param options - Query options
     * @returns Promise resolving to found entity or null
     */
    async findOne(collection, query = {}, options = {}) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert ID to ObjectId if needed
            if (query.id) {
                query._id = query.id;
                delete query.id;
            }
            // Find one
            const result = await coll.findOne(query, options);
            if (!result) {
                return null;
            }
            // Convert _id to id
            const { _id, ...rest } = result;
            return { id: _id.toString(), ...rest };
        }
        catch (error) {
            this.logError(`Failed to find entity in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Find entity by ID
     * @param collection - Collection name
     * @param id - Entity ID
     * @param options - Query options
     * @returns Promise resolving to found entity or null
     */
    async findById(collection, id, options = {}) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Find by ID
            const result = await coll.findOne({ _id: id }, options);
            if (!result) {
                return null;
            }
            // Convert _id to id
            const { _id, ...rest } = result;
            return { id: _id.toString(), ...rest };
        }
        catch (error) {
            this.logError(`Failed to find entity by ID in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Insert entity
     * @param collection - Collection name
     * @param entity - Entity to insert
     * @returns Promise resolving to inserted entity
     */
    async insert(collection, entity) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert id to _id
            const { id, ...rest } = entity;
            const document = { _id: id, ...rest };
            // Insert document
            await coll.insertOne(document);
            return entity;
        }
        catch (error) {
            this.logError(`Failed to insert entity in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Insert multiple entities
     * @param collection - Collection name
     * @param entities - Entities to insert
     * @returns Promise resolving to inserted entities
     */
    async insertMany(collection, entities) {
        try {
            if (entities.length === 0) {
                return [];
            }
            // Get collection
            const coll = this.getCollection(collection);
            // Convert id to _id
            const documents = entities.map(entity => {
                const { id, ...rest } = entity;
                return { _id: id, ...rest };
            });
            // Insert documents
            await coll.insertMany(documents);
            return entities;
        }
        catch (error) {
            this.logError(`Failed to insert entities in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Update entity by ID
     * @param collection - Collection name
     * @param id - Entity ID
     * @param update - Update object
     * @returns Promise resolving to update success
     */
    async updateById(collection, id, update) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Remove id from update
            const { id: updateId, ...updateData } = update;
            // Update document
            const result = await coll.updateOne({ _id: id }, { $set: updateData });
            return result.modifiedCount > 0;
        }
        catch (error) {
            this.logError(`Failed to update entity by ID in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Update entities
     * @param collection - Collection name
     * @param query - Query object
     * @param update - Update object
     * @returns Promise resolving to number of updated entities
     */
    async update(collection, query, update) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert ID to ObjectId if needed
            if (query.id) {
                query._id = query.id;
                delete query.id;
            }
            // Remove id from update
            const { id: updateId, ...updateData } = update;
            // Update documents
            const result = await coll.updateMany(query, { $set: updateData });
            return result.modifiedCount;
        }
        catch (error) {
            this.logError(`Failed to update entities in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Delete entity by ID
     * @param collection - Collection name
     * @param id - Entity ID
     * @returns Promise resolving to deletion success
     */
    async deleteById(collection, id) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Delete document
            const result = await coll.deleteOne({ _id: id });
            return result.deletedCount > 0;
        }
        catch (error) {
            this.logError(`Failed to delete entity by ID in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Delete entities
     * @param collection - Collection name
     * @param query - Query object
     * @returns Promise resolving to number of deleted entities
     */
    async delete(collection, query) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert ID to ObjectId if needed
            if (query.id) {
                query._id = query.id;
                delete query.id;
            }
            // Delete documents
            const result = await coll.deleteMany(query);
            return result.deletedCount;
        }
        catch (error) {
            this.logError(`Failed to delete entities in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Count entities
     * @param collection - Collection name
     * @param query - Query object
     * @returns Promise resolving to entity count
     */
    async count(collection, query = {}) {
        try {
            // Get collection
            const coll = this.getCollection(collection);
            // Convert ID to ObjectId if needed
            if (query.id) {
                query._id = query.id;
                delete query.id;
            }
            // Count documents
            return await coll.countDocuments(query);
        }
        catch (error) {
            this.logError(`Failed to count entities in collection: ${collection}`, error);
            throw error;
        }
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[MongoDBAdapter] ${message}`);
        }
    }
    /**
     * Log error
     * @param message - Error message
     * @param error - Error object
     */
    logError(message, error) {
        console.error(`[MongoDBAdapter] ${message}`, error);
    }
}
export default MongoDBAdapter;
