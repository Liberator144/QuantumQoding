/**
 * Sync Manager
 *
 * Manages data synchronization between different data sources.
 *
 * @version 1.0.0
 */
import { EventEmitter } from 'events';
/**
 * Sync operation type
 */
export var SyncOperationType;
(function (SyncOperationType) {
    SyncOperationType["CREATE"] = "create";
    SyncOperationType["UPDATE"] = "update";
    SyncOperationType["DELETE"] = "delete";
    SyncOperationType["BATCH"] = "batch";
})(SyncOperationType || (SyncOperationType = {}));
const DEFAULT_OPTIONS = {
    syncOperationsCollection: '_sync_operations',
    syncInterval: 5000,
    batchSize: 100,
    retryAttempts: 3,
    retryDelay: 1000,
    debugMode: false
};
/**
 * Sync manager
 */
export class SyncManager extends EventEmitter {
    /**
     * Constructor
     * @param primaryAdapter - Primary database adapter
     * @param metadataManager - Metadata manager
     * @param options - Sync manager options
     */
    constructor(primaryAdapter, metadataManager, options = {}) {
        super();
        /** Secondary adapters */
        this.secondaryAdapters = new Map();
        /** Sync timer */
        this.syncTimer = null;
        /** Is initialized */
        this.isInitialized = false;
        /** Is syncing */
        this.isSyncing = false;
        this.primaryAdapter = primaryAdapter;
        this.metadataManager = metadataManager;
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    /**
     * Initialize sync manager
     * @returns Promise resolving to initialization success
     */
    async initialize() {
        try {
            // Check if primary adapter is connected
            if (!this.primaryAdapter.isConnected) {
                throw new Error('Primary adapter is not connected');
            }
            // Check if metadata manager is initialized
            if (!this.metadataManager) {
                throw new Error('Metadata manager is required');
            }
            // Check if sync operations collection exists
            const exists = await this.primaryAdapter.collectionExists(this.options.syncOperationsCollection);
            if (!exists) {
                // Create sync operations collection
                await this.primaryAdapter.createCollection(this.options.syncOperationsCollection);
            }
            this.isInitialized = true;
            this.log('Sync manager initialized');
            return true;
        }
        catch (error) {
            this.logError('Failed to initialize sync manager', error);
            return false;
        }
    }
    /**
     * Ensure initialized
     * @throws Error if not initialized
     */
    ensureInitialized() {
        if (!this.isInitialized) {
            throw new Error('Sync manager not initialized');
        }
    }
    /**
     * Register secondary adapter
     * @param name - Adapter name
     * @param adapter - Database adapter
     */
    registerAdapter(name, adapter) {
        // Check if adapter is connected
        if (!adapter.isConnected) {
            throw new Error(`Adapter ${name} is not connected`);
        }
        // Register adapter
        this.secondaryAdapters.set(name, adapter);
        this.log(`Registered adapter: ${name}`);
    }
    /**
     * Unregister secondary adapter
     * @param name - Adapter name
     */
    unregisterAdapter(name) {
        // Unregister adapter
        this.secondaryAdapters.delete(name);
        this.log(`Unregistered adapter: ${name}`);
    }
    /**
     * Start sync
     */
    startSync() {
        this.ensureInitialized();
        // Stop existing sync
        this.stopSync();
        // Start sync timer
        this.syncTimer = setInterval(() => {
            this.sync().catch(error => {
                this.logError('Sync error', error);
            });
        }, this.options.syncInterval);
        this.log('Sync started');
    }
    /**
     * Stop sync
     */
    stopSync() {
        if (this.syncTimer) {
            clearInterval(this.syncTimer);
            this.syncTimer = null;
        }
        this.log('Sync stopped');
    }
    /**
     * Sync
     * @returns Promise resolving to sync success
     */
    async sync() {
        this.ensureInitialized();
        // Check if already syncing
        if (this.isSyncing) {
            return false;
        }
        this.isSyncing = true;
        try {
            // Get pending sync operations
            const operations = await this.getPendingSyncOperations();
            if (operations.length === 0) {
                this.isSyncing = false;
                return true;
            }
            // Execute sync operations
            for (const operation of operations) {
                await this.executeSyncOperation(operation);
            }
            this.isSyncing = false;
            return true;
        }
        catch (error) {
            this.isSyncing = false;
            this.logError('Sync failed', error);
            return false;
        }
    }
    /**
     * Get pending sync operations
     * @returns Promise resolving to pending sync operations
     */
    async getPendingSyncOperations() {
        try {
            // Get pending operations
            return await this.primaryAdapter.find(this.options.syncOperationsCollection, { status: 'pending' }, { limit: this.options.batchSize, sort: { createdAt: 1 } });
        }
        catch (error) {
            this.logError('Failed to get pending sync operations', error);
            throw error;
        }
    }
    /**
     * Execute sync operation
     * @param operation - Sync operation
     * @returns Promise resolving to execution success
     */
    async executeSyncOperation(operation) {
        try {
            // Update operation status
            await this.updateSyncOperationStatus(operation.id, 'executing');
            // Get target adapter
            const targetAdapter = this.secondaryAdapters.get(operation.targetAdapter);
            if (!targetAdapter) {
                throw new Error(`Target adapter not found: ${operation.targetAdapter}`);
            }
            // Execute operation
            let success = false;
            switch (operation.type) {
                case SyncOperationType.CREATE:
                    success = await this.executeCreateOperation(targetAdapter, operation);
                    break;
                case SyncOperationType.UPDATE:
                    success = await this.executeUpdateOperation(targetAdapter, operation);
                    break;
                case SyncOperationType.DELETE:
                    success = await this.executeDeleteOperation(targetAdapter, operation);
                    break;
                case SyncOperationType.BATCH:
                    success = await this.executeBatchOperation(targetAdapter, operation);
                    break;
                default:
                    throw new Error(`Unknown operation type: ${operation.type}`);
            }
            // Update operation status
            if (success) {
                await this.updateSyncOperationStatus(operation.id, 'completed');
            }
            else {
                await this.updateSyncOperationStatus(operation.id, 'failed');
            }
            return success;
        }
        catch (error) {
            // Update operation status
            await this.updateSyncOperationStatus(operation.id, 'failed', error);
            this.logError(`Failed to execute sync operation: ${operation.id}`, error);
            return false;
        }
    }
    /**
     * Execute create operation
     * @param adapter - Target adapter
     * @param operation - Sync operation
     * @returns Promise resolving to execution success
     */
    async executeCreateOperation(adapter, operation) {
        try {
            // Check if entity exists
            const exists = await adapter.findById(operation.collection, operation.entityId);
            if (exists) {
                // Entity already exists, update instead
                await adapter.updateById(operation.collection, operation.entityId, operation.data);
            }
            else {
                // Create entity
                await adapter.insert(operation.collection, operation.data);
            }
            return true;
        }
        catch (error) {
            this.logError(`Failed to execute create operation: ${operation.id}`, error);
            throw error;
        }
    }
    /**
     * Execute update operation
     * @param adapter - Target adapter
     * @param operation - Sync operation
     * @returns Promise resolving to execution success
     */
    async executeUpdateOperation(adapter, operation) {
        try {
            // Check if entity exists
            const exists = await adapter.findById(operation.collection, operation.entityId);
            if (!exists) {
                // Entity doesn't exist, create instead
                await adapter.insert(operation.collection, operation.data);
            }
            else {
                // Update entity
                await adapter.updateById(operation.collection, operation.entityId, operation.data);
            }
            return true;
        }
        catch (error) {
            this.logError(`Failed to execute update operation: ${operation.id}`, error);
            throw error;
        }
    }
    /**
     * Execute delete operation
     * @param adapter - Target adapter
     * @param operation - Sync operation
     * @returns Promise resolving to execution success
     */
    async executeDeleteOperation(adapter, operation) {
        try {
            // Delete entity
            await adapter.deleteById(operation.collection, operation.entityId);
            return true;
        }
        catch (error) {
            this.logError(`Failed to execute delete operation: ${operation.id}`, error);
            throw error;
        }
    }
    /**
     * Execute batch operation
     * @param adapter - Target adapter
     * @param operation - Sync operation
     * @returns Promise resolving to execution success
     */
    async executeBatchOperation(adapter, operation) {
        try {
            // Execute batch operations
            for (const batchOperation of operation.batchOperations || []) {
                // Execute operation
                let success = false;
                switch (batchOperation.type) {
                    case SyncOperationType.CREATE:
                        success = await this.executeCreateOperation(adapter, batchOperation);
                        break;
                    case SyncOperationType.UPDATE:
                        success = await this.executeUpdateOperation(adapter, batchOperation);
                        break;
                    case SyncOperationType.DELETE:
                        success = await this.executeDeleteOperation(adapter, batchOperation);
                        break;
                    default:
                        throw new Error(`Unknown operation type: ${batchOperation.type}`);
                }
                if (!success) {
                    return false;
                }
            }
            return true;
        }
        catch (error) {
            this.logError(`Failed to execute batch operation: ${operation.id}`, error);
            throw error;
        }
    }
    /**
     * Update sync operation status
     * @param operationId - Operation ID
     * @param status - Operation status
     * @param error - Operation error
     */
    async updateSyncOperationStatus(operationId, status, error) {
        try {
            // Update operation
            await this.primaryAdapter.updateById(this.options.syncOperationsCollection, operationId, {
                status,
                executedAt: status === 'completed' || status === 'failed' ? new Date() : undefined,
                error: error ? error.toString() : undefined
            });
        }
        catch (error) {
            this.logError(`Failed to update sync operation status: ${operationId}`, error);
            throw error;
        }
    }
    /**
     * Create sync operation
     * @param type - Operation type
     * @param sourceAdapter - Source adapter
     * @param targetAdapter - Target adapter
     * @param collection - Collection name
     * @param entityId - Entity ID
     * @param data - Entity data
     * @param batchOperations - Batch operations
     * @returns Promise resolving to operation ID
     */ async createSyncOperation(type, sourceAdapter, targetAdapter, collection, entityId, data, batchOperations) {
        this.ensureInitialized();
        try {
            // Create operation
            const operation = {
                id: this.generateId(),
                type,
                sourceAdapter,
                targetAdapter,
                collection,
                entityId,
                data,
                batchOperations,
                createdAt: new Date(),
                status: 'pending'
            };
            // Insert operation
            await this.primaryAdapter.insert(this.options.syncOperationsCollection, operation);
            // Emit event
            this.emit('operation-created', operation);
            return operation.id;
        }
        catch (error) {
            this.logError('Failed to create sync operation', error);
            throw error;
        }
    }
    /**
     * Create entity
     * @param sourceAdapter - Source adapter
     * @param targetAdapter - Target adapter
     * @param collection - Collection name
     * @param entity - Entity
     * @returns Promise resolving to operation ID
     */
    async createEntity(sourceAdapter, targetAdapter, collection, entity) {
        return this.createSyncOperation(SyncOperationType.CREATE, sourceAdapter, targetAdapter, collection, entity.id, entity);
    }
    /**
     * Update entity
     * @param sourceAdapter - Source adapter
     * @param targetAdapter - Target adapter
     * @param collection - Collection name
     * @param entity - Entity
     * @returns Promise resolving to operation ID
     */
    async updateEntity(sourceAdapter, targetAdapter, collection, entity) {
        return this.createSyncOperation(SyncOperationType.UPDATE, sourceAdapter, targetAdapter, collection, entity.id, entity);
    }
    /**
     * Delete entity
     * @param sourceAdapter - Source adapter
     * @param targetAdapter - Target adapter
     * @param collection - Collection name
     * @param entityId - Entity ID
     * @returns Promise resolving to operation ID
     */
    async deleteEntity(sourceAdapter, targetAdapter, collection, entityId) {
        return this.createSyncOperation(SyncOperationType.DELETE, sourceAdapter, targetAdapter, collection, entityId);
    }
    /**
     * Batch operations
     * @param sourceAdapter - Source adapter
     * @param targetAdapter - Target adapter
     * @param collection - Collection name
     * @param operations - Batch operations
     * @returns Promise resolving to operation ID
     */
    async batchOperations(sourceAdapter, targetAdapter, collection, operations) {
        return this.createSyncOperation(SyncOperationType.BATCH, sourceAdapter, targetAdapter, collection, undefined, undefined, operations);
    }
    /**
     * Generate ID
     * @returns Generated ID
     */
    generateId() {
        return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[SyncManager] ${message}`);
        }
    }
    /**
     * Log error
     * @param message - Error message
     * @param error - Error object
     */
    logError(message, error) {
        console.error(`[SyncManager] ${message}`, error);
    }
}
export default SyncManager;
