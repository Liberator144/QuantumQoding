"use strict";
/**
 * Touch Interaction System
 *
 * This module provides advanced touch interaction capabilities
 * for mobile devices.
 *
 * @version 1.0.0
 */
const { EventEmitter } = require('events');
const { FeedbackProvider } = require('./FeedbackProvider');
/**
 * Touch Interaction System
 * Main class for managing touch interactions
 */
class TouchInteractionSystem extends EventEmitter {
    /**
     * Create a new TouchInteractionSystem instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        this.options = {
            // Enable gesture recognition
            enableGestures: true,
            // Enable multi-touch support
            enableMultiTouch: true,
            // Enable haptic feedback
            enableHapticFeedback: true,
            // Enable visual feedback
            enableVisualFeedback: true,
            // Debug mode
            debugMode: false,
            // Gesture options
            gestures: {
                // Tap options
                tap: {
                    maxDuration: 300, // Maximum duration in milliseconds
                    maxDistance: 10, // Maximum distance in pixels
                },
                // Double tap options
                doubleTap: {
                    maxDuration: 300, // Maximum duration in milliseconds
                    maxDistance: 10, // Maximum distance in pixels
                    maxInterval: 300, // Maximum interval between taps in milliseconds
                },
                // Long press options
                longPress: {
                    minDuration: 500, // Minimum duration in milliseconds
                    maxDistance: 10, // Maximum distance in pixels
                },
                // Swipe options
                swipe: {
                    minDistance: 50, // Minimum distance in pixels
                    maxDuration: 300, // Maximum duration in milliseconds
                    directionTolerance: 30, // Direction tolerance in degrees
                },
                // Pinch options
                pinch: {
                    minScale: 0.5, // Minimum scale
                    maxScale: 2.0, // Maximum scale
                },
                // Rotate options
                rotate: {
                    minRotation: 15, // Minimum rotation in degrees
                },
            },
            ...options,
        };
        // Initialize components
        this.gestureRecognizer = new GestureRecognizer({
            ...this.options,
            debugMode: this.options.debugMode,
        });
        this.feedbackProvider = new FeedbackProvider({
            ...this.options,
            debugMode: this.options.debugMode,
        });
        // Initialize state
        this.activeElements = new Map();
        this.isInitialized = false;
        // Log initialization
        this.log('Touch Interaction System created');
    }
    /**
     * Initialize the touch interaction system
     * @returns {Promise<void>}
     */
    async initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            this.log('Initializing Touch Interaction System');
            // Initialize gesture recognizer
            if (this.options.enableGestures) {
                await this.gestureRecognizer.initialize();
            }
            // Initialize feedback provider
            if (this.options.enableHapticFeedback || this.options.enableVisualFeedback) {
                await this.feedbackProvider.initialize();
            }
            // Connect event handlers
            this._connectEventHandlers();
            this.isInitialized = true;
            this.log('Touch Interaction System initialized');
            this.emit('system:initialized');
        }
        catch (error) {
            this.log(`Error initializing Touch Interaction System: ${error.message}`);
            this.emit('system:error', error);
            throw error;
        }
    }
    /**
     * Connect event handlers
     * @private
     */
    _connectEventHandlers() {
        // Connect gesture recognizer events
        if (this.options.enableGestures) {
            this.gestureRecognizer.on('gesture:recognized', (gesture, event) => {
                this.log(`Gesture recognized: ${gesture.type}`);
                // Provide feedback
                if (this.options.enableHapticFeedback || this.options.enableVisualFeedback) {
                    this.feedbackProvider.provideFeedback(gesture.type, event.target);
                }
                // Emit gesture event
                this.emit('gesture:recognized', gesture, event);
                // Emit specific gesture event
                this.emit(`gesture:${gesture.type}`, gesture, event);
            });
        }
    }
    /**
     * Register an element for touch interactions
     * @param {HTMLElement} element - Element to register
     * @param {Object} options - Touch options
     * @returns {Promise<Object>} Registration result
     */
    async registerElement(element, options = {}) {
        try {
            // Check if system is initialized
            if (!this.isInitialized) {
                await this.initialize();
            }
            this.log('Registering element for touch interactions');
            // Generate element ID
            const elementId = this._generateElementId(element);
            // Register with gesture recognizer
            let gestureResult = null;
            if (this.options.enableGestures) {
                gestureResult = await this.gestureRecognizer.registerElement(element, options.gestures);
            }
            // Register with feedback provider
            let feedbackResult = null;
            if (this.options.enableHapticFeedback || this.options.enableVisualFeedback) {
                feedbackResult = await this.feedbackProvider.registerElement(element, options.feedback);
            }
            // Store element
            this.activeElements.set(elementId, {
                element,
                options,
                gestureResult,
                feedbackResult,
            });
            this.log(`Element registered with ID: ${elementId}`);
            this.emit('element:registered', element, elementId);
            return {
                elementId,
                gestureResult,
                feedbackResult,
            };
        }
        catch (error) {
            this.log(`Error registering element: ${error.message}`);
            this.emit('element:error', error, element);
            throw error;
        }
    }
    /**
     * Unregister an element
     * @param {HTMLElement|string} elementOrId - Element or element ID
     * @returns {Promise<boolean>} Whether the element was unregistered
     */
    async unregisterElement(elementOrId) {
        try {
            // Get element ID
            const elementId = typeof elementOrId === 'string' ? elementOrId : this._generateElementId(elementOrId);
            // Check if element exists
            if (!this.activeElements.has(elementId)) {
                this.log(`Element not found: ${elementId}`);
                return false;
            }
            // Get element info
            const elementInfo = this.activeElements.get(elementId);
            // Unregister with gesture recognizer
            if (this.options.enableGestures) {
                await this.gestureRecognizer.unregisterElement(elementInfo.element);
            }
            // Unregister with feedback provider
            if (this.options.enableHapticFeedback || this.options.enableVisualFeedback) {
                await this.feedbackProvider.unregisterElement(elementInfo.element);
            }
            // Remove element
            this.activeElements.delete(elementId);
            this.log(`Element unregistered: ${elementId}`);
            this.emit('element:unregistered', elementInfo.element, elementId);
            return true;
        }
        catch (error) {
            this.log(`Error unregistering element: ${error.message}`);
            this.emit('element:error', error, elementOrId);
            throw error;
        }
    }
    /**
     * Get system state
     * @returns {Object} System state
     */
    getState() {
        return {
            initialized: this.isInitialized,
            activeElements: this.activeElements.size,
            enabledGestures: this.options.enableGestures,
            enabledMultiTouch: this.options.enableMultiTouch,
            enabledHapticFeedback: this.options.enableHapticFeedback,
            enabledVisualFeedback: this.options.enableVisualFeedback,
        };
    }
    /**
     * Generate element ID
     * @param {HTMLElement} element - Element
     * @returns {string} Element ID
     * @private
     */
    _generateElementId(element) {
        // Implementation depends on the specific environment (browser, Node.js, etc.)
        // This is a placeholder for the actual implementation
        return `touch-element-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[TouchInteractionSystem] ${message}`);
        }
    }
}
/**
 * Gesture Recognizer
 * Recognizes touch gestures
 */
class GestureRecognizer extends EventEmitter {
    /**
     * Create a new GestureRecognizer instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        this.options = {
            debugMode: false,
            ...options,
        };
        // Initialize state
        this.registeredElements = new Map();
        // Log initialization
        this.log('Gesture Recognizer created');
    }
    /**
     * Initialize the gesture recognizer
     * @returns {Promise<void>}
     */
    async initialize() {
        try {
            this.log('Initializing Gesture Recognizer');
            // Initialize gesture recognition
            // Implementation depends on the specific environment (browser, Node.js, etc.)
            this.log('Gesture Recognizer initialized');
            this.emit('recognizer:initialized');
        }
        catch (error) {
            this.log(`Error initializing Gesture Recognizer: ${error.message}`);
            this.emit('recognizer:error', error);
            throw error;
        }
    }
    /**
     * Register an element for gesture recognition
     * @param {HTMLElement} element - Element to register
     * @param {Object} options - Gesture options
     * @returns {Promise<Object>} Registration result
     */
    async registerElement(element, options = {}) {
        // Implementation depends on the specific environment (browser, Node.js, etc.)
        // This is a placeholder for the actual implementation
        return {
            element,
            gestures: ['tap', 'doubleTap', 'longPress', 'swipe', 'pinch', 'rotate'],
        };
    }
    /**
     * Unregister an element
     * @param {HTMLElement} element - Element to unregister
     * @returns {Promise<boolean>} Whether the element was unregistered
     */
    async unregisterElement(element) {
        // Implementation depends on the specific environment (browser, Node.js, etc.)
        // This is a placeholder for the actual implementation
        return true;
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[GestureRecognizer] ${message}`);
        }
    }
}
module.exports = { TouchInteractionSystem, GestureRecognizer };
