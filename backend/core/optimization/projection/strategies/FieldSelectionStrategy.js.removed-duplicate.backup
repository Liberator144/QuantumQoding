"use strict";
/**
 * Field Selection Strategy
 *
 * Optimizes projections by selecting only necessary fields.
 *
 * @version 1.0.0
 */
const { createProjectionDescriptor, transformProjection } = require('../ProjectionModel');
const { analyzeProjection } = require('../ProjectionAnalysis');
/**
 * Field Selection Strategy
 */
class FieldSelectionStrategy {
    /**
     * Create a new FieldSelectionStrategy instance
     * @param {Object} options - Strategy options
     */
    constructor(options = {}) {
        this.options = {
            // Whether to remove unnecessary fields
            removeUnnecessary: true,
            // Whether to reorder fields for optimal retrieval
            reorderFields: true,
            // Whether to minimize nested projections
            minimizeNested: true,
            // Merge with provided options
            ...options,
        };
    }
    /**
     * Apply the strategy to a projection
     * @param {Object} projection - Projection to optimize
     * @param {Object} context - Optimization context
     * @returns {Object} Optimized projection
     */
    apply(projection, context = {}) {
        // Create projection descriptor
        const descriptor = createProjectionDescriptor(projection);
        // Analyze projection
        const analysis = analyzeProjection(descriptor, context);
        // Apply optimizations
        let optimized = descriptor;
        // Remove unnecessary fields
        if (this.options.removeUnnecessary) {
            optimized = this._removeUnnecessaryFields(optimized, analysis, context);
        }
        // Reorder fields
        if (this.options.reorderFields) {
            optimized = this._reorderFields(optimized, analysis, context);
        }
        // Minimize nested projections
        if (this.options.minimizeNested) {
            optimized = this._minimizeNestedProjections(optimized, analysis, context);
        }
        return optimized;
    }
    /**
     * Remove unnecessary fields from a projection
     * @param {Object} projection - Projection to optimize
     * @param {Object} analysis - Projection analysis
     * @param {Object} context - Optimization context
     * @returns {Object} Optimized projection
     * @private
     */
    _removeUnnecessaryFields(projection, analysis, context) {
        // Get fields to keep
        const fieldsToKeep = this._getFieldsToKeep(analysis, context);
        // Transform projection to keep only necessary fields
        return transformProjection(projection, (field, spec) => {
            if (fieldsToKeep.has(field)) {
                // Keep field
                return spec;
            }
            else {
                // Remove field
                return null;
            }
        });
    }
    /**
     * Get fields to keep
     * @param {Object} analysis - Projection analysis
     * @param {Object} context - Optimization context
     * @returns {Set} Fields to keep
     * @private
     */
    _getFieldsToKeep(analysis, context) {
        const fieldsToKeep = new Set();
        // Always keep ID fields
        for (const field of analysis.fields.includedFields) {
            if (field === 'id' || field === '_id' || field.endsWith('Id') || field.endsWith('_id')) {
                fieldsToKeep.add(field);
            }
        }
        // Keep fields based on usage statistics if available
        if (context.fieldUsageStats) {
            for (const [field, stats] of Object.entries(context.fieldUsageStats)) {
                if (stats.usageFrequency > 0.5) {
                    fieldsToKeep.add(field);
                }
            }
        }
        // Keep fields explicitly requested in context
        if (context.requiredFields) {
            for (const field of context.requiredFields) {
                fieldsToKeep.add(field);
            }
        }
        // If no fields are selected, keep all fields
        if (fieldsToKeep.size === 0) {
            for (const field of analysis.fields.includedFields) {
                fieldsToKeep.add(field);
            }
        }
        return fieldsToKeep;
    }
    /**
     * Reorder fields in a projection
     * @param {Object} projection - Projection to optimize
     * @param {Object} analysis - Projection analysis
     * @param {Object} context - Optimization context
     * @returns {Object} Optimized projection
     * @private
     */
    _reorderFields(projection, analysis, context) {
        // Get field priorities
        const fieldPriorities = this._getFieldPriorities(analysis, context);
        // Create a new projection with reordered fields
        const reordered = {
            _type: 'ProjectionDescriptor',
            _version: '1.0.0',
            fields: {},
            metadata: {
                ...projection.metadata,
                reordered: true,
                reorderedAt: Date.now(),
            },
        };
        // Sort fields by priority
        const sortedFields = [...Object.keys(projection.fields)].sort((a, b) => {
            return (fieldPriorities.get(b) || 0) - (fieldPriorities.get(a) || 0);
        });
        // Add fields in priority order
        for (const field of sortedFields) {
            reordered.fields[field] = projection.fields[field];
        }
        return reordered;
    }
    /**
     * Get field priorities
     * @param {Object} analysis - Projection analysis
     * @param {Object} context - Optimization context
     * @returns {Map} Field priorities
     * @private
     */
    _getFieldPriorities(analysis, context) {
        const priorities = new Map();
        // Set priorities based on field type
        for (const field of analysis.fields.includedFields) {
            // Start with base priority
            let priority = 0;
            // ID fields have highest priority
            if (field === 'id' || field === '_id' || field.endsWith('Id') || field.endsWith('_id')) {
                priority += 1000;
            }
            // Name fields have high priority
            if (field.includes('name') || field.includes('title')) {
                priority += 800;
            }
            // Status and type fields have high priority
            if (field.includes('status') || field.includes('type')) {
                priority += 700;
            }
            // Date and time fields have high priority
            if (field.includes('date') || field.includes('time')) {
                priority += 600;
            }
            // Count and total fields have medium-high priority
            if (field.includes('count') || field.includes('total')) {
                priority += 500;
            }
            // Description and content fields have medium priority
            if (field.includes('description') || field.includes('content')) {
                priority += 300;
            }
            // Image and file fields have lower priority
            if (field.includes('image') || field.includes('file')) {
                priority += 100;
            }
            // Set priority
            priorities.set(field, priority);
        }
        // Adjust priorities based on usage statistics if available
        if (context.fieldUsageStats) {
            for (const [field, stats] of Object.entries(context.fieldUsageStats)) {
                if (priorities.has(field)) {
                    priorities.set(field, priorities.get(field) + stats.usageFrequency * 500);
                }
            }
        }
        return priorities;
    }
    /**
     * Minimize nested projections
     * @param {Object} projection - Projection to optimize
     * @param {Object} analysis - Projection analysis
     * @param {Object} context - Optimization context
     * @returns {Object} Optimized projection
     * @private
     */
    _minimizeNestedProjections(projection, analysis, context) {
        // Transform projection to minimize nested projections
        return transformProjection(projection, (field, spec) => {
            if (spec.nested) {
                // Apply field selection strategy to nested projection
                const nestedStrategy = new FieldSelectionStrategy(this.options);
                const optimizedNested = nestedStrategy.apply(spec.nested, context);
                return {
                    include: spec.include,
                    nested: optimizedNested,
                };
            }
            return spec;
        });
    }
}
module.exports = { FieldSelectionStrategy };
