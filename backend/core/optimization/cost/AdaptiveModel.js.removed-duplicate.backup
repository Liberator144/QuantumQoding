"use strict";
/**
 * Adaptive Cost Model
 *
 * A cost model that learns from execution history to improve estimates.
 *
 * @version 1.0.0
 */
/**
 * Adaptive Cost Model
 *
 * Uses machine learning techniques to adapt cost estimates based on execution history.
 */
class AdaptiveModel {
    /**
     * Create a new AdaptiveModel instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Base cost model
            baseCostModel: null,
            // Learning rate
            learningRate: 0.1,
            // Anomaly detection threshold
            anomalyThreshold: 0.5,
            // History size
            historySize: 100,
            // Feature extraction
            featureExtraction: {
                enabled: true,
                maxFeatures: 20,
            },
            // Merge with provided options
            ...options,
        };
        // State
        this.state = {
            history: [],
            weights: {},
            features: new Set(),
            initialized: false,
        };
        // Initialize
        this._init();
    }
    /**
     * Initialize the model
     * @private
     */
    _init() {
        this.log('Initializing Adaptive Cost Model');
        // Check if base cost model is provided
        if (!this.config.baseCostModel) {
            throw new Error('Base cost model is required');
        }
        // Initialize weights
        this.state.weights = {
            // Base weight
            base: 1.0,
            // Feature weights
            features: {},
        };
        // Set initialized flag
        this.state.initialized = true;
        this.log('Adaptive Cost Model initialized');
    }
    /**
     * Estimate the cost of a query
     * @param {Object} query - Query to estimate
     * @param {Object} context - Estimation context
     * @returns {Promise<Object>} Cost estimate
     */
    async estimateQueryCost(query, context = {}) {
        try {
            // Get base estimate
            const baseEstimate = await this.config.baseCostModel.estimateQueryCost(query, context);
            // Extract features
            const features = this._extractFeatures(query, context);
            // Apply adaptive adjustment
            const adjustment = this._calculateAdjustment(features);
            // Calculate adjusted cost
            const adjustedCost = baseEstimate.totalCost * adjustment;
            // Create adjusted costs
            const adjustedCosts = {};
            Object.entries(baseEstimate.costs).forEach(([key, cost]) => {
                adjustedCosts[key] = cost * adjustment;
            });
            return {
                totalCost: adjustedCost,
                costs: adjustedCosts,
                baseEstimate,
                adjustment,
                features,
            };
        }
        catch (error) {
            this.log(`Error estimating query cost: ${error.message}`);
            throw error;
        }
    }
    /**
     * Estimate the cost of an execution plan
     * @param {Object} plan - Execution plan to estimate
     * @param {Object} statistics - Statistics for estimation
     * @param {Object} context - Estimation context
     * @returns {Promise<Object>} Cost estimate
     */
    async estimatePlanCost(plan, statistics = {}, context = {}) {
        try {
            // Get base estimate
            const baseEstimate = await this.config.baseCostModel.estimatePlanCost(plan, statistics, context);
            // Extract features
            const features = this._extractFeaturesFromPlan(plan, statistics, context);
            // Apply adaptive adjustment
            const adjustment = this._calculateAdjustment(features);
            // Calculate adjusted cost
            const adjustedCost = baseEstimate.totalCost * adjustment;
            // Create adjusted node costs
            const adjustedNodeCosts = {};
            Object.entries(baseEstimate.nodeCosts).forEach(([key, nodeCost]) => {
                adjustedNodeCosts[key] = {
                    ...nodeCost,
                    cost: nodeCost.cost * adjustment,
                };
            });
            return {
                totalCost: adjustedCost,
                nodeCosts: adjustedNodeCosts,
                baseEstimate,
                adjustment,
                features,
            };
        }
        catch (error) {
            this.log(`Error estimating plan cost: ${error.message}`);
            throw error;
        }
    }
    /**
     * Update the model with actual metrics
     * @param {Object} plan - Execution plan
     * @param {Object} actualMetrics - Actual execution metrics
     * @param {Object} context - Update context
     * @returns {Promise<boolean>} Success
     */
    async update(plan, actualMetrics, context = {}) {
        try {
            // Get estimated metrics
            let estimatedMetrics;
            try {
                estimatedMetrics = await this.estimatePlanCost(plan, context.statistics || {}, context);
            }
            catch (error) {
                this.log(`Error getting estimated metrics: ${error.message}`);
                return false;
            }
            // Calculate error
            const error = this._calculateError(actualMetrics, estimatedMetrics);
            // Check for anomalies
            if (context.enableAnomalyDetection && Math.abs(error.totalError) > context.anomalyThreshold) {
                this.log(`Anomaly detected: error ${error.totalError.toFixed(2)} exceeds threshold ${context.anomalyThreshold}`);
                // Don't update the model with anomalous data
                return false;
            }
            // Extract features
            const features = estimatedMetrics.features;
            // Update weights
            this._updateWeights(features, error.totalError, context.learningRate || this.config.learningRate);
            // Add to history
            this._addToHistory({
                plan,
                actualMetrics,
                estimatedMetrics,
                error,
                features,
                timestamp: Date.now(),
            });
            this.log(`Updated adaptive model with error: ${error.totalError.toFixed(4)}`);
            return true;
        }
        catch (error) {
            this.log(`Error updating adaptive model: ${error.message}`);
            return false;
        }
    }
    /**
     * Extract features from a query
     * @param {Object} query - Query to extract features from
     * @param {Object} context - Extraction context
     * @returns {Object} Features
     * @private
     */
    _extractFeatures(query, context = {}) {
        const features = {};
        // Extract basic features
        if (typeof query === 'object') {
            // Collection
            if (query.collection || query.from) {
                features[`collection:${query.collection || query.from}`] = 1;
            }
            // Filter
            if (query.filter || query.where) {
                features['has:filter'] = 1;
                const filter = query.filter || query.where;
                if (typeof filter === 'object') {
                    // Count filter fields
                    features['filter:fieldCount'] = Object.keys(filter).length;
                    // Extract filter fields
                    Object.keys(filter).forEach(field => {
                        features[`filter:field:${field}`] = 1;
                    });
                }
            }
            // Join
            if (query.join) {
                features['has:join'] = 1;
                if (Array.isArray(query.join)) {
                    // Count join collections
                    features['join:collectionCount'] = query.join.length;
                }
                else if (typeof query.join === 'object') {
                    // Count join collections
                    features['join:collectionCount'] = Object.keys(query.join).length;
                    // Join type
                    if (query.join.type) {
                        features[`join:type:${query.join.type}`] = 1;
                    }
                }
            }
            // Sort
            if (query.sort || query.orderBy) {
                features['has:sort'] = 1;
                const sort = query.sort || query.orderBy;
                if (Array.isArray(sort)) {
                    // Count sort fields
                    features['sort:fieldCount'] = sort.length;
                }
                else if (typeof sort === 'object') {
                    // Count sort fields
                    features['sort:fieldCount'] = Object.keys(sort).length;
                }
                // Sort type
                if (query.externalSort) {
                    features['sort:type:external'] = 1;
                }
                else {
                    features['sort:type:inMemory'] = 1;
                }
            }
            // Projection
            if (query.project || query.select) {
                features['has:project'] = 1;
                const project = query.project || query.select;
                if (Array.isArray(project)) {
                    // Count project fields
                    features['project:fieldCount'] = project.length;
                }
                else if (typeof project === 'object') {
                    // Count project fields
                    features['project:fieldCount'] = Object.keys(project).length;
                }
            }
        }
        // Extract context features
        if (typeof context === 'object') {
            // Row count
            if (context.rowCount) {
                features['context:rowCount'] = Math.log10(Math.max(1, context.rowCount));
            }
            // Index type
            if (context.indexType) {
                features[`context:indexType:${context.indexType}`] = 1;
            }
            // Memory type
            if (context.memoryType) {
                features[`context:memoryType:${context.memoryType}`] = 1;
            }
        }
        // Add features to feature set
        Object.keys(features).forEach(feature => {
            this.state.features.add(feature);
        });
        // Limit feature set size
        if (this.state.features.size > this.config.featureExtraction.maxFeatures) {
            // Remove least important features
            const featureArray = Array.from(this.state.features);
            const featureWeights = featureArray.map(feature => Math.abs(this.state.weights.features[feature] || 0));
            // Sort features by weight
            const sortedFeatures = featureArray
                .map((feature, index) => ({ feature, weight: featureWeights[index] }))
                .sort((a, b) => b.weight - a.weight);
            // Keep only the most important features
            this.state.features = new Set(sortedFeatures.slice(0, this.config.featureExtraction.maxFeatures).map(item => item.feature));
        }
        return features;
    }
    /**
     * Extract features from an execution plan
     * @param {Object} plan - Execution plan to extract features from
     * @param {Object} statistics - Statistics for extraction
     * @param {Object} context - Extraction context
     * @returns {Object} Features
     * @private
     */
    _extractFeaturesFromPlan(plan, statistics = {}, context = {}) {
        const features = {};
        // Extract basic features
        if (plan.nodes && Array.isArray(plan.nodes)) {
            // Count nodes
            features['plan:nodeCount'] = plan.nodes.length;
            // Extract node features
            plan.nodes.forEach((node, index) => {
                // Node type
                if (node.type) {
                    features[`node:type:${node.type}`] = (features[`node:type:${node.type}`] || 0) + 1;
                }
                // Collection
                if (node.collection) {
                    features[`node:collection:${node.collection}`] =
                        (features[`node:collection:${node.collection}`] || 0) + 1;
                }
                // Row count
                if (node.rowCount) {
                    features[`node:rowCount:${index}`] = Math.log10(Math.max(1, node.rowCount));
                }
                // Index type
                if (node.indexType) {
                    features[`node:indexType:${node.indexType}`] =
                        (features[`node:indexType:${node.indexType}`] || 0) + 1;
                }
                // Memory type
                if (node.memoryType) {
                    features[`node:memoryType:${node.memoryType}`] =
                        (features[`node:memoryType:${node.memoryType}`] || 0) + 1;
                }
                // Child nodes
                if (node.children && Array.isArray(node.children)) {
                    features[`node:childCount:${index}`] = node.children.length;
                }
            });
        }
        // Extract statistics features
        if (statistics.rowCounts) {
            Object.entries(statistics.rowCounts).forEach(([collection, rowCount]) => {
                features[`stats:rowCount:${collection}`] = Math.log10(Math.max(1, rowCount));
            });
        }
        // Extract context features
        if (typeof context === 'object') {
            // Memory limit
            if (context.memoryLimit) {
                features['context:memoryLimit'] = Math.log10(Math.max(1, context.memoryLimit));
            }
            // Concurrency
            if (context.concurrency) {
                features['context:concurrency'] = context.concurrency;
            }
        }
        // Add features to feature set
        Object.keys(features).forEach(feature => {
            this.state.features.add(feature);
        });
        // Limit feature set size
        if (this.state.features.size > this.config.featureExtraction.maxFeatures) {
            // Remove least important features
            const featureArray = Array.from(this.state.features);
            const featureWeights = featureArray.map(feature => Math.abs(this.state.weights.features[feature] || 0));
            // Sort features by weight
            const sortedFeatures = featureArray
                .map((feature, index) => ({ feature, weight: featureWeights[index] }))
                .sort((a, b) => b.weight - a.weight);
            // Keep only the most important features
            this.state.features = new Set(sortedFeatures.slice(0, this.config.featureExtraction.maxFeatures).map(item => item.feature));
        }
        return features;
    }
    /**
     * Calculate adjustment factor based on features
     * @param {Object} features - Features
     * @returns {number} Adjustment factor
     * @private
     */
    _calculateAdjustment(features) {
        // Start with base weight
        let adjustment = this.state.weights.base;
        // Apply feature weights
        Object.entries(features).forEach(([feature, value]) => {
            const weight = this.state.weights.features[feature] || 0;
            adjustment += weight * value;
        });
        // Ensure adjustment is positive
        return Math.max(0.1, adjustment);
    }
    /**
     * Calculate error between actual and estimated metrics
     * @param {Object} actualMetrics - Actual metrics
     * @param {Object} estimatedMetrics - Estimated metrics
     * @returns {Object} Error metrics
     * @private
     */
    _calculateError(actualMetrics, estimatedMetrics) {
        // Calculate total error
        const totalError = (actualMetrics.totalCost - estimatedMetrics.totalCost) / Math.max(1, actualMetrics.totalCost);
        // Calculate node errors
        const nodeErrors = {};
        if (actualMetrics.nodeCosts && estimatedMetrics.nodeCosts) {
            Object.keys(actualMetrics.nodeCosts).forEach(nodeKey => {
                if (estimatedMetrics.nodeCosts[nodeKey]) {
                    const actualCost = actualMetrics.nodeCosts[nodeKey].cost;
                    const estimatedCost = estimatedMetrics.nodeCosts[nodeKey].cost;
                    const error = (actualCost - estimatedCost) / Math.max(1, actualCost);
                    nodeErrors[nodeKey] = error;
                }
            });
        }
        return {
            totalError,
            nodeErrors,
        };
    }
    /**
     * Update weights based on error
     * @param {Object} features - Features
     * @param {number} error - Error value
     * @param {number} learningRate - Learning rate
     * @private
     */
    _updateWeights(features, error, learningRate) {
        // Update base weight
        this.state.weights.base -= error * learningRate;
        // Update feature weights
        Object.entries(features).forEach(([feature, value]) => {
            // Get current weight
            const currentWeight = this.state.weights.features[feature] || 0;
            // Calculate adjustment
            const adjustment = -error * value * learningRate;
            // Update weight
            this.state.weights.features[feature] = currentWeight + adjustment;
        });
    }
    /**
     * Add an entry to the history
     * @param {Object} entry - History entry
     * @private
     */
    _addToHistory(entry) {
        // Add to history
        this.state.history.push(entry);
        // Limit history size
        if (this.state.history.length > this.config.historySize) {
            this.state.history.shift();
        }
    }
    /**
     * Get optimization history
     * @param {number} limit - Maximum number of entries to return
     * @returns {Array} History entries
     */
    getHistory(limit = this.config.historySize) {
        return this.state.history.slice(-limit);
    }
    /**
     * Clear optimization history
     * @returns {AdaptiveModel} This instance for chaining
     */
    clearHistory() {
        this.state.history = [];
        this.log('Cleared optimization history');
        return this;
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[AdaptiveModel] ${message}`);
        }
    }
}
module.exports = { AdaptiveModel };
