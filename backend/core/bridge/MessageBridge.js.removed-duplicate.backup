"use strict";
/**
 * MessageBridge
 *
 * The MessageBridge provides advanced context transfer capabilities for preserving
 * and transferring context between different modes and systems.
 *
 * @version 1.0.0
 */
const { EventEmitter } = require('events');
/**
 * MessageContext interface
 * @typedef {Object} MessageContext
 * @property {string} id - Message ID
 * @property {any} content - Message content
 * @property {Object} metadata - Message metadata
 * @property {string} metadata.sourceWindow - Source window ID
 * @property {number} metadata.timestamp - Timestamp
 * @property {string} metadata.mode - Mode ('CHAT' or 'AGENT')
 * @property {string[]} metadata.contextChain - Context chain
 * @property {Object} [quantum] - Quantum state
 * @property {any} [quantum.state] - Quantum state data
 * @property {number} [quantum.coherence] - Quantum coherence level
 */
/**
 * MessageBridge class
 *
 * Provides advanced context transfer capabilities for preserving and transferring
 * context between different modes and systems.
 */
class MessageBridge extends EventEmitter {
    /**
     * Create a new MessageBridge instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        super();
        // Configuration
        this.config = {
            // Debug mode
            debugMode: options.debugMode || false,
            // Neural fabric reference
            neuralFabric: options.neuralFabric || null,
            // Dimensional gateway reference
            dimensionalGateway: options.dimensionalGateway || null,
            // Context store capacity
            contextStoreCapacity: options.contextStoreCapacity || 1000,
            // Context expiration time in milliseconds (0 = no expiration)
            contextExpiration: options.contextExpiration || 3600000, // 1 hour
            // Whether to enhance context with quantum state
            enhanceContext: options.enhanceContext !== undefined ? options.enhanceContext : true,
            // Whether to broadcast context changes
            broadcastChanges: options.broadcastChanges !== undefined ? options.broadcastChanges : true,
        };
        // State
        this.state = {
            // Context store
            contextStore: new Map(),
            // Bridge status
            status: 'initializing', // 'initializing', 'active', 'degraded', 'offline'
            // Bridge statistics
            stats: {
                // Total contexts preserved
                contextsPreserved: 0,
                // Total contexts retrieved
                contextsRetrieved: 0,
                // Total contexts transferred
                contextsTransferred: 0,
                // Total contexts expired
                contextsExpired: 0,
                // Total broadcasts
                broadcasts: 0,
                // Total errors
                errors: 0,
            },
        };
        // Initialize
        this._initialize();
    }
    /**
     * Initialize the message bridge
     * @private
     */
    _initialize() {
        // Set up context cleanup interval if expiration is enabled
        if (this.config.contextExpiration > 0) {
            this._cleanupInterval = setInterval(() => {
                this._cleanupExpiredContexts();
            }, Math.min(this.config.contextExpiration / 2, 60000)); // At most every minute
        }
        // Set status to active
        this.state.status = 'active';
        // Log initialization
        this.log('Message bridge initialized');
        // Emit initialized event
        this.emit('initialized');
    }
    /**
     * Preserve context
     * @param {string} messageId - Message ID
     * @param {MessageContext} context - Message context
     * @returns {Promise<void>}
     */
    async preserveContext(messageId, context) {
        try {
            // Validate message ID
            if (!messageId) {
                throw new Error('Invalid message ID');
            }
            // Validate context
            if (!context || typeof context !== 'object') {
                throw new Error('Invalid context');
            }
            // Start with a copy of the context
            let enhancedContext = { ...context };
            // Only add quantum property if enhanceContext is enabled or if it already exists in the context
            if (this.config.enhanceContext || context.quantum) {
                // Initialize quantum property if it doesn't exist
                enhancedContext.quantum = context.quantum || {
                    state: null,
                    coherence: 0.5,
                };
                // Process through neural fabric if available
                if (this.config.enhanceContext && this.config.neuralFabric) {
                    try {
                        // Process context through neural fabric
                        const processedData = await this.config.neuralFabric.process(context);
                        // Update quantum state in context
                        enhancedContext.quantum = {
                            state: processedData,
                            coherence: 1.0,
                        };
                        this.log(`Enhanced context for message: ${messageId}`);
                    }
                    catch (error) {
                        this.log(`Error enhancing context: ${error.message}`);
                        // Keep the default quantum state we initialized above
                    }
                }
            }
            // Add timestamp if not present
            if (!enhancedContext.metadata?.timestamp) {
                enhancedContext = {
                    ...enhancedContext,
                    metadata: {
                        ...(enhancedContext.metadata || {}),
                        timestamp: Date.now(),
                    },
                };
            }
            // Store context
            this.state.contextStore.set(messageId, {
                context: enhancedContext,
                storedAt: Date.now(),
                expiresAt: this.config.contextExpiration > 0 ? Date.now() + this.config.contextExpiration : 0,
            });
            // Update statistics
            this.state.stats.contextsPreserved++;
            // Log context preservation
            this.log(`Preserved context for message: ${messageId}`);
            // Broadcast context if enabled
            if (this.config.broadcastChanges && this.config.dimensionalGateway) {
                try {
                    await this._broadcastContext(messageId, enhancedContext);
                }
                catch (error) {
                    this.log(`Error broadcasting context: ${error.message}`);
                }
            }
            // Emit preserved event
            this.emit('context:preserved', { messageId, context: enhancedContext });
            // Trim context store if needed
            if (this.state.contextStore.size > this.config.contextStoreCapacity) {
                this._trimContextStore();
            }
        }
        catch (error) {
            // Update statistics
            this.state.stats.errors++;
            // Log error
            this.log(`Error preserving context: ${error.message}`);
            // Emit error event
            this.emit('error', {
                operation: 'preserveContext',
                messageId,
                error,
            });
            // Rethrow error
            throw error;
        }
    }
    /**
     * Retrieve context
     * @param {string} messageId - Message ID
     * @returns {Promise<MessageContext|null>} Message context or null if not found
     */
    async retrieveContext(messageId) {
        try {
            // Validate message ID
            if (!messageId) {
                throw new Error('Invalid message ID');
            }
            // Check local context store
            const storedContext = this.state.contextStore.get(messageId);
            if (storedContext) {
                // Update statistics
                this.state.stats.contextsRetrieved++;
                // Log context retrieval
                this.log(`Retrieved context for message: ${messageId} (local)`);
                // Emit retrieved event
                this.emit('context:retrieved', {
                    messageId,
                    context: storedContext.context,
                    source: 'local',
                });
                return storedContext.context;
            }
            // Try to fetch from dimensional gateway if available
            if (this.config.dimensionalGateway) {
                try {
                    const bridgeContext = await this._fetchFromGateway(messageId);
                    if (bridgeContext) {
                        // Store fetched context
                        await this.preserveContext(messageId, bridgeContext);
                        // Update statistics
                        this.state.stats.contextsRetrieved++;
                        // Log context retrieval
                        this.log(`Retrieved context for message: ${messageId} (gateway)`);
                        // Emit retrieved event
                        this.emit('context:retrieved', {
                            messageId,
                            context: bridgeContext,
                            source: 'gateway',
                        });
                        return bridgeContext;
                    }
                }
                catch (error) {
                    this.log(`Error fetching context from gateway: ${error.message}`);
                }
            }
            // Context not found
            this.log(`Context not found for message: ${messageId}`);
            return null;
        }
        catch (error) {
            // Update statistics
            this.state.stats.errors++;
            // Log error
            this.log(`Error retrieving context: ${error.message}`);
            // Emit error event
            this.emit('error', {
                operation: 'retrieveContext',
                messageId,
                error,
            });
            // Rethrow error
            throw error;
        }
    }
    /**
     * Transfer context to agent mode
     * @param {string} messageId - Message ID
     * @returns {Promise<boolean>} Whether the transfer was successful
     */
    async transferToAgent(messageId) {
        return this.transferContext(messageId, 'AGENT');
    }
    /**
     * Transfer context to chat mode
     * @param {string} messageId - Message ID
     * @returns {Promise<boolean>} Whether the transfer was successful
     */
    async transferToChat(messageId) {
        return this.transferContext(messageId, 'CHAT');
    }
    /**
     * Transfer context to a specific mode
     * @param {string} messageId - Message ID
     * @param {string} targetMode - Target mode ('CHAT' or 'AGENT')
     * @returns {Promise<boolean>} Whether the transfer was successful
     */
    async transferContext(messageId, targetMode) {
        try {
            // Validate message ID
            if (!messageId) {
                throw new Error('Invalid message ID');
            }
            // Validate target mode
            if (targetMode !== 'CHAT' && targetMode !== 'AGENT') {
                throw new Error('Invalid target mode');
            }
            // Retrieve context
            const context = await this.retrieveContext(messageId);
            if (!context) {
                this.log(`Cannot transfer context: Context not found for message: ${messageId}`);
                return false;
            }
            // Update mode in context
            const updatedContext = {
                ...context,
                metadata: {
                    ...(context.metadata || {}),
                    mode: targetMode,
                    // Ensure mode is set in both places for backward compatibility
                    MODE: targetMode,
                },
            };
            // Ensure quantum property is preserved if it exists
            if (context.quantum) {
                updatedContext.quantum = { ...context.quantum };
            }
            // Preserve updated context
            await this.preserveContext(messageId, updatedContext);
            // Update statistics
            this.state.stats.contextsTransferred++;
            // Log context transfer
            this.log(`Transferred context for message: ${messageId} to mode: ${targetMode}`);
            // Emit transferred event
            this.emit('context:transferred', {
                messageId,
                context: updatedContext,
                targetMode,
            });
            return true;
        }
        catch (error) {
            // Update statistics
            this.state.stats.errors++;
            // Log error
            this.log(`Error transferring context: ${error.message}`);
            // Emit error event
            this.emit('error', {
                operation: 'transferContext',
                messageId,
                targetMode,
                error,
            });
            return false;
        }
    }
    /**
     * Get bridge state
     * @returns {Object} Bridge state
     */
    getState() {
        return {
            status: this.state.status,
            contextCount: this.state.contextStore.size,
            stats: { ...this.state.stats },
        };
    }
    /**
     * Broadcast context through dimensional gateway
     * @param {string} messageId - Message ID
     * @param {MessageContext} context - Message context
     * @returns {Promise<void>}
     * @private
     */
    async _broadcastContext(messageId, context) {
        if (!this.config.dimensionalGateway) {
            return;
        }
        try {
            // Broadcast through dimensional gateway
            await this.config.dimensionalGateway.broadcast(messageId, context);
            // Update statistics
            this.state.stats.broadcasts++;
            // Log broadcast
            this.log(`Broadcast context for message: ${messageId}`);
        }
        catch (error) {
            this.log(`Error broadcasting context: ${error.message}`);
            throw error;
        }
    }
    /**
     * Fetch context from dimensional gateway
     * @param {string} messageId - Message ID
     * @returns {Promise<MessageContext|null>} Message context or null if not found
     * @private
     */
    async _fetchFromGateway(messageId) {
        if (!this.config.dimensionalGateway) {
            return null;
        }
        try {
            // Fetch from dimensional gateway
            const context = await this.config.dimensionalGateway.fetch(messageId);
            // Log fetch
            if (context) {
                this.log(`Fetched context for message: ${messageId} from gateway`);
            }
            else {
                this.log(`Context not found in gateway for message: ${messageId}`);
            }
            return context;
        }
        catch (error) {
            this.log(`Error fetching context from gateway: ${error.message}`);
            return null;
        }
    }
    /**
     * Clean up expired contexts
     * @private
     */
    _cleanupExpiredContexts() {
        if (this.config.contextExpiration <= 0) {
            return;
        }
        const now = Date.now();
        let expiredCount = 0;
        // Find expired contexts
        for (const [messageId, storedContext] of this.state.contextStore.entries()) {
            if (storedContext.expiresAt > 0 && storedContext.expiresAt <= now) {
                // Remove expired context
                this.state.contextStore.delete(messageId);
                expiredCount++;
            }
        }
        if (expiredCount > 0) {
            // Update statistics
            this.state.stats.contextsExpired += expiredCount;
            // Log cleanup
            this.log(`Cleaned up ${expiredCount} expired contexts`);
        }
    }
    /**
     * Trim context store
     * @private
     */
    _trimContextStore() {
        // Sort contexts by stored time (oldest first)
        const sortedContexts = Array.from(this.state.contextStore.entries()).sort((a, b) => a[1].storedAt - b[1].storedAt);
        // Calculate number of contexts to remove
        const removeCount = Math.ceil(this.state.contextStore.size * 0.2); // Remove 20%
        // Remove oldest contexts
        for (let i = 0; i < removeCount && i < sortedContexts.length; i++) {
            this.state.contextStore.delete(sortedContexts[i][0]);
        }
        // Log trim
        this.log(`Trimmed context store, removed ${removeCount} oldest contexts`);
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[MessageBridge] ${message}`);
        }
    }
    /**
     * Clean up resources
     */
    dispose() {
        // Clear cleanup interval
        if (this._cleanupInterval) {
            clearInterval(this._cleanupInterval);
            this._cleanupInterval = null;
        }
        // Clear context store
        this.state.contextStore.clear();
        // Set status to offline
        this.state.status = 'offline';
        // Log disposal
        this.log('Message bridge disposed');
        // Emit disposed event
        this.emit('disposed');
    }
}
module.exports = { MessageBridge };
