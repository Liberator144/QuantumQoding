"use strict";
/**
 * Schema Validator
 *
 * Validates documents against schemas.
 *
 * @version 1.0.0
 */
/**
 * Schema Validator
 *
 * Validates documents against schemas.
 */
class SchemaValidator {
    /**
     * Create a new SchemaValidator instance
     * @param {Object} options - Configuration options
     */
    constructor(options = {}) {
        // Configuration
        this.config = {
            // Debug mode
            debugMode: false,
            // Strict mode (reject invalid documents)
            strictMode: false,
            // Merge with provided options
            ...options,
        };
        // Initialize
        this._init();
    }
    /**
     * Initialize the validator
     * @private
     */
    _init() {
        this.log('Initializing Schema Validator');
        this.log('Schema Validator initialized');
    }
    /**
     * Validate a document against a schema
     * @param {Object} document - Document to validate
     * @param {Object} schema - Schema
     * @returns {Object} Validation result
     */
    validate(document, schema) {
        if (!document) {
            return {
                valid: false,
                errors: ['Document is required'],
            };
        }
        if (!schema || !schema.schema) {
            return {
                valid: true,
                errors: [],
            };
        }
        // Validate document
        const errors = [];
        try {
            this._validateObject(document, schema.schema, '', errors);
        }
        catch (error) {
            errors.push(error.message);
        }
        return {
            valid: errors.length === 0,
            errors,
        };
    }
    /**
     * Validate an object against a schema
     * @param {Object} obj - Object to validate
     * @param {Object} schema - Schema
     * @param {string} path - Current path
     * @param {Array} errors - Errors array
     * @private
     */
    _validateObject(obj, schema, path, errors) {
        // Check required fields
        if (schema.required && Array.isArray(schema.required)) {
            for (const field of schema.required) {
                if (obj[field] === undefined) {
                    errors.push(`${path ? path + '.' : ''}${field} is required`);
                }
            }
        }
        // Check properties
        if (schema.properties && typeof schema.properties === 'object') {
            for (const [field, fieldSchema] of Object.entries(schema.properties)) {
                const value = obj[field];
                const fieldPath = path ? `${path}.${field}` : field;
                if (value !== undefined) {
                    this._validateValue(value, fieldSchema, fieldPath, errors);
                }
            }
        }
        // Check additional properties
        if (schema.additionalProperties === false) {
            const schemaProperties = schema.properties ? Object.keys(schema.properties) : [];
            for (const field of Object.keys(obj)) {
                if (!schemaProperties.includes(field)) {
                    errors.push(`${path ? path + '.' : ''}${field} is not allowed`);
                }
            }
        }
    }
    /**
     * Validate a value against a schema
     * @param {*} value - Value to validate
     * @param {Object} schema - Schema
     * @param {string} path - Current path
     * @param {Array} errors - Errors array
     * @private
     */
    _validateValue(value, schema, path, errors) {
        // Check type
        if (schema.type) {
            const valid = this._validateType(value, schema.type);
            if (!valid) {
                errors.push(`${path} must be of type ${schema.type}`);
                return;
            }
        }
        // Check enum
        if (schema.enum && Array.isArray(schema.enum)) {
            if (!schema.enum.includes(value)) {
                errors.push(`${path} must be one of: ${schema.enum.join(', ')}`);
            }
        }
        // Check minimum/maximum for numbers
        if (schema.type === 'number' || schema.type === 'integer') {
            if (schema.minimum !== undefined && value < schema.minimum) {
                errors.push(`${path} must be >= ${schema.minimum}`);
            }
            if (schema.maximum !== undefined && value > schema.maximum) {
                errors.push(`${path} must be <= ${schema.maximum}`);
            }
        }
        // Check minLength/maxLength for strings
        if (schema.type === 'string') {
            if (schema.minLength !== undefined && value.length < schema.minLength) {
                errors.push(`${path} must have length >= ${schema.minLength}`);
            }
            if (schema.maxLength !== undefined && value.length > schema.maxLength) {
                errors.push(`${path} must have length <= ${schema.maxLength}`);
            }
            // Check pattern
            if (schema.pattern) {
                const regex = new RegExp(schema.pattern);
                if (!regex.test(value)) {
                    errors.push(`${path} must match pattern: ${schema.pattern}`);
                }
            }
        }
        // Check minItems/maxItems for arrays
        if (schema.type === 'array') {
            if (schema.minItems !== undefined && value.length < schema.minItems) {
                errors.push(`${path} must have >= ${schema.minItems} items`);
            }
            if (schema.maxItems !== undefined && value.length > schema.maxItems) {
                errors.push(`${path} must have <= ${schema.maxItems} items`);
            }
            // Check items
            if (schema.items) {
                for (let i = 0; i < value.length; i++) {
                    this._validateValue(value[i], schema.items, `${path}[${i}]`, errors);
                }
            }
        }
        // Check properties for objects
        if (schema.type === 'object' && typeof value === 'object' && value !== null) {
            this._validateObject(value, schema, path, errors);
        }
    }
    /**
     * Validate a value against a type
     * @param {*} value - Value to validate
     * @param {string} type - Type
     * @returns {boolean} Valid
     * @private
     */
    _validateType(value, type) {
        switch (type) {
            case 'string':
                return typeof value === 'string';
            case 'number':
                return typeof value === 'number' && !isNaN(value);
            case 'integer':
                return typeof value === 'number' && !isNaN(value) && Number.isInteger(value);
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && value !== null && !Array.isArray(value);
            case 'null':
                return value === null;
            default:
                return true;
        }
    }
    /**
     * Log message if debug mode is enabled
     * @param {string} message - Message to log
     * @private
     */
    log(message) {
        if (this.config.debugMode) {
            console.log(`[SchemaValidator] ${message}`);
        }
    }
}
module.exports = { SchemaValidator };
