/**
 * Occlusion Culling System
 *
 * Provides occlusion culling for efficient rendering of complex scenes.
 *
 * @version 1.0.0
 */
import * as THREE from 'three';
/**
 * Occlusion Culling Method
 */
export var OcclusionCullingMethod;
(function (OcclusionCullingMethod) {
    /** Hierarchical Z-Buffer */
    OcclusionCullingMethod["HIERARCHICAL_Z_BUFFER"] = "hierarchical_z_buffer";
    /** Hardware Occlusion Queries */
    OcclusionCullingMethod["HARDWARE_OCCLUSION_QUERIES"] = "hardware_occlusion_queries";
    /** Software Occlusion Culling */
    OcclusionCullingMethod["SOFTWARE_OCCLUSION_CULLING"] = "software_occlusion_culling";
    /** Portal Culling */
    OcclusionCullingMethod["PORTAL_CULLING"] = "portal_culling";
    /** Cell-Portal Culling */
    OcclusionCullingMethod["CELL_PORTAL_CULLING"] = "cell_portal_culling";
})(OcclusionCullingMethod || (OcclusionCullingMethod = {}));
/**
 * Default options
 */
const defaultOptions = {
    method: OcclusionCullingMethod.HIERARCHICAL_Z_BUFFER,
    occlusionThreshold: 0.8,
    depthTextureResolution: 256,
    updateInterval: 100,
    cullSmallObjects: true,
    smallObjectThreshold: 0.01,
    debugMode: false,
}; /**
 * Occlusion data
 */
/**
 * Occlusion Culling System
 */
export class OcclusionCullingSystem {
    /**
     * Constructor
     * @param scene - Scene
     * @param camera - Camera
     * @param renderer - Renderer
     * @param options - Options
     */
    constructor(scene, camera, renderer, options = {}) {
        /** Occlusion renderer */
        this.occlusionRenderer = null;
        /** Occlusion camera */
        this.occlusionCamera = null;
        /** Occlusion render target */
        this.occlusionRenderTarget = null;
        /** Occlusion depth texture */
        this.occlusionDepthTexture = null;
        /** Occlusion depth material */
        this.occlusionDepthMaterial = null;
        /** Occlusion data */
        this.occlusionData = new Map();
        /** Update timer */
        this.updateTimer = null;
        /** Is initialized */
        this.isInitialized = false;
        /** Stats */
        this.stats = {
            totalObjects: 0,
            occludedObjects: 0,
            visibleObjects: 0,
            smallObjects: 0,
            updateTime: 0,
        };
        this.scene = scene;
        this.camera = camera;
        this.renderer = renderer;
        this.options = {
            ...defaultOptions,
            ...options,
        };
        this.log('Occlusion Culling System initialized');
    }
    /**
     * Initialize the occlusion culling system
     */
    initialize() {
        if (this.isInitialized) {
            return;
        }
        // Initialize occlusion culling
        this.initializeOcclusionCulling();
        // Register all objects in the scene
        this.registerSceneObjects();
        // Start update timer
        this.startUpdateTimer();
        // Mark as initialized
        this.isInitialized = true;
        this.log('Occlusion Culling System started');
    }
    /**
     * Initialize occlusion culling
     */
    initializeOcclusionCulling() {
        // Create occlusion renderer
        this.occlusionRenderer = new THREE.WebGLRenderer({
            canvas: document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
            context: this.renderer.getContext(),
        });
        const resolution = this.options.depthTextureResolution;
        this.occlusionRenderer.setSize(resolution, resolution);
        // Create occlusion camera
        if (this.camera instanceof THREE.PerspectiveCamera) {
            this.occlusionCamera = this.camera.clone();
        }
        else {
            this.occlusionCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        }
        // Create depth texture
        this.occlusionDepthTexture = new THREE.DepthTexture(resolution, resolution);
        this.occlusionDepthTexture.format = THREE.DepthFormat;
        this.occlusionDepthTexture.type = THREE.UnsignedShortType;
        // Create render target
        this.occlusionRenderTarget = new THREE.WebGLRenderTarget(resolution, resolution, {
            depthTexture: this.occlusionDepthTexture,
            depthBuffer: true,
        });
        // Create depth material
        this.occlusionDepthMaterial = new THREE.MeshDepthMaterial({
            depthPacking: THREE.RGBADepthPacking,
        });
        this.log('Occlusion culling initialized');
    }
    /**
     * Register scene objects
     */
    registerSceneObjects() {
        // Clear existing objects
        this.occlusionData.clear();
        // Register all objects in the scene
        this.scene.traverse((object) => {
            if (object.visible && !(object instanceof THREE.Camera) && !(object instanceof THREE.Light)) {
                this.registerObject(object);
            }
        });
        // Update stats
        this.stats.totalObjects = this.occlusionData.size;
        this.log(`Registered ${this.stats.totalObjects} objects`);
    }
    /**
     * Register object
     * @param object - Object to register
     */
    registerObject(object) {
        // Generate object ID
        const objectId = `object-${object.uuid}`;
        // Create bounding sphere
        let boundingSphere;
        if (object instanceof THREE.Mesh && object.geometry.boundingSphere) {
            // Use geometry bounding sphere
            boundingSphere = object.geometry.boundingSphere.clone();
            boundingSphere.applyMatrix4(object.matrixWorld);
        }
        else {
            // Create bounding sphere from object position
            const objectPosition = new THREE.Vector3();
            object.getWorldPosition(objectPosition);
            boundingSphere = new THREE.Sphere(objectPosition, 1);
        }
        // Create occlusion data
        const occlusionData = {
            object,
            isOccluded: false,
            query: null,
            boundingSphere,
            screenSpaceSize: 0,
            lastUpdateTime: performance.now(),
        };
        // Store occlusion data
        this.occlusionData.set(objectId, occlusionData);
        // Update stats
        this.stats.totalObjects = this.occlusionData.size;
    }
    /**
     * Unregister object
     * @param object - Object to unregister
     */
    unregisterObject(object) {
        // Generate object ID
        const objectId = `object-${object.uuid}`;
        // Remove occlusion data
        this.occlusionData.delete(objectId);
        // Update stats
        this.stats.totalObjects = this.occlusionData.size;
    }
    /**
     * Start update timer
     */
    startUpdateTimer() {
        // Clear existing timer
        this.stopUpdateTimer();
        // Start new timer
        this.updateTimer = window.setInterval(() => {
            this.updateOcclusion();
        }, this.options.updateInterval);
    }
    /**
     * Stop update timer
     */
    stopUpdateTimer() {
        if (this.updateTimer !== null) {
            window.clearInterval(this.updateTimer);
            this.updateTimer = null;
        }
    }
    /**
     * Update occlusion
     */
    updateOcclusion() {
        if (!this.isInitialized ||
            !this.occlusionRenderer ||
            !this.occlusionCamera ||
            !this.occlusionRenderTarget ||
            !this.occlusionDepthMaterial) {
            return;
        }
        // Start timer
        const startTime = performance.now();
        // Reset stats
        this.stats.occludedObjects = 0;
        this.stats.visibleObjects = 0;
        this.stats.smallObjects = 0;
        // Update occlusion camera
        this.occlusionCamera.position.copy(this.camera.position);
        this.occlusionCamera.rotation.copy(this.camera.rotation);
        this.occlusionCamera.updateMatrixWorld();
        // Render depth
        const currentRenderTarget = this.renderer.getRenderTarget();
        const currentMaterials = new Map();
        // Store original materials
        this.scene.traverse((node) => {
            if (node instanceof THREE.Mesh) {
                currentMaterials.set(node, node.material);
                node.material = this.occlusionDepthMaterial;
            }
        });
        // Render to occlusion render target
        this.renderer.setRenderTarget(this.occlusionRenderTarget);
        this.renderer.render(this.scene, this.occlusionCamera);
        // Update each object
        this.occlusionData.forEach((data, objectId) => {
            // Skip if object is not visible
            if (!data.object.visible) {
                return;
            }
            // Calculate screen space size
            data.screenSpaceSize = this.calculateScreenSpaceSize(data.boundingSphere);
            // Check if object is small
            if (this.options.cullSmallObjects &&
                data.screenSpaceSize < this.options.smallObjectThreshold) {
                data.isOccluded = true;
                this.stats.occludedObjects++;
                this.stats.smallObjects++;
                return;
            }
            // Check if object is occluded
            data.isOccluded = this.isObjectOccluded(data);
            // Update stats
            if (data.isOccluded) {
                this.stats.occludedObjects++;
            }
            else {
                this.stats.visibleObjects++;
            }
            // Update last update time
            data.lastUpdateTime = performance.now();
        });
        // Restore original materials
        currentMaterials.forEach((material, node) => {
            node.material = material;
        });
        // Restore render target
        this.renderer.setRenderTarget(currentRenderTarget);
        // Apply visibility
        this.applyVisibility();
        // Update stats
        this.stats.updateTime = performance.now() - startTime;
    }
    /**
     * Calculate screen space size
     * @param boundingSphere - Bounding sphere
     * @returns Screen space size
     */
    calculateScreenSpaceSize(boundingSphere) {
        if (!(this.camera instanceof THREE.PerspectiveCamera)) {
            return 1;
        }
        // Calculate distance to camera
        const cameraPosition = new THREE.Vector3();
        this.camera.getWorldPosition(cameraPosition);
        const distance = boundingSphere.center.distanceTo(cameraPosition);
        // Calculate screen space size
        const fov = this.camera.fov * Math.PI / 180;
        const height = 2 * Math.tan(fov / 2) * distance;
        const screenSpaceSize = boundingSphere.radius * 2 / height;
        return screenSpaceSize;
    }
    /**
     * Check if object is occluded
     * @param data - Occlusion data
     * @returns Is occluded
     */
    isObjectOccluded(data) {
        if (!this.occlusionRenderTarget || !this.occlusionDepthTexture) {
            return false;
        }
        // Get object position in screen space
        const screenPosition = this.getScreenPosition(data.boundingSphere.center);
        // Check if object is outside screen
        if (screenPosition.x < 0 || screenPosition.x > 1 ||
            screenPosition.y < 0 || screenPosition.y > 1 ||
            screenPosition.z < 0 || screenPosition.z > 1) {
            return false;
        }
        // Read depth buffer
        const resolution = this.options.depthTextureResolution;
        const x = Math.floor(screenPosition.x * resolution);
        const y = Math.floor(screenPosition.y * resolution);
        const pixelBuffer = new Float32Array(4);
        this.renderer.readRenderTargetPixels(this.occlusionRenderTarget, x, y, 1, 1, pixelBuffer);
        // Get depth from buffer
        const depth = pixelBuffer[0];
        // Get object depth
        const objectDepth = screenPosition.z;
        // Check if object is occluded
        return objectDepth > depth + this.options.occlusionThreshold;
    }
    /**
     * Get screen position
     * @param worldPosition - World position
     * @returns Screen position
     */
    getScreenPosition(worldPosition) {
        // Create vector
        const vector = new THREE.Vector3();
        // Copy world position
        vector.copy(worldPosition);
        // Project to screen space
        vector.project(this.camera);
        // Convert to 0-1 range
        vector.x = (vector.x + 1) / 2;
        vector.y = (vector.y + 1) / 2;
        return vector;
    }
    /**
     * Apply visibility
     */
    applyVisibility() {
        // Apply visibility to objects
        this.occlusionData.forEach((data) => {
            data.object.visible = !data.isOccluded;
        });
    }
    /**
     * Update
     */
    update() {
        if (!this.isInitialized) {
            return;
        }
        // Update occlusion
        this.updateOcclusion();
    }
    /**
     * Get visible objects
     * @returns Visible objects
     */
    getVisibleObjects() {
        const visibleObjects = [];
        this.occlusionData.forEach((data) => {
            if (!data.isOccluded) {
                visibleObjects.push(data.object);
            }
        });
        return visibleObjects;
    }
    /**
     * Get occluded objects
     * @returns Occluded objects
     */
    getOccludedObjects() {
        const occludedObjects = [];
        this.occlusionData.forEach((data) => {
            if (data.isOccluded) {
                occludedObjects.push(data.object);
            }
        });
        return occludedObjects;
    }
    /**
     * Get stats
     * @returns Stats
     */
    getStats() {
        return { ...this.stats };
    }
    /**
     * Set options
     * @param options - Options
     */
    setOptions(options) {
        this.options = {
            ...this.options,
            ...options,
        };
        // Reinitialize occlusion culling if needed
        if (options.depthTextureResolution !== undefined) {
            this.dispose();
            this.initialize();
        }
    }
    /**
     * Resize
     * @param width - Width
     * @param height - Height
     */
    resize(width, height) {
        // Resize occlusion camera
        if (this.occlusionCamera instanceof THREE.PerspectiveCamera) {
            this.occlusionCamera.aspect = width / height;
            this.occlusionCamera.updateProjectionMatrix();
        }
    }
    /**
     * Dispose
     */
    dispose() {
        // Stop update timer
        this.stopUpdateTimer();
        // Dispose occlusion resources
        if (this.occlusionRenderTarget) {
            this.occlusionRenderTarget.dispose();
            this.occlusionRenderTarget = null;
        }
        if (this.occlusionDepthTexture) {
            this.occlusionDepthTexture.dispose();
            this.occlusionDepthTexture = null;
        }
        if (this.occlusionDepthMaterial) {
            this.occlusionDepthMaterial.dispose();
            this.occlusionDepthMaterial = null;
        }
        // Clear occlusion data
        this.occlusionData.clear();
        // Mark as not initialized
        this.isInitialized = false;
        this.log('Occlusion Culling System disposed');
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[OcclusionCullingSystem] ${message}`);
        }
    }
}
