/**
 * Visualization Worker
 *
 * Web Worker for offloading visualization computations.
 *
 * @version 1.0.0
 */
// Worker context
const ctx = self;
/**
 * Handle message
 * @param event - Message event
 */
ctx.onmessage = (event) => {
    const { taskId, taskType, data } = event.data;
    // Start timer
    const startTime = performance.now();
    try {
        // Process task
        let result;
        switch (taskType) {
            case 'computeGeometry':
                result = computeGeometry(data);
                break;
            case 'processParticles':
                result = processParticles(data);
                break;
            case 'calculatePhysics':
                result = calculatePhysics(data);
                break;
            case 'generateStarField':
                result = generateStarField(data);
                break;
            case 'generateNebula':
                result = generateNebula(data);
                break;
            default:
                throw new Error(`Unknown task type: ${taskType}`);
        }
        // Calculate processing time
        const processingTime = performance.now() - startTime;
        // Send response
        ctx.postMessage({
            taskId,
            taskType,
            result,
            processingTime,
        });
    }
    catch (error) {
        // Calculate processing time
        const processingTime = performance.now() - startTime;
        // Send error response
        ctx.postMessage({
            taskId,
            taskType,
            result: null,
            error: error.message,
            processingTime,
        });
    }
}; /**
 * Compute geometry
 * @param data - Geometry data
 * @returns Computed geometry data
 */
function computeGeometry(data) {
    const { vertices, indices, normals, uvs, type } = data;
    // Process based on geometry type
    switch (type) {
        case 'sphere':
            return computeSphereGeometry(data);
        case 'galaxy':
            return computeGalaxyGeometry(data);
        case 'nebula':
            return computeNebulaGeometry(data);
        case 'starSystem':
            return computeStarSystemGeometry(data);
        case 'custom':
            return computeCustomGeometry(vertices, indices, normals, uvs);
        default:
            throw new Error(`Unknown geometry type: ${type}`);
    }
}
/**
 * Compute sphere geometry
 * @param data - Sphere data
 * @returns Sphere geometry data
 */
function computeSphereGeometry(data) {
    const { radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength } = data;
    // Generate sphere vertices, indices, normals, and UVs
    // This is a simplified version; a full implementation would generate proper sphere geometry
    const vertices = [];
    const indices = [];
    const normals = [];
    const uvs = [];
    // Generate vertices
    for (let y = 0; y <= heightSegments; y++) {
        const v = y / heightSegments;
        const theta = thetaStart + v * thetaLength;
        for (let x = 0; x <= widthSegments; x++) {
            const u = x / widthSegments;
            const phi = phiStart + u * phiLength;
            // Calculate vertex position
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            const x = -radius * cosPhi * sinTheta;
            const y = radius * cosTheta;
            const z = radius * sinPhi * sinTheta;
            // Add vertex
            vertices.push(x, y, z);
            // Add normal (normalized vertex position for sphere)
            normals.push(x / radius, y / radius, z / radius);
            // Add UV
            uvs.push(u, v);
        }
    }
    // Generate indices
    for (let y = 0; y < heightSegments; y++) {
        for (let x = 0; x < widthSegments; x++) {
            const a = (widthSegments + 1) * y + x;
            const b = (widthSegments + 1) * y + x + 1;
            const c = (widthSegments + 1) * (y + 1) + x + 1;
            const d = (widthSegments + 1) * (y + 1) + x;
            // Add triangles
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    return { vertices, indices, normals, uvs };
}
/**
 * Compute galaxy geometry
 * @param data - Galaxy data
 * @returns Galaxy geometry data
 */
function computeGalaxyGeometry(data) {
    const { particleCount, radius, thickness, arms, armWidth, randomness } = data;
    // Generate galaxy particles
    const positions = [];
    const colors = [];
    const sizes = [];
    for (let i = 0; i < particleCount; i++) {
        // Calculate particle position in galaxy
        const armAngle = (i % arms) * (2 * Math.PI / arms);
        const distanceFromCenter = Math.random() * radius;
        const spiralAngle = distanceFromCenter * 2.5;
        const angle = armAngle + spiralAngle;
        // Add randomness
        const randX = (Math.random() - 0.5) * armWidth * distanceFromCenter;
        const randY = (Math.random() - 0.5) * thickness;
        const randZ = (Math.random() - 0.5) * armWidth * distanceFromCenter;
        // Calculate position
        const x = Math.cos(angle) * distanceFromCenter + randX;
        const y = randY;
        const z = Math.sin(angle) * distanceFromCenter + randZ;
        // Add position
        positions.push(x, y, z);
        // Calculate color based on distance from center
        const r = 0.3 + 0.7 * (1 - distanceFromCenter / radius);
        const g = 0.3 + 0.7 * (1 - distanceFromCenter / radius);
        const b = 0.5 + 0.5 * (1 - distanceFromCenter / radius);
        // Add color
        colors.push(r, g, b);
        // Calculate size based on distance from center
        const size = 0.5 + 1.5 * (1 - distanceFromCenter / radius);
        // Add size
        sizes.push(size);
    }
    return { positions, colors, sizes };
} /**
 * Compute nebula geometry
 * @param data - Nebula data
 * @returns Nebula geometry data
 */
function computeNebulaGeometry(data) {
    const { particleCount, radius, density, colorScheme } = data;
    // Generate nebula particles
    const positions = [];
    const colors = [];
    const sizes = [];
    const opacities = [];
    for (let i = 0; i < particleCount; i++) {
        // Calculate random position within nebula volume
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = Math.pow(Math.random(), 1 / 3) * radius;
        // Convert to Cartesian coordinates
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        // Add position
        positions.push(x, y, z);
        // Calculate color based on color scheme
        let r, g, b;
        switch (colorScheme) {
            case 'blue':
                r = 0.2 + 0.3 * Math.random();
                g = 0.5 + 0.3 * Math.random();
                b = 0.7 + 0.3 * Math.random();
                break;
            case 'red':
                r = 0.7 + 0.3 * Math.random();
                g = 0.3 + 0.3 * Math.random();
                b = 0.2 + 0.3 * Math.random();
                break;
            case 'purple':
                r = 0.5 + 0.3 * Math.random();
                g = 0.2 + 0.3 * Math.random();
                b = 0.7 + 0.3 * Math.random();
                break;
            default:
                r = 0.5 + 0.5 * Math.random();
                g = 0.5 + 0.5 * Math.random();
                b = 0.5 + 0.5 * Math.random();
        }
        // Add color
        colors.push(r, g, b);
        // Calculate size based on density
        const size = 1 + 4 * Math.random() * density;
        // Add size
        sizes.push(size);
        // Calculate opacity based on distance from center
        const distanceFromCenter = Math.sqrt(x * x + y * y + z * z);
        const opacity = 0.2 + 0.8 * (1 - distanceFromCenter / radius);
        // Add opacity
        opacities.push(opacity);
    }
    return { positions, colors, sizes, opacities };
} /**
 * Compute star system geometry
 * @param data - Star system data
 * @returns Star system geometry data
 */
function computeStarSystemGeometry(data) {
    const { stars, orbits } = data;
    // Generate star system geometry
    const starPositions = [];
    const starColors = [];
    const starSizes = [];
    const orbitPositions = [];
    const orbitColors = [];
    // Process stars
    for (const star of stars) {
        const { position, color, size } = star;
        // Add star position
        starPositions.push(position.x, position.y, position.z);
        // Add star color
        starColors.push(color.r, color.g, color.b);
        // Add star size
        starSizes.push(size);
    }
    // Process orbits
    for (const orbit of orbits) {
        const { center, radius, segments, color } = orbit;
        // Generate orbit points
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = center.x + radius * Math.cos(angle);
            const y = center.y;
            const z = center.z + radius * Math.sin(angle);
            // Add orbit position
            orbitPositions.push(x, y, z);
            // Add orbit color
            orbitColors.push(color.r, color.g, color.b);
        }
    }
    return { starPositions, starColors, starSizes, orbitPositions, orbitColors };
}
/**
 * Compute custom geometry
 * @param vertices - Vertex positions
 * @param indices - Vertex indices
 * @param normals - Vertex normals
 * @param uvs - Vertex UVs
 * @returns Processed geometry data
 */
function computeCustomGeometry(vertices, indices, normals, uvs) {
    // Process custom geometry
    // This is a placeholder for custom geometry processing
    return { vertices, indices, normals, uvs };
} /**
 * Process particles
 * @param data - Particle data
 * @returns Processed particle data
 */
function processParticles(data) {
    const { positions, velocities, accelerations, masses, timeStep } = data;
    // Process particles
    const newPositions = [];
    const newVelocities = [];
    // Update particles
    for (let i = 0; i < positions.length; i += 3) {
        const px = positions[i];
        const py = positions[i + 1];
        const pz = positions[i + 2];
        const vx = velocities[i];
        const vy = velocities[i + 1];
        const vz = velocities[i + 2];
        const ax = accelerations[i];
        const ay = accelerations[i + 1];
        const az = accelerations[i + 2];
        // Update velocity (v = v + a * dt)
        const nvx = vx + ax * timeStep;
        const nvy = vy + ay * timeStep;
        const nvz = vz + az * timeStep;
        // Update position (p = p + v * dt)
        const npx = px + nvx * timeStep;
        const npy = py + nvy * timeStep;
        const npz = pz + nvz * timeStep;
        // Add new position
        newPositions.push(npx, npy, npz);
        // Add new velocity
        newVelocities.push(nvx, nvy, nvz);
    }
    return { positions: newPositions, velocities: newVelocities };
}
/**
 * Calculate physics
 * @param data - Physics data
 * @returns Physics calculation results
 */
function calculatePhysics(data) {
    const { bodies, timeStep, gravitationalConstant } = data;
    // Calculate physics
    const accelerations = [];
    // Calculate accelerations
    for (let i = 0; i < bodies.length; i++) {
        const bodyA = bodies[i];
        let ax = 0;
        let ay = 0;
        let az = 0;
        // Calculate gravitational forces from other bodies
        for (let j = 0; j < bodies.length; j++) {
            if (i === j)
                continue;
            const bodyB = bodies[j];
            // Calculate distance vector
            const dx = bodyB.position.x - bodyA.position.x;
            const dy = bodyB.position.y - bodyA.position.y;
            const dz = bodyB.position.z - bodyA.position.z;
            // Calculate distance squared
            const distanceSquared = dx * dx + dy * dy + dz * dz;
            // Avoid division by zero
            if (distanceSquared < 0.0001)
                continue;
            // Calculate gravitational force
            const force = gravitationalConstant * bodyB.mass / distanceSquared;
            // Calculate acceleration components
            const distance = Math.sqrt(distanceSquared);
            ax += force * dx / distance;
            ay += force * dy / distance;
            az += force * dz / distance;
        }
        // Add acceleration
        accelerations.push(ax, ay, az);
    }
    return { accelerations };
} /**
 * Generate star field
 * @param data - Star field data
 * @returns Star field data
 */
function generateStarField(data) {
    const { count, radius, minSize, maxSize, colorVariation } = data;
    // Generate star field
    const positions = [];
    const colors = [];
    const sizes = [];
    for (let i = 0; i < count; i++) {
        // Generate random position on sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = radius;
        // Convert to Cartesian coordinates
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        // Add position
        positions.push(x, y, z);
        // Generate random star color
        const temperature = 3000 + Math.random() * 27000; // Star temperature in Kelvin
        const { r: red, g: green, b: blue } = temperatureToRGB(temperature);
        // Add color variation
        const variation = 1 - colorVariation / 2 + Math.random() * colorVariation;
        // Add color
        colors.push(red * variation, green * variation, blue * variation);
        // Generate random star size
        const size = minSize + Math.random() * (maxSize - minSize);
        // Add size
        sizes.push(size);
    }
    return { positions, colors, sizes };
}
/**
 * Generate nebula
 * @param data - Nebula data
 * @returns Nebula data
 */
function generateNebula(data) {
    // This is a simplified version of the computeNebulaGeometry function
    return computeNebulaGeometry(data);
}
/**
 * Convert temperature to RGB color
 * @param temperature - Temperature in Kelvin
 * @returns RGB color
 */
function temperatureToRGB(temperature) {
    // Approximate RGB values for star temperature
    // Based on blackbody radiation
    let r, g, b;
    // Normalize temperature
    const temp = temperature / 100;
    // Calculate red component
    if (temp <= 66) {
        r = 1;
    }
    else {
        r = temp - 60;
        r = 329.698727446 * Math.pow(r, -0.1332047592);
        r = Math.max(0, Math.min(1, r / 255));
    }
    // Calculate green component
    if (temp <= 66) {
        g = temp;
        g = 99.4708025861 * Math.log(g) - 161.1195681661;
        g = Math.max(0, Math.min(1, g / 255));
    }
    else {
        g = temp - 60;
        g = 288.1221695283 * Math.pow(g, -0.0755148492);
        g = Math.max(0, Math.min(1, g / 255));
    }
    // Calculate blue component
    if (temp >= 66) {
        b = 1;
    }
    else if (temp <= 19) {
        b = 0;
    }
    else {
        b = temp - 10;
        b = 138.5177312231 * Math.log(b) - 305.0447927307;
        b = Math.max(0, Math.min(1, b / 255));
    }
    return { r, g, b };
}
// Export worker
export default null; // This is needed for TypeScript to recognize this as a module
