/**
 * Model Simplifier
 *
 * Provides utilities for creating simplified 3D models for Level of Detail (LOD) rendering.
 *
 * @version 1.0.0
 */
import * as THREE from 'three';
import { SimplifyModifier } from 'three/examples/jsm/modifiers/SimplifyModifier';
import { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils';
/**
 * Simplification method
 */
export var SimplificationMethod;
(function (SimplificationMethod) {
    /** Vertex reduction */
    SimplificationMethod["VERTEX_REDUCTION"] = "vertex_reduction";
    /** Face reduction */
    SimplificationMethod["FACE_REDUCTION"] = "face_reduction";
    /** Mesh decimation */
    SimplificationMethod["MESH_DECIMATION"] = "mesh_decimation";
    /** Voxel-based simplification */
    SimplificationMethod["VOXEL"] = "voxel";
    /** Bounding box */
    SimplificationMethod["BOUNDING_BOX"] = "bounding_box";
    /** Bounding sphere */
    SimplificationMethod["BOUNDING_SPHERE"] = "bounding_sphere";
    /** Billboard */
    SimplificationMethod["BILLBOARD"] = "billboard";
    /** Point cloud */
    SimplificationMethod["POINT_CLOUD"] = "point_cloud";
})(SimplificationMethod || (SimplificationMethod = {}));
/**
 * Default simplification options
 */
const defaultOptions = {
    method: SimplificationMethod.MESH_DECIMATION,
    targetPercentage: 0.5,
    preserveBoundary: true,
    preserveTexCoords: true,
    preserveNormals: true,
    preserveColors: true,
    debugMode: false,
}; /**
 * Model Simplifier
 */
export class ModelSimplifier {
    /**
     * Constructor
     * @param options - Simplification options
     */
    constructor(options = {}) {
        /** Geometry cache */
        this.geometryCache = new Map();
        this.options = {
            ...defaultOptions,
            ...options,
        };
        this.simplifyModifier = new SimplifyModifier();
        this.log('Model Simplifier initialized');
    }
    /**
     * Simplify geometry
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyGeometry(geometry, options = {}) {
        // Merge options
        const mergedOptions = {
            ...this.options,
            ...options,
        };
        // Generate cache key
        const cacheKey = this.generateCacheKey(geometry, mergedOptions);
        // Check cache
        if (this.geometryCache.has(cacheKey)) {
            return this.geometryCache.get(cacheKey).clone();
        }
        // Clone geometry to avoid modifying the original
        const clonedGeometry = geometry.clone();
        // Ensure geometry has indices
        if (!clonedGeometry.index) {
            clonedGeometry.setIndex(BufferGeometryUtils.mergeVertices(clonedGeometry).index);
        }
        // Simplify geometry based on method
        let simplifiedGeometry;
        switch (mergedOptions.method) {
            case SimplificationMethod.VERTEX_REDUCTION:
                simplifiedGeometry = this.simplifyByVertexReduction(clonedGeometry, mergedOptions);
                break;
            case SimplificationMethod.FACE_REDUCTION:
                simplifiedGeometry = this.simplifyByFaceReduction(clonedGeometry, mergedOptions);
                break;
            case SimplificationMethod.MESH_DECIMATION:
                simplifiedGeometry = this.simplifyByMeshDecimation(clonedGeometry, mergedOptions);
                break;
            case SimplificationMethod.VOXEL:
                simplifiedGeometry = this.simplifyByVoxelization(clonedGeometry, mergedOptions);
                break;
            case SimplificationMethod.BOUNDING_BOX:
                simplifiedGeometry = this.simplifyToBoundingBox(clonedGeometry);
                break;
            case SimplificationMethod.BOUNDING_SPHERE:
                simplifiedGeometry = this.simplifyToBoundingSphere(clonedGeometry);
                break;
            case SimplificationMethod.BILLBOARD:
                simplifiedGeometry = this.simplifyToBillboard(clonedGeometry);
                break;
            case SimplificationMethod.POINT_CLOUD:
                simplifiedGeometry = this.simplifyToPointCloud(clonedGeometry, mergedOptions);
                break;
            default:
                simplifiedGeometry = this.simplifyByMeshDecimation(clonedGeometry, mergedOptions);
        }
        // Cache simplified geometry
        this.geometryCache.set(cacheKey, simplifiedGeometry.clone());
        this.log(`Simplified geometry: ${mergedOptions.method}`);
        return simplifiedGeometry;
    }
    /**
     * Simplify by vertex reduction
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyByVertexReduction(geometry, options) {
        // Get position attribute
        const positionAttribute = geometry.getAttribute('position');
        // Calculate target vertex count
        const originalVertexCount = positionAttribute.count;
        const targetVertexCount = Math.max(4, Math.floor(originalVertexCount * (options.targetPercentage || 0.5)));
        // Skip if target count is close to original
        if (targetVertexCount >= originalVertexCount * 0.9) {
            return geometry.clone();
        }
        // Create new geometry
        const simplifiedGeometry = new THREE.BufferGeometry();
        // Create new position array with reduced vertices
        const stride = Math.ceil(originalVertexCount / targetVertexCount);
        const newPositions = new Float32Array(targetVertexCount * 3);
        for (let i = 0, j = 0; i < originalVertexCount && j < targetVertexCount; i += stride, j++) {
            newPositions[j * 3] = positionAttribute.getX(i);
            newPositions[j * 3 + 1] = positionAttribute.getY(i);
            newPositions[j * 3 + 2] = positionAttribute.getZ(i);
        }
        // Set position attribute
        simplifiedGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        // Copy other attributes if requested
        if (options.preserveNormals && geometry.attributes.normal) {
            const normalAttribute = geometry.getAttribute('normal');
            const newNormals = new Float32Array(targetVertexCount * 3);
            for (let i = 0, j = 0; i < originalVertexCount && j < targetVertexCount; i += stride, j++) {
                newNormals[j * 3] = normalAttribute.getX(i);
                newNormals[j * 3 + 1] = normalAttribute.getY(i);
                newNormals[j * 3 + 2] = normalAttribute.getZ(i);
            }
            simplifiedGeometry.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
        }
        else {
            // Compute normals if not preserved
            simplifiedGeometry.computeVertexNormals();
        }
        // Copy UV coordinates if requested
        if (options.preserveTexCoords && geometry.attributes.uv) {
            const uvAttribute = geometry.getAttribute('uv');
            const newUVs = new Float32Array(targetVertexCount * 2);
            for (let i = 0, j = 0; i < originalVertexCount && j < targetVertexCount; i += stride, j++) {
                newUVs[j * 2] = uvAttribute.getX(i);
                newUVs[j * 2 + 1] = uvAttribute.getY(i);
            }
            simplifiedGeometry.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));
        }
        // Copy color attributes if requested
        if (options.preserveColors && geometry.attributes.color) {
            const colorAttribute = geometry.getAttribute('color');
            const itemSize = colorAttribute.itemSize;
            const newColors = new Float32Array(targetVertexCount * itemSize);
            for (let i = 0, j = 0; i < originalVertexCount && j < targetVertexCount; i += stride, j++) {
                for (let k = 0; k < itemSize; k++) {
                    newColors[j * itemSize + k] = colorAttribute.array[i * itemSize + k];
                }
            }
            simplifiedGeometry.setAttribute('color', new THREE.BufferAttribute(newColors, itemSize));
        }
        // Compute bounding sphere
        simplifiedGeometry.computeBoundingSphere();
        return simplifiedGeometry;
    }
    /**
     * Simplify by face reduction
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyByFaceReduction(geometry, options) {
        // Ensure geometry has indices
        if (!geometry.index) {
            geometry = BufferGeometryUtils.mergeVertices(geometry);
        }
        // Get index attribute
        const indexAttribute = geometry.index;
        // Calculate target face count
        const originalFaceCount = indexAttribute.count / 3;
        const targetFaceCount = Math.max(1, Math.floor(originalFaceCount * (options.targetPercentage || 0.5)));
        // Skip if target count is close to original
        if (targetFaceCount >= originalFaceCount * 0.9) {
            return geometry.clone();
        }
        // Create new geometry
        const simplifiedGeometry = geometry.clone();
        // Create new index array with reduced faces
        const stride = Math.ceil(originalFaceCount / targetFaceCount);
        const newIndices = [];
        for (let i = 0; i < originalFaceCount; i += stride) {
            const faceIndex = i * 3;
            newIndices.push(indexAttribute.getX(faceIndex), indexAttribute.getX(faceIndex + 1), indexAttribute.getX(faceIndex + 2));
        }
        // Set index attribute
        simplifiedGeometry.setIndex(newIndices);
        // Compute normals if needed
        if (!options.preserveNormals || !geometry.attributes.normal) {
            simplifiedGeometry.computeVertexNormals();
        }
        // Compute bounding sphere
        simplifiedGeometry.computeBoundingSphere();
        return simplifiedGeometry;
    }
    /**
     * Simplify by mesh decimation
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyByMeshDecimation(geometry, options) {
        // Ensure geometry has indices
        if (!geometry.index) {
            geometry = BufferGeometryUtils.mergeVertices(geometry);
        }
        // Calculate target triangle count
        const originalTriangleCount = geometry.index ? geometry.index.count / 3 : 0;
        let targetTriangleCount;
        if (options.targetTriangles) {
            targetTriangleCount = options.targetTriangles;
        }
        else {
            targetTriangleCount = Math.max(4, Math.floor(originalTriangleCount * (options.targetPercentage || 0.5)));
        }
        // Skip if target count is close to original
        if (targetTriangleCount >= originalTriangleCount * 0.9) {
            return geometry.clone();
        }
        // Calculate reduction amount
        const reduction = originalTriangleCount - targetTriangleCount;
        try {
            // Use SimplifyModifier to decimate the mesh
            const simplifiedGeometry = this.simplifyModifier.modify(geometry, reduction);
            // Compute normals if needed
            if (!options.preserveNormals || !simplifiedGeometry.attributes.normal) {
                simplifiedGeometry.computeVertexNormals();
            }
            // Compute bounding sphere
            simplifiedGeometry.computeBoundingSphere();
            return simplifiedGeometry;
        }
        catch (error) {
            console.error('Error in mesh decimation:', error);
            // Fallback to face reduction
            return this.simplifyByFaceReduction(geometry, options);
        }
    }
    /**
     * Simplify by voxelization
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyByVoxelization(geometry, options) {
        // Get position attribute
        const positionAttribute = geometry.getAttribute('position');
        // Calculate bounding box
        geometry.computeBoundingBox();
        const boundingBox = geometry.boundingBox;
        // Calculate voxel size
        const voxelSize = options.voxelSize || Math.max((boundingBox.max.x - boundingBox.min.x), (boundingBox.max.y - boundingBox.min.y), (boundingBox.max.z - boundingBox.min.z)) * (1 - (options.targetPercentage || 0.5));
        // Skip if voxel size is too small
        if (voxelSize <= 0.001) {
            return geometry.clone();
        }
        // Create voxel grid
        const voxelGrid = new Map();
        // Process vertices
        for (let i = 0; i < positionAttribute.count; i++) {
            // Get position
            const position = new THREE.Vector3(positionAttribute.getX(i), positionAttribute.getY(i), positionAttribute.getZ(i));
            // Calculate voxel coordinates
            const voxelX = Math.floor(position.x / voxelSize);
            const voxelY = Math.floor(position.y / voxelSize);
            const voxelZ = Math.floor(position.z / voxelSize);
            // Generate voxel key
            const voxelKey = `${voxelX},${voxelY},${voxelZ}`;
            // Skip if voxel already exists
            if (voxelGrid.has(voxelKey)) {
                continue;
            }
            // Create voxel data
            const voxelData = {
                position: new THREE.Vector3((voxelX + 0.5) * voxelSize, (voxelY + 0.5) * voxelSize, (voxelZ + 0.5) * voxelSize),
                normal: new THREE.Vector3(0, 0, 0),
            };
            // Get normal
            if (geometry.attributes.normal) {
                const normalAttribute = geometry.getAttribute('normal');
                voxelData.normal.set(normalAttribute.getX(i), normalAttribute.getY(i), normalAttribute.getZ(i));
            }
            // Get UV coordinates
            if (options.preserveTexCoords && geometry.attributes.uv) {
                const uvAttribute = geometry.getAttribute('uv');
                voxelData.uv = new THREE.Vector2(uvAttribute.getX(i), uvAttribute.getY(i));
            }
            // Get color
            if (options.preserveColors && geometry.attributes.color) {
                const colorAttribute = geometry.getAttribute('color');
                if (colorAttribute.itemSize === 3) {
                    voxelData.color = new THREE.Color(colorAttribute.getX(i), colorAttribute.getY(i), colorAttribute.getZ(i));
                }
                else if (colorAttribute.itemSize === 4) {
                    voxelData.color = new THREE.Color(colorAttribute.getX(i), colorAttribute.getY(i), colorAttribute.getZ(i));
                }
            }
            // Add voxel to grid
            voxelGrid.set(voxelKey, voxelData);
        }
        // Create new geometry
        const simplifiedGeometry = new THREE.BufferGeometry();
        // Create arrays for attributes
        const positions = [];
        const normals = [];
        const uvs = [];
        const colors = [];
        // Add voxels to arrays
        voxelGrid.forEach((voxelData) => {
            // Add position
            positions.push(voxelData.position.x, voxelData.position.y, voxelData.position.z);
            // Add normal
            normals.push(voxelData.normal.x, voxelData.normal.y, voxelData.normal.z);
            // Add UV coordinates
            if (voxelData.uv) {
                uvs.push(voxelData.uv.x, voxelData.uv.y);
            }
            // Add color
            if (voxelData.color) {
                colors.push(voxelData.color.r, voxelData.color.g, voxelData.color.b);
            }
        });
        // Set attributes
        simplifiedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        simplifiedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        if (uvs.length > 0) {
            simplifiedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
        if (colors.length > 0) {
            simplifiedGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }
        // Compute bounding sphere
        simplifiedGeometry.computeBoundingSphere();
        return simplifiedGeometry;
    }
    /**
     * Simplify to bounding box
     * @param geometry - Original geometry
     * @returns Simplified geometry
     */
    simplifyToBoundingBox(geometry) {
        // Calculate bounding box
        geometry.computeBoundingBox();
        const boundingBox = geometry.boundingBox;
        // Create box geometry
        const boxGeometry = new THREE.BoxGeometry(boundingBox.max.x - boundingBox.min.x, boundingBox.max.y - boundingBox.min.y, boundingBox.max.z - boundingBox.min.z);
        // Center box
        boxGeometry.translate((boundingBox.min.x + boundingBox.max.x) / 2, (boundingBox.min.y + boundingBox.max.y) / 2, (boundingBox.min.z + boundingBox.max.z) / 2);
        return boxGeometry;
    }
    /**
     * Simplify to bounding sphere
     * @param geometry - Original geometry
     * @returns Simplified geometry
     */
    simplifyToBoundingSphere(geometry) {
        // Calculate bounding sphere
        geometry.computeBoundingSphere();
        const boundingSphere = geometry.boundingSphere;
        // Create sphere geometry
        const sphereGeometry = new THREE.SphereGeometry(boundingSphere.radius, 8, 6);
        // Center sphere
        sphereGeometry.translate(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z);
        return sphereGeometry;
    }
    /**
     * Simplify to billboard
     * @param geometry - Original geometry
     * @returns Simplified geometry
     */
    simplifyToBillboard(geometry) {
        // Calculate bounding box
        geometry.computeBoundingBox();
        const boundingBox = geometry.boundingBox;
        // Create plane geometry
        const planeGeometry = new THREE.PlaneGeometry(boundingBox.max.x - boundingBox.min.x, boundingBox.max.y - boundingBox.min.y);
        // Center plane
        planeGeometry.translate((boundingBox.min.x + boundingBox.max.x) / 2, (boundingBox.min.y + boundingBox.max.y) / 2, (boundingBox.min.z + boundingBox.max.z) / 2);
        return planeGeometry;
    }
    /**
     * Simplify to point cloud
     * @param geometry - Original geometry
     * @param options - Simplification options
     * @returns Simplified geometry
     */
    simplifyToPointCloud(geometry, options) {
        // Get position attribute
        const positionAttribute = geometry.getAttribute('position');
        // Calculate target point count
        const originalPointCount = positionAttribute.count;
        const targetPointCount = Math.max(4, Math.floor(originalPointCount * (options.targetPercentage || 0.1)));
        // Create new geometry
        const simplifiedGeometry = new THREE.BufferGeometry();
        // Create new position array with reduced points
        const stride = Math.ceil(originalPointCount / targetPointCount);
        const newPositions = new Float32Array(targetPointCount * 3);
        for (let i = 0, j = 0; i < originalPointCount && j < targetPointCount; i += stride, j++) {
            newPositions[j * 3] = positionAttribute.getX(i);
            newPositions[j * 3 + 1] = positionAttribute.getY(i);
            newPositions[j * 3 + 2] = positionAttribute.getZ(i);
        }
        // Set position attribute
        simplifiedGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        // Copy color attributes if requested
        if (options.preserveColors && geometry.attributes.color) {
            const colorAttribute = geometry.getAttribute('color');
            const itemSize = colorAttribute.itemSize;
            const newColors = new Float32Array(targetPointCount * itemSize);
            for (let i = 0, j = 0; i < originalPointCount && j < targetPointCount; i += stride, j++) {
                for (let k = 0; k < itemSize; k++) {
                    newColors[j * itemSize + k] = colorAttribute.array[i * itemSize + k];
                }
            }
            simplifiedGeometry.setAttribute('color', new THREE.BufferAttribute(newColors, itemSize));
        }
        // Compute bounding sphere
        simplifiedGeometry.computeBoundingSphere();
        return simplifiedGeometry;
    }
    /**
     * Generate cache key
     * @param geometry - Geometry
     * @param options - Simplification options
     * @returns Cache key
     */
    generateCacheKey(geometry, options) {
        // Generate hash from geometry UUID and options
        return `${geometry.uuid}_${options.method}_${options.targetPercentage}_${options.targetTriangles}`;
    }
    /**
     * Create LOD model
     * @param geometry - Original geometry
     * @param material - Material
     * @param levels - Number of LOD levels
     * @param options - Simplification options
     * @returns LOD object
     */
    createLODModel(geometry, material, levels = 3, options = {}) {
        // Create LOD object
        const lod = new THREE.LOD();
        // Add original model as highest detail level
        const highDetailMesh = new THREE.Mesh(geometry, material);
        lod.addLevel(highDetailMesh, 0);
        // Add simplified models for lower detail levels
        for (let i = 1; i < levels; i++) {
            // Calculate target percentage for this level
            const targetPercentage = 1 - (i / levels);
            // Create simplified geometry
            const simplifiedGeometry = this.simplifyGeometry(geometry, {
                ...options,
                targetPercentage,
            });
            // Create mesh
            const mesh = new THREE.Mesh(simplifiedGeometry, material);
            // Calculate distance threshold
            const distance = Math.pow(2, i) * 10;
            // Add level
            lod.addLevel(mesh, distance);
        }
        return lod;
    }
    /**
     * Create LOD group
     * @param object - Original object
     * @param levels - Number of LOD levels
     * @param options - Simplification options
     * @returns LOD group
     */
    createLODGroup(object, levels = 3, options = {}) {
        // Create group
        const group = new THREE.Group();
        // Process object
        object.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                // Create LOD model
                const lod = this.createLODModel(child.geometry, child.material, levels, options);
                // Copy transformation
                lod.position.copy(child.position);
                lod.rotation.copy(child.rotation);
                lod.scale.copy(child.scale);
                // Add to group
                group.add(lod);
            }
            else if (child !== object) {
                // Add non-mesh objects directly
                group.add(child.clone());
            }
        });
        return group;
    }
    /**
     * Clear cache
     */
    clearCache() {
        // Dispose geometries
        this.geometryCache.forEach((geometry) => {
            geometry.dispose();
        });
        // Clear cache
        this.geometryCache.clear();
        this.log('Cache cleared');
    }
    /**
     * Dispose resources
     */
    dispose() {
        // Clear cache
        this.clearCache();
        this.log('Model Simplifier disposed');
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[ModelSimplifier] ${message}`);
        }
    }
}
