/**
 * Base Renderer
 *
 * Base class for all visualization renderers.
 *
 * @version 1.0.0
 */
/**
 * Base Renderer
 */
class BaseRenderer {
    /**
     * Create a new BaseRenderer instance
     * @param options - Renderer options
     */
    constructor(options = {}) {
        // Options
        this.options = {
            // Debug mode
            debugMode: false,
            // Theme
            theme: 'light',
            // Color palette
            colorPalette: 'quantum',
            // Animation enabled
            animationsEnabled: true,
            // Responsive design
            responsive: true,
            // Merge with provided options
            ...options,
        };
        // Renderer name
        this.name = 'base';
    }
    /**
     * Initialize the renderer
     * @param options - Initialization options
     */
    initialize(options = {}) {
        // Merge options
        this.options = {
            ...this.options,
            ...options,
        };
        this.log('Base Renderer initialized');
    }
    /**
     * Render the visualization
     * @param element - DOM element to render into
     * @param data - Visualization data
     * @param options - Render options
     */
    render(element, data, options = {}) {
        throw new Error('Method not implemented: render');
    }
    /**
     * Update the visualization
     * @param element - DOM element to update
     * @param data - Visualization data
     * @param options - Update options
     */
    update(element, data, options = {}) {
        // Default implementation: re-render
        this.render(element, data, options);
    }
    /**
     * Resize the visualization
     * @param element - DOM element to resize
     * @param dimensions - New dimensions
     */
    resize(element, dimensions = {}) {
        // Default implementation: re-render with new dimensions
        this.render(element, this.lastData, {
            ...this.options,
            ...dimensions,
        });
    }
    /**
     * Destroy the visualization
     * @param element - DOM element to clean up
     */
    destroy(element) {
        // Default implementation: clear element
        if (element) {
            element.innerHTML = '';
        }
    }
    /**
     * Get color from palette
     * @param index - Color index
     * @returns Color
     */
    getColor(index) {
        // Get palette
        const palette = this._getPalette();
        // Get color
        return palette[index % palette.length];
    }
    /**
     * Get color palette
     * @returns Color palette
     * @private
     */
    _getPalette() {
        // Predefined palettes
        const palettes = {
            quantum: [
                '#3366CC',
                '#DC3912',
                '#FF9900',
                '#109618',
                '#990099',
                '#3B3EAC',
                '#0099C6',
                '#DD4477',
                '#66AA00',
                '#B82E2E',
            ],
            cosmic: [
                '#8C54FF',
                '#FF5454',
                '#54FFBD',
                '#FFBD54',
                '#5481FF',
                '#FF54E5',
                '#54FFFF',
                '#FF8C54',
                '#54FF54',
                '#FF54A8',
            ],
            aurora: [
                '#00FFFF',
                '#FF00FF',
                '#FFFF00',
                '#00FF00',
                '#FF0000',
                '#0000FF',
                '#00FFAA',
                '#FF00AA',
                '#AAFF00',
                '#AA00FF',
            ],
            nebula: [
                '#FF6B6B',
                '#4ECDC4',
                '#FFE66D',
                '#1A535C',
                '#F7FFF7',
                '#FF9F1C',
                '#2EC4B6',
                '#E71D36',
                '#011627',
                '#FDFFFC',
            ],
        };
        // Return palette or default
        return palettes[this.options.colorPalette || 'quantum'] || palettes.quantum;
    }
    /**
     * Format value for display
     * @param value - Value to format
     * @param type - Value type
     * @returns Formatted value
     */
    formatValue(value, type = 'number') {
        switch (type) {
            case 'number':
                return this._formatNumber(value);
            case 'percent':
                return this._formatPercent(value);
            case 'date':
                return this._formatDate(value);
            case 'time':
                return this._formatTime(value);
            case 'datetime':
                return this._formatDateTime(value);
            case 'duration':
                return this._formatDuration(value);
            default:
                return String(value);
        }
    }
    /**
     * Format number
     * @param value - Number to format
     * @returns Formatted number
     * @private
     */
    _formatNumber(value) {
        if (typeof value !== 'number') {
            return String(value);
        }
        // Format based on magnitude
        if (Math.abs(value) >= 1000000) {
            return `${(value / 1000000).toFixed(1)}M`;
        }
        else if (Math.abs(value) >= 1000) {
            return `${(value / 1000).toFixed(1)}K`;
        }
        else if (Math.abs(value) < 1 && value !== 0) {
            return value.toFixed(2);
        }
        else {
            return value.toFixed(0);
        }
    }
    /**
     * Format percent
     * @param value - Percent to format
     * @returns Formatted percent
     * @private
     */
    _formatPercent(value) {
        if (typeof value !== 'number') {
            return String(value);
        }
        return `${(value * 100).toFixed(1)}%`;
    }
    /**
     * Format date
     * @param value - Date to format
     * @returns Formatted date
     * @private
     */
    _formatDate(value) {
        try {
            const date = new Date(value);
            return date.toLocaleDateString();
        }
        catch (error) {
            return String(value);
        }
    }
    /**
     * Format time
     * @param value - Time to format
     * @returns Formatted time
     * @private
     */
    _formatTime(value) {
        try {
            const date = new Date(value);
            return date.toLocaleTimeString();
        }
        catch (error) {
            return String(value);
        }
    }
    /**
     * Format date and time
     * @param value - Date and time to format
     * @returns Formatted date and time
     * @private
     */
    _formatDateTime(value) {
        try {
            const date = new Date(value);
            return date.toLocaleString();
        }
        catch (error) {
            return String(value);
        }
    }
    /**
     * Format duration
     * @param value - Duration in milliseconds
     * @returns Formatted duration
     * @private
     */
    _formatDuration(value) {
        if (typeof value !== 'number') {
            return String(value);
        }
        // Format based on magnitude
        if (value >= 86400000) {
            return `${(value / 86400000).toFixed(1)}d`;
        }
        else if (value >= 3600000) {
            return `${(value / 3600000).toFixed(1)}h`;
        }
        else if (value >= 60000) {
            return `${(value / 60000).toFixed(1)}m`;
        }
        else if (value >= 1000) {
            return `${(value / 1000).toFixed(1)}s`;
        }
        else {
            return `${value}ms`;
        }
    }
    /**
     * Log message if debug mode is enabled
     * @param message - Message to log
     * @private
     */
    log(message) {
        if (this.options.debugMode) {
            console.log(`[${this.name}Renderer] ${message}`);
        }
    }
}
export { BaseRenderer };
