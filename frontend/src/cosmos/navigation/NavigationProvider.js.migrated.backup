/**
 * Navigation Provider
 *
 * This component provides navigation context and state management
 * for the Wormhole Navigation System.
 *
 * @version 1.0.0
 */
import React, { createContext, useContext, useState, useCallback, useMemo } from 'react';
const NavigationContext = createContext(undefined);
/**
 * Navigation Provider Component
 */
export const NavigationProvider = ({ initialLevel, initialEntityId, initialEntityName, initialEntityColor, maxHistoryItems = 10, children, initialData, }) => {
    // State
    const [currentLevel, setCurrentLevel] = useState(initialLevel);
    const [currentEntityId, setCurrentEntityId] = useState(initialEntityId);
    const [currentEntityName, setCurrentEntityName] = useState(initialEntityName);
    const [currentEntityColor, setCurrentEntityColor] = useState(initialEntityColor);
    const [navigationHistory, setNavigationHistory] = useState([
        {
            level: initialLevel,
            entityId: initialEntityId,
            entityName: initialEntityName,
            entityColor: initialEntityColor,
            timestamp: Date.now(),
            data: initialData,
        },
    ]);
    const [data, setData] = useState(initialData);
    /**
     * Navigate to a specific level and entity
     */
    const navigateTo = useCallback((level, entityId, entityName, entityColor, customData) => {
        // Update current location
        setCurrentLevel(level);
        setCurrentEntityId(entityId);
        setCurrentEntityName(entityName);
        setCurrentEntityColor(entityColor);
        setData(customData);
        // Add to history
        setNavigationHistory((prevHistory) => {
            // Create new history item
            const newItem = {
                level,
                entityId,
                entityName,
                entityColor,
                timestamp: Date.now(),
                data: customData,
            };
            // Check if this is the same as the last item
            const lastItem = prevHistory[prevHistory.length - 1];
            if (lastItem && lastItem.level === level && lastItem.entityId === entityId) {
                return prevHistory;
            }
            // Add to history and limit size
            const newHistory = [...prevHistory, newItem];
            if (newHistory.length > maxHistoryItems) {
                return newHistory.slice(newHistory.length - maxHistoryItems);
            }
            return newHistory;
        });
    }, [maxHistoryItems]);
    /**
     * Navigate back in history
     */
    const navigateBack = useCallback(() => {
        // Don't navigate if history is empty
        if (navigationHistory.length <= 1)
            return;
        // Get previous item
        const previousItem = navigationHistory[navigationHistory.length - 2];
        // Update current location
        setCurrentLevel(previousItem.level);
        setCurrentEntityId(previousItem.entityId);
        setCurrentEntityName(previousItem.entityName);
        setCurrentEntityColor(previousItem.entityColor);
        setData(previousItem.data);
        // Remove current item from history
        setNavigationHistory((prevHistory) => prevHistory.slice(0, prevHistory.length - 1));
    }, [navigationHistory]);
    /**
     * Clear navigation history
     */
    const clearHistory = useCallback(() => {
        // Keep only current location
        setNavigationHistory([
            {
                level: currentLevel,
                entityId: currentEntityId,
                entityName: currentEntityName,
                entityColor: currentEntityColor,
                timestamp: Date.now(),
                data,
            },
        ]);
    }, [currentLevel, currentEntityId, currentEntityName, currentEntityColor, data]);
    // Create context value
    const contextValue = useMemo(() => ({
        currentLevel,
        currentEntityId,
        currentEntityName,
        currentEntityColor,
        navigationHistory,
        navigateTo,
        navigateBack,
        clearHistory,
        data,
    }), [
        currentLevel,
        currentEntityId,
        currentEntityName,
        currentEntityColor,
        navigationHistory,
        navigateTo,
        navigateBack,
        clearHistory,
        data,
    ]);
    return (<NavigationContext.Provider value={contextValue}>
      {children}
    </NavigationContext.Provider>);
};
/**
 * Use navigation hook
 */
export const useNavigation = () => {
    const context = useContext(NavigationContext);
    if (!context) {
        throw new Error('useNavigation must be used within a NavigationProvider');
    }
    return context;
};
export default NavigationProvider;
