// src/core/quantum-state/entanglement/entanglement-synchronization.ts
/**
 * Entanglement Synchronization Implementation
 *
 * This module implements the entanglement synchronization functionality for the QQ-Verse project,
 * ensuring synchronized state changes across entangled quantum states.
 */
import { produce } from 'immer';
// Import functions from other modules
import { transformState, verifyStateCoherence, repairStateCoherence, } from '../quantum-state';
/**
 * Default entanglement synchronization options
 */
export const defaultEntanglementSynchronizationOptions = {
    propagateTransformations: true,
    verifyBeforeSynchronization: true,
    verifyAfterSynchronization: true,
    repairIfVerificationFails: true,
    propagationThreshold: 0.1,
    transformationDecayFactor: 0.8,
};
/**
 * Creates a new entanglement registry
 *
 * @param options - Synchronization options
 * @returns A new entanglement registry
 */
export function createEntanglementRegistry(options = {}) {
    // Merge options with defaults
    const mergedOptions = {
        ...defaultEntanglementSynchronizationOptions,
        ...options,
    };
    // Create the registry
    const registry = {
        entries: [],
        options: mergedOptions,
    };
    return registry;
}
/**
 * Registers an entanglement between two quantum states
 *
 * @param registry - The entanglement registry
 * @param sourceState - The source quantum state
 * @param targetState - The target quantum state
 * @param type - The entanglement type
 * @param strength - The entanglement strength
 * @param coherence - The entanglement coherence
 * @returns The updated entanglement registry
 */
export function registerEntanglement(registry, sourceState, targetState, type = 'direct', strength = 1.0, coherence = 1.0) {
    return produce(registry, (draft) => {
        // Check if the entanglement already exists
        const existingEntryIndex = draft.entries.findIndex(entry => ((entry.sourceId === sourceState.id && entry.targetId === targetState.id) ||
            (entry.sourceId === targetState.id && entry.targetId === sourceState.id)));
        if (existingEntryIndex >= 0) {
            // Update the existing entry
            draft.entries[existingEntryIndex] = {
                sourceId: sourceState.id,
                targetId: targetState.id,
                type,
                strength,
                coherence,
                timestamp: new Date().toISOString(),
            };
        }
        else {
            // Add a new entry
            draft.entries.push({
                sourceId: sourceState.id,
                targetId: targetState.id,
                type,
                strength,
                coherence,
                timestamp: new Date().toISOString(),
            });
        }
    });
}
/**
 * Unregisters an entanglement between two quantum states
 *
 * @param registry - The entanglement registry
 * @param sourceState - The source quantum state
 * @param targetState - The target quantum state
 * @returns The updated entanglement registry
 */
export function unregisterEntanglement(registry, sourceState, targetState) {
    return produce(registry, (draft) => {
        // Remove the entanglement entry
        draft.entries = draft.entries.filter(entry => !((entry.sourceId === sourceState.id && entry.targetId === targetState.id) ||
            (entry.sourceId === targetState.id && entry.targetId === sourceState.id)));
    });
}
/**
 * Gets all entangled states for a quantum state
 *
 * @param registry - The entanglement registry
 * @param state - The quantum state
 * @returns The entangled state IDs
 */
export function getEntangledStateIds(registry, state) {
    // Find all entries involving the state
    const entries = registry.entries.filter(entry => entry.sourceId === state.id || entry.targetId === state.id);
    // Extract the entangled state IDs
    const entangledStateIds = entries.map(entry => entry.sourceId === state.id ? entry.targetId : entry.sourceId);
    return entangledStateIds;
}
/**
 * Gets the entanglement information between two quantum states
 *
 * @param registry - The entanglement registry
 * @param sourceState - The source quantum state
 * @param targetState - The target quantum state
 * @returns The entanglement information or undefined if not entangled
 */
export function getEntanglementInfo(registry, sourceState, targetState) {
    // Find the entanglement entry
    const entry = registry.entries.find(entry => ((entry.sourceId === sourceState.id && entry.targetId === targetState.id) ||
        (entry.sourceId === targetState.id && entry.targetId === sourceState.id)));
    return entry;
}
/**
 * Synchronizes a transformation across entangled quantum states
 *
 * @param registry - The entanglement registry
 * @param state - The quantum state being transformed
 * @param transformation - The transformation to apply
 * @param states - Map of state IDs to quantum states
 * @returns Map of state IDs to transformed quantum states
 */
export function synchronizeTransformation(registry, state, transformation, states) {
    // Create a new map for the transformed states
    const transformedStates = new Map(states);
    // Apply the transformation to the source state
    const transformedState = transformState(state, transformation);
    transformedStates.set(state.id, transformedState);
    // Check if we should propagate transformations
    if (!registry.options.propagateTransformations) {
        return transformedStates;
    }
    // Get all entangled state IDs
    const entangledStateIds = getEntangledStateIds(registry, state);
    // Process each entangled state
    for (const entangledStateId of entangledStateIds) {
        // Get the entangled state
        const entangledState = states.get(entangledStateId);
        if (!entangledState) {
            continue;
        }
        // Get the entanglement information
        const entanglementInfo = getEntanglementInfo(registry, state, entangledState);
        if (!entanglementInfo) {
            continue;
        }
        // Check if the entanglement strength is above the threshold
        if (entanglementInfo.strength < registry.options.propagationThreshold) {
            continue;
        }
        // Verify state coherence if needed
        if (registry.options.verifyBeforeSynchronization) {
            const verificationResult = verifyStateCoherence(entangledState);
            // Skip if verification fails and repair is not enabled
            if (!verificationResult.success && !registry.options.repairIfVerificationFails) {
                continue;
            }
            // Repair if verification fails and repair is enabled
            if (!verificationResult.success && registry.options.repairIfVerificationFails) {
                if (verificationResult.errors) {
                    const repairedState = repairStateCoherence(entangledState, verificationResult.errors);
                    transformedStates.set(entangledStateId, repairedState);
                    continue;
                }
            }
        }
        // Create a decayed transformation
        const decayedTransformation = {
            ...transformation,
            coherence: transformation.coherence * entanglementInfo.strength * registry.options.transformationDecayFactor,
        };
        // Apply the decayed transformation to the entangled state
        const transformedEntangledState = transformState(entangledState, decayedTransformation);
        // Verify state coherence if needed
        if (registry.options.verifyAfterSynchronization) {
            const verificationResult = verifyStateCoherence(transformedEntangledState);
            // Skip if verification fails and repair is not enabled
            if (!verificationResult.success && !registry.options.repairIfVerificationFails) {
                continue;
            }
            // Repair if verification fails and repair is enabled
            if (!verificationResult.success && registry.options.repairIfVerificationFails) {
                if (verificationResult.errors) {
                    const repairedState = repairStateCoherence(transformedEntangledState, verificationResult.errors);
                    transformedStates.set(entangledStateId, repairedState);
                    continue;
                }
            }
        }
        // Update the transformed states map
        transformedStates.set(entangledStateId, transformedEntangledState);
    }
    return transformedStates;
}
/**
 * Updates entanglement synchronization options
 *
 * @param registry - The entanglement registry
 * @param options - The new options
 * @returns The updated entanglement registry
 */
export function updateSynchronizationOptions(registry, options) {
    return produce(registry, (draft) => {
        // Update options
        draft.options = {
            ...draft.options,
            ...options,
        };
    });
}
